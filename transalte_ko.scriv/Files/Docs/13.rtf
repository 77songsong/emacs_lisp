{\rtf1\ansi\ansicpg949\cocoartf1187\cocoasubrtf340
{\fonttbl\f0\fnil\fcharset129 AppleSDGothicNeo-Regular;}
{\colortbl;\red255\green255\blue255;}
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\fi360\sl288\slmult1\pardirnatural

\f0\fs28 \cf0 \
@node Cutting & Storing Text, List Implementation, car cdr & cons, Top\
@comment  node-name,  next,  previous,  up\
@chapter Cutting and Storing Text\
@cindex Cutting and storing text\
@cindex Storing and cutting text\
@cindex Killing text\
@cindex Clipping text\
@cindex Erasing text\
@cindex Deleting text\
\
Whenever you cut or clip text out of a buffer with a `kill' command in\
GNU Emacs, it is stored in a list and you can bring it back with a\
`yank' command.\
\
(The use of the word `kill' in Emacs for processes which specifically\
@emph\{do not\} destroy the values of the entities is an unfortunate\
historical accident.  A much more appropriate word would be `clip' since\
that is what the kill commands do; they clip text out of a buffer and\
put it into storage from which it can be brought back.  I have often\
been tempted to replace globally all occurrences of `kill' in the Emacs\
sources with `clip' and all occurrences of `killed' with `clipped'.)\
\
@menu\
* Storing Text::                Text is stored in a list.\
* zap-to-char::                 Cutting out text up to a character.\
* kill-region::                 Cutting text out of a region.\
* copy-region-as-kill::         A definition for copying text.\
* Digression into C::           Minor note on C programming language macros.\
* defvar::                      How to give a variable an initial value.\
* cons & search-fwd Review::\
* search Exercises::\
@end menu\
\
@node Storing Text, zap-to-char, Cutting & Storing Text, Cutting & Storing Text\
@ifnottex\
@unnumberedsec Storing Text in a List\
@end ifnottex\
\
When text is cut out of a buffer, it is stored on a list.  Successive\
pieces of text are stored on the list successively, so the list might\
look like this:\
\
@smallexample\
("a piece of text" "previous piece")\
@end smallexample\
\
@need 1200\
@noindent\
The function @code\{cons\} can be used to create a new list from a piece\
of text (an `atom', to use the jargon) and an existing list, like\
this:\
\
@smallexample\
@group\
(cons "another piece"\
      '("a piece of text" "previous piece"))\
@end group\
@end smallexample\
\
@need 1200\
@noindent\
If you evaluate this expression, a list of three elements will appear in\
the echo area:\
\
@smallexample\
("another piece" "a piece of text" "previous piece")\
@end smallexample\
\
With the @code\{car\} and @code\{nthcdr\} functions, you can retrieve\
whichever piece of text you want.  For example, in the following code,\
@code\{nthcdr 1 @dots\{\}\} returns the list with the first item removed;\
and the @code\{car\} returns the first element of that remainder---the\
second element of the original list:\
\
@smallexample\
@group\
(car (nthcdr 1 '("another piece"\
                 "a piece of text"\
                 "previous piece")))\
     @result\{\} "a piece of text"\
@end group\
@end smallexample\
\
The actual functions in Emacs are more complex than this, of course.\
The code for cutting and retrieving text has to be written so that\
Emacs can figure out which element in the list you want---the first,\
second, third, or whatever.  In addition, when you get to the end of\
the list, Emacs should give you the first element of the list, rather\
than nothing at all.\
\
The list that holds the pieces of text is called the @dfn\{kill ring\}.\
This chapter leads up to a description of the kill ring and how it is\
used by first tracing how the @code\{zap-to-char\} function works.  This\
function uses (or `calls') a function that invokes a function that\
manipulates the kill ring.  Thus, before reaching the mountains, we\
climb the foothills.\
\
A subsequent chapter describes how text that is cut from the buffer is\
retrieved.  @xref\{Yanking, , Yanking Text Back\}.\
\
@node zap-to-char, kill-region, Storing Text, Cutting & Storing Text\
@comment  node-name,  next,  previous,  up\
@section @code\{zap-to-char\}\
@findex zap-to-char\
\
The @code\{zap-to-char\} function changed little between GNU Emacs\
version 19 and GNU Emacs version 22.  However, @code\{zap-to-char\}\
calls another function, @code\{kill-region\}, which enjoyed a major\
rewrite.\
\
The @code\{kill-region\} function in Emacs 19 is complex, but does not\
use code that is important at this time.  We will skip it.\
\
The @code\{kill-region\} function in Emacs 22 is easier to read than the\
same function in Emacs 19 and introduces a very important concept,\
that of error handling.  We will walk through the function.\
\
But first, let us look at the interactive @code\{zap-to-char\} function.\
\
@menu\
* Complete zap-to-char::        The complete implementation.\
* zap-to-char interactive::     A three part interactive expression.\
* zap-to-char body::            A short overview.\
* search-forward::              How to search for a string.\
* progn::                       The @code\{progn\} special form.\
* Summing up zap-to-char::      Using @code\{point\} and @code\{search-forward\}.\
@end menu\
\
@node Complete zap-to-char, zap-to-char interactive, zap-to-char, zap-to-char\
@ifnottex\
@unnumberedsubsec The Complete @code\{zap-to-char\} Implementation\
@end ifnottex\
\
The @code\{zap-to-char\} function removes the text in the region between\
the location of the cursor (i.e., of point) up to and including the\
next occurrence of a specified character.  The text that\
@code\{zap-to-char\} removes is put in the kill ring; and it can be\
retrieved from the kill ring by typing @kbd\{C-y\} (@code\{yank\}).  If\
the command is given an argument, it removes text through that number\
of occurrences.  Thus, if the cursor were at the beginning of this\
sentence and the character were @samp\{s\}, @samp\{Thus\} would be\
removed.  If the argument were two, @samp\{Thus, if the curs\} would be\
removed, up to and including the @samp\{s\} in @samp\{cursor\}.\
\
If the specified character is not found, @code\{zap-to-char\} will say\
``Search failed'', tell you the character you typed, and not remove\
any text.\
\
In order to determine how much text to remove, @code\{zap-to-char\} uses\
a search function.  Searches are used extensively in code that\
manipulates text, and we will focus attention on them as well as on the\
deletion command.\
\
@ignore\
@c GNU Emacs version 19\
(defun zap-to-char (arg char)  ; version 19 implementation\
  "Kill up to and including ARG'th occurrence of CHAR.\
Goes backward if ARG is negative; error if CHAR not found."\
  (interactive "*p\\ncZap to char: ")\
  (kill-region (point)\
               (progn\
                 (search-forward\
                  (char-to-string char) nil nil arg)\
                 (point))))\
@end ignore\
\
@need 1250\
Here is the complete text of the version 22 implementation of the function:\
\
@c GNU Emacs 22\
@smallexample\
@group\
(defun zap-to-char (arg char)\
  "Kill up to and including ARG'th occurrence of CHAR.\
Case is ignored if `case-fold-search' is non-nil in the current buffer.\
Goes backward if ARG is negative; error if CHAR not found."\
  (interactive "p\\ncZap to char: ")\
  (if (char-table-p translation-table-for-input)\
      (setq char (or (aref translation-table-for-input char) char)))\
  (kill-region (point) (progn\
                         (search-forward (char-to-string char)\
                                         nil nil arg)\
                         (point))))\
@end group\
@end smallexample\
\
The documentation is thorough.  You do need to know the jargon meaning\
of the word `kill'.\
\
@node zap-to-char interactive, zap-to-char body, Complete zap-to-char, zap-to-char\
@comment  node-name,  next,  previous,  up\
@subsection The @code\{interactive\} Expression\
\
@need 800\
The interactive expression in the @code\{zap-to-char\} command looks like\
this:\
\
@smallexample\
(interactive "p\\ncZap to char: ")\
@end smallexample\
\
The part within quotation marks, @code\{"p\\ncZap to char:@: "\}, specifies\
two different things.  First, and most simply, is the @samp\{p\}.\
This part is separated from the next part by a newline, @samp\{\\n\}.\
The @samp\{p\} means that the first argument to the function will be\
passed the value of a `processed prefix'.  The prefix argument is\
passed by typing @kbd\{C-u\} and a number, or @kbd\{M-\} and a number.  If\
the function is called interactively without a prefix, 1 is passed to\
this argument.\
\
The second part of @code\{"p\\ncZap to char:@: "\} is\
@samp\{cZap to char:@:  \}.  In this part, the lower case @samp\{c\}\
indicates that @code\{interactive\} expects a prompt and that the\
argument will be a character.  The prompt follows the @samp\{c\} and is\
the string @samp\{Zap to char:@: \} (with a space after the colon to\
make it look good).\
\
What all this does is prepare the arguments to @code\{zap-to-char\} so they\
are of the right type, and give the user a prompt.\
\
In a read-only buffer, the @code\{zap-to-char\} function copies the text\
to the kill ring, but does not remove it.  The echo area displays a\
message saying that the buffer is read-only.  Also, the terminal may\
beep or blink at you.\
\
@node zap-to-char body, search-forward, zap-to-char interactive, zap-to-char\
@comment  node-name,  next,  previous,  up\
@subsection The Body of @code\{zap-to-char\}\
\
The body of the @code\{zap-to-char\} function contains the code that\
kills (that is, removes) the text in the region from the current\
position of the cursor up to and including the specified character.\
\
The first part of the code looks like this:\
\
@smallexample\
(if (char-table-p translation-table-for-input)\
    (setq char (or (aref translation-table-for-input char) char)))\
(kill-region (point) (progn\
                       (search-forward (char-to-string char) nil nil arg)\
                       (point)))\
@end smallexample\
\
@noindent\
@code\{char-table-p\} is an hitherto unseen function.  It determines\
whether its argument is a character table.  When it is, it sets the\
character passed to @code\{zap-to-char\} to one of them, if that\
character exists, or to the character itself.  (This becomes important\
for certain characters in non-European languages.  The @code\{aref\}\
function extracts an element from an array.  It is an array-specific\
function that is not described in this document.  @xref\{Arrays, ,\
Arrays, elisp, The GNU Emacs Lisp Reference Manual\}.)\
\
@noindent\
@code\{(point)\} is the current position of the cursor.\
\
The next part of the code is an expression using @code\{progn\}.  The body\
of the @code\{progn\} consists of calls to @code\{search-forward\} and\
@code\{point\}.\
\
It is easier to understand how @code\{progn\} works after learning about\
@code\{search-forward\}, so we will look at @code\{search-forward\} and\
then at @code\{progn\}.\
\
@node search-forward, progn, zap-to-char body, zap-to-char\
@comment  node-name,  next,  previous,  up\
@subsection The @code\{search-forward\} Function\
@findex search-forward\
\
The @code\{search-forward\} function is used to locate the\
zapped-for-character in @code\{zap-to-char\}.  If the search is\
successful, @code\{search-forward\} leaves point immediately after the\
last character in the target string.  (In @code\{zap-to-char\}, the\
target string is just one character long.  @code\{zap-to-char\} uses the\
function @code\{char-to-string\} to ensure that the computer treats that\
character as a string.)  If the search is backwards,\
@code\{search-forward\} leaves point just before the first character in\
the target.  Also, @code\{search-forward\} returns @code\{t\} for true.\
(Moving point is therefore a `side effect'.)\
\
@need 1250\
In @code\{zap-to-char\}, the @code\{search-forward\} function looks like this:\
\
@smallexample\
(search-forward (char-to-string char) nil nil arg)\
@end smallexample\
\
The @code\{search-forward\} function takes four arguments:\
\
@enumerate\
@item\
The first argument is the target, what is searched for.  This must be a\
string, such as @samp\{"z"\}.\
\
As it happens, the argument passed to @code\{zap-to-char\} is a single\
character.  Because of the way computers are built, the Lisp\
interpreter may treat a single character as being different from a\
string of characters.  Inside the computer, a single character has a\
different electronic format than a string of one character.  (A single\
character can often be recorded in the computer using exactly one\
byte; but a string may be longer, and the computer needs to be ready\
for this.)  Since the @code\{search-forward\} function searches for a\
string, the character that the @code\{zap-to-char\} function receives as\
its argument must be converted inside the computer from one format to\
the other; otherwise the @code\{search-forward\} function will fail.\
The @code\{char-to-string\} function is used to make this conversion.\
\
@item\
The second argument bounds the search; it is specified as a position in\
the buffer.  In this case, the search can go to the end of the buffer,\
so no bound is set and the second argument is @code\{nil\}.\
\
@item\
The third argument tells the function what it should do if the search\
fails---it can signal an error (and print a message) or it can return\
@code\{nil\}.  A @code\{nil\} as the third argument causes the function to\
signal an error when the search fails.\
\
@item\
The fourth argument to @code\{search-forward\} is the repeat count---how\
many occurrences of the string to look for.  This argument is optional\
and if the function is called without a repeat count, this argument is\
passed the value 1.  If this argument is negative, the search goes\
backwards.\
@end enumerate\
\
@need 800\
In template form, a @code\{search-forward\} expression looks like this:\
\
@smallexample\
@group\
(search-forward "@var\{target-string\}"\
                @var\{limit-of-search\}\
                @var\{what-to-do-if-search-fails\}\
                @var\{repeat-count\})\
@end group\
@end smallexample\
\
We will look at @code\{progn\} next.\
\
@node progn, Summing up zap-to-char, search-forward, zap-to-char\
@comment  node-name,  next,  previous,  up\
@subsection The @code\{progn\} Special Form\
@findex progn\
\
@code\{progn\} is a special form that causes each of its arguments to be\
evaluated in sequence and then returns the value of the last one.  The\
preceding expressions are evaluated only for the side effects they\
perform.  The values produced by them are discarded.\
\
@need 800\
The template for a @code\{progn\} expression is very simple:\
\
@smallexample\
@group\
(progn\
  @var\{body\}@dots\{\})\
@end group\
@end smallexample\
\
In @code\{zap-to-char\}, the @code\{progn\} expression has to do two things:\
put point in exactly the right position; and return the location of\
point so that @code\{kill-region\} will know how far to kill to.\
\
The first argument to the @code\{progn\} is @code\{search-forward\}.  When\
@code\{search-forward\} finds the string, the function leaves point\
immediately after the last character in the target string.  (In this\
case the target string is just one character long.)  If the search is\
backwards, @code\{search-forward\} leaves point just before the first\
character in the target.  The movement of point is a side effect.\
\
The second and last argument to @code\{progn\} is the expression\
@code\{(point)\}.  This expression returns the value of point, which in\
this case will be the location to which it has been moved by\
@code\{search-forward\}.  (In the source, a line that tells the function\
to go to the previous character, if it is going forward, was commented\
out in 1999; I don't remember whether that feature or mis-feature was\
ever a part of the distributed source.)  The value of @code\{point\} is\
returned by the @code\{progn\} expression and is passed to\
@code\{kill-region\} as @code\{kill-region\}'s second argument.\
\
@node Summing up zap-to-char,  , progn, zap-to-char\
@comment  node-name,  next,  previous,  up\
@subsection Summing up @code\{zap-to-char\}\
\
Now that we have seen how @code\{search-forward\} and @code\{progn\} work,\
we can see how the @code\{zap-to-char\} function works as a whole.\
\
The first argument to @code\{kill-region\} is the position of the cursor\
when the @code\{zap-to-char\} command is given---the value of point at\
that time.  Within the @code\{progn\}, the search function then moves\
point to just after the zapped-to-character and @code\{point\} returns the\
value of this location.  The @code\{kill-region\} function puts together\
these two values of point, the first one as the beginning of the region\
and the second one as the end of the region, and removes the region.\
\
The @code\{progn\} special form is necessary because the\
@code\{kill-region\} command takes two arguments; and it would fail if\
@code\{search-forward\} and @code\{point\} expressions were written in\
sequence as two additional arguments.  The @code\{progn\} expression is\
a single argument to @code\{kill-region\} and returns the one value that\
@code\{kill-region\} needs for its second argument.\
\
@node kill-region, copy-region-as-kill, zap-to-char, Cutting & Storing Text\
@comment  node-name,  next,  previous,  up\
@section @code\{kill-region\}\
@findex kill-region\
\
The @code\{zap-to-char\} function uses the @code\{kill-region\} function.\
This function clips text from a region and copies that text to\
the kill ring, from which it may be retrieved.\
\
@ignore\
GNU Emacs 22:\
\
(defun kill-region (beg end &optional yank-handler)\
  "Kill (\\"cut\\") text between point and mark.\
This deletes the text from the buffer and saves it in the kill ring.\
The command \\\\[yank] can retrieve it from there.\
\\(If you want to kill and then yank immediately, use \\\\[kill-ring-save].)\
\
If you want to append the killed region to the last killed text,\
use \\\\[append-next-kill] before \\\\[kill-region].\
\
If the buffer is read-only, Emacs will beep and refrain from deleting\
the text, but put the text in the kill ring anyway.  This means that\
you can use the killing commands to copy text from a read-only buffer.\
\
This is the primitive for programs to kill text (as opposed to deleting it).\
Supply two arguments, character positions indicating the stretch of text\
 to be killed.\
Any command that calls this function is a \\"kill command\\".\
If the previous command was also a kill command,\
the text killed this time appends to the text killed last time\
to make one entry in the kill ring.\
\
In Lisp code, optional third arg YANK-HANDLER, if non-nil,\
specifies the yank-handler text property to be set on the killed\
text.  See `insert-for-yank'."\
  ;; Pass point first, then mark, because the order matters\
  ;; when calling kill-append.\
  (interactive (list (point) (mark)))\
  (unless (and beg end)\
    (error "The mark is not set now, so there is no region"))\
  (condition-case nil\
      (let ((string (filter-buffer-substring beg end t)))\
        (when string                        ;STRING is nil if BEG = END\
          ;; Add that string to the kill ring, one way or another.\
          (if (eq last-command 'kill-region)\
              (kill-append string (< end beg) yank-handler)\
            (kill-new string nil yank-handler)))\
        (when (or string (eq last-command 'kill-region))\
          (setq this-command 'kill-region))\
        nil)\
    ((buffer-read-only text-read-only)\
     ;; The code above failed because the buffer, or some of the characters\
     ;; in the region, are read-only.\
     ;; We should beep, in case the user just isn't aware of this.\
     ;; However, there's no harm in putting\
     ;; the region's text in the kill ring, anyway.\
     (copy-region-as-kill beg end)\
     ;; Set this-command now, so it will be set even if we get an error.\
     (setq this-command 'kill-region)\
     ;; This should barf, if appropriate, and give us the correct error.\
     (if kill-read-only-ok\
         (progn (message "Read only text copied to kill ring") nil)\
       ;; Signal an error if the buffer is read-only.\
       (barf-if-buffer-read-only)\
       ;; If the buffer isn't read-only, the text is.\
       (signal 'text-read-only (list (current-buffer)))))))\
@end ignore\
\
The Emacs 22 version of that function uses @code\{condition-case\} and\
@code\{copy-region-as-kill\}, both of which we will explain.\
@code\{condition-case\} is an important special form.\
\
In essence, the @code\{kill-region\} function calls\
@code\{condition-case\}, which takes three arguments.  In this function,\
the first argument does nothing.  The second argument contains the\
code that does the work when all goes well.  The third argument\
contains the code that is called in the event of an error.\
\
@menu\
* Complete kill-region::        The function definition.\
* condition-case::              Dealing with a problem.\
* Lisp macro::\
@end menu\
\
@node Complete kill-region, condition-case, kill-region, kill-region\
@ifnottex\
@unnumberedsubsec The Complete @code\{kill-region\} Definition\
@end ifnottex\
\
@need 1200\
We will go through the @code\{condition-case\} code in a moment.  First,\
let us look at the definition of @code\{kill-region\}, with comments\
added:\
\
@c GNU Emacs 22:\
@smallexample\
@group\
(defun kill-region (beg end)\
  "Kill (\\"cut\\") text between point and mark.\
This deletes the text from the buffer and saves it in the kill ring.\
The command \\\\[yank] can retrieve it from there. @dots\{\} "\
@end group\
\
@group\
  ;; @bullet\{\} Since order matters, pass point first.\
  (interactive (list (point) (mark)))\
  ;; @bullet\{\} And tell us if we cannot cut the text.\
  ;; `unless' is an `if' without a then-part.\
  (unless (and beg end)\
    (error "The mark is not set now, so there is no region"))\
@end group\
\
@group\
  ;; @bullet\{\} `condition-case' takes three arguments.\
  ;;    If the first argument is nil, as it is here,\
  ;;    information about the error signal is not\
  ;;    stored for use by another function.\
  (condition-case nil\
@end group\
\
@group\
      ;; @bullet\{\} The second argument to `condition-case' tells the\
      ;;    Lisp interpreter what to do when all goes well.\
@end group\
\
@group\
      ;;    It starts with a `let' function that extracts the string\
      ;;    and tests whether it exists.  If so (that is what the\
      ;;    `when' checks), it calls an `if' function that determines\
      ;;    whether the previous command was another call to\
      ;;    `kill-region'; if it was, then the new text is appended to\
      ;;    the previous text; if not, then a different function,\
      ;;    `kill-new', is called.\
@end group\
\
@group\
      ;;    The `kill-append' function concatenates the new string and\
      ;;    the old.  The `kill-new' function inserts text into a new\
      ;;    item in the kill ring.\
@end group\
\
@group\
      ;;    `when' is an `if' without an else-part.  The second `when'\
      ;;    again checks whether the current string exists; in\
      ;;    addition, it checks whether the previous command was\
      ;;    another call to `kill-region'.  If one or the other\
      ;;    condition is true, then it sets the current command to\
      ;;    be `kill-region'.\
@end group\
@group\
      (let ((string (filter-buffer-substring beg end t)))\
        (when string                    ;STRING is nil if BEG = END\
          ;; Add that string to the kill ring, one way or another.\
          (if (eq last-command 'kill-region)\
@end group\
@group\
              ;;    @minus\{\} `yank-handler' is an optional argument to\
              ;;    `kill-region' that tells the `kill-append' and\
              ;;    `kill-new' functions how deal with properties\
              ;;    added to the text, such as `bold' or `italics'.\
              (kill-append string (< end beg) yank-handler)\
            (kill-new string nil yank-handler)))\
        (when (or string (eq last-command 'kill-region))\
          (setq this-command 'kill-region))\
        nil)\
@end group\
\
@group\
    ;;  @bullet\{\} The third argument to `condition-case' tells the interpreter\
    ;;    what to do with an error.\
@end group\
@group\
    ;;    The third argument has a conditions part and a body part.\
    ;;    If the conditions are met (in this case,\
    ;;             if text or buffer are read-only)\
    ;;    then the body is executed.\
@end group\
@group\
    ;;    The first part of the third argument is the following:\
    ((buffer-read-only text-read-only) ;; the if-part\
     ;; @dots\{\}  the then-part\
     (copy-region-as-kill beg end)\
@end group\
@group\
     ;;    Next, also as part of the then-part, set this-command, so\
     ;;    it will be set in an error\
     (setq this-command 'kill-region)\
     ;;    Finally, in the then-part, send a message if you may copy\
     ;;    the text to the kill ring without signally an error, but\
     ;;    don't if you may not.\
@end group\
@group\
     (if kill-read-only-ok\
         (progn (message "Read only text copied to kill ring") nil)\
       (barf-if-buffer-read-only)\
       ;; If the buffer isn't read-only, the text is.\
       (signal 'text-read-only (list (current-buffer)))))\
@end group\
@end smallexample\
\
@ignore\
@c v 21\
@smallexample\
@group\
(defun kill-region (beg end)\
  "Kill between point and mark.\
The text is deleted but saved in the kill ring."\
  (interactive "r")\
@end group\
\
@group\
  ;; 1. `condition-case' takes three arguments.\
  ;;    If the first argument is nil, as it is here,\
  ;;    information about the error signal is not\
  ;;    stored for use by another function.\
  (condition-case nil\
@end group\
\
@group\
      ;; 2. The second argument to `condition-case'\
      ;;    tells the Lisp interpreter what to do when all goes well.\
@end group\
\
@group\
      ;;    The `delete-and-extract-region' function usually does the\
      ;;    work.  If the beginning and ending of the region are both\
      ;;    the same, then the variable `string' will be empty, or nil\
      (let ((string (delete-and-extract-region beg end)))\
@end group\
\
@group\
        ;; `when' is an `if' clause that cannot take an `else-part'.\
        ;; Emacs normally sets the value of `last-command' to the\
        ;; previous command.\
@end group\
@group\
        ;; `kill-append' concatenates the new string and the old.\
        ;; `kill-new' inserts text into a new item in the kill ring.\
        (when string\
          (if (eq last-command 'kill-region)\
              ;; if true, prepend string\
              (kill-append string (< end beg))\
            (kill-new string)))\
        (setq this-command 'kill-region))\
@end group\
\
@group\
    ;; 3. The third argument to `condition-case' tells the interpreter\
    ;;    what to do with an error.\
@end group\
@group\
    ;;    The third argument has a conditions part and a body part.\
    ;;    If the conditions are met (in this case,\
    ;;             if text or buffer are read-only)\
    ;;    then the body is executed.\
@end group\
@group\
    ((buffer-read-only text-read-only) ;; this is the if-part\
     ;; then...\
     (copy-region-as-kill beg end)\
@end group\
@group\
     (if kill-read-only-ok            ;; usually this variable is nil\
         (message "Read only text copied to kill ring")\
       ;; or else, signal an error if the buffer is read-only;\
       (barf-if-buffer-read-only)\
       ;; and, in any case, signal that the text is read-only.\
       (signal 'text-read-only (list (current-buffer)))))))\
@end group\
@end smallexample\
@end ignore\
\
@node condition-case, Lisp macro, Complete kill-region, kill-region\
@comment  node-name,  next,  previous,  up\
@subsection @code\{condition-case\}\
@findex condition-case\
\
As we have seen earlier (@pxref\{Making Errors, , Generate an Error\
Message\}), when the Emacs Lisp interpreter has trouble evaluating an\
expression, it provides you with help; in the jargon, this is called\
``signaling an error''.  Usually, the computer stops the program and\
shows you a message.\
\
However, some programs undertake complicated actions.  They should not\
simply stop on an error.  In the @code\{kill-region\} function, the most\
likely error is that you will try to kill text that is read-only and\
cannot be removed.  So the @code\{kill-region\} function contains code\
to handle this circumstance.  This code, which makes up the body of\
the @code\{kill-region\} function, is inside of a @code\{condition-case\}\
special form.\
\
@need 800\
The template for @code\{condition-case\} looks like this:\
\
@smallexample\
@group\
(condition-case\
  @var\{var\}\
  @var\{bodyform\}\
  @var\{error-handler\}@dots\{\})\
@end group\
@end smallexample\
\
The second argument, @var\{bodyform\}, is straightforward.  The\
@code\{condition-case\} special form causes the Lisp interpreter to\
evaluate the code in @var\{bodyform\}.  If no error occurs, the special\
form returns the code's value and produces the side-effects, if any.\
\
In short, the @var\{bodyform\} part of a @code\{condition-case\}\
expression determines what should happen when everything works\
correctly.\
\
However, if an error occurs, among its other actions, the function\
generating the error signal will define one or more error condition\
names.\
\
An error handler is the third argument to @code\{condition case\}.\
An error handler has two parts, a @var\{condition-name\} and a\
@var\{body\}.  If the @var\{condition-name\} part of an error handler\
matches a condition name generated by an error, then the @var\{body\}\
part of the error handler is run.\
\
As you will expect, the @var\{condition-name\} part of an error handler\
may be either a single condition name or a list of condition names.\
\
Also, a complete @code\{condition-case\} expression may contain more\
than one error handler.  When an error occurs, the first applicable\
handler is run.\
\
Lastly, the first argument to the @code\{condition-case\} expression,\
the @var\{var\} argument, is sometimes bound to a variable that\
contains information about the error.  However, if that argument is\
nil, as is the case in @code\{kill-region\}, that information is\
discarded.\
\
@need 1200\
In brief, in the @code\{kill-region\} function, the code\
@code\{condition-case\} works like this:\
\
@smallexample\
@group\
@var\{If no errors\}, @var\{run only this code\}\
    @var\{but\}, @var\{if errors\}, @var\{run this other code\}.\
@end group\
@end smallexample\
\
@ignore\
2006 Oct 24\
In Emacs 22,\
copy-region-as-kill is short, 12 lines, and uses\
filter-buffer-substring, which is longer, 39 lines\
and has delete-and-extract-region in it.\
delete-and-extract-region is written in C.\
\
see Initializing a Variable with @code\{defvar\}\
this is line 8054\
Initializing a Variable with @code\{defvar\} includes line 8350\
@end ignore\
\
@node Lisp macro,  , condition-case, kill-region\
@comment  node-name,  next,  previous,  up\
@subsection Lisp macro\
@cindex Macro, lisp\
@cindex Lisp macro\
\
The part of the @code\{condition-case\} expression that is evaluated in\
the expectation that all goes well has a @code\{when\}.  The code uses\
@code\{when\} to determine whether the @code\{string\} variable points to\
text that exists.\
\
A @code\{when\} expression is simply a programmers' convenience.  It is\
an @code\{if\} without the possibility of an else clause.  In your mind,\
you can replace @code\{when\} with @code\{if\} and understand what goes\
on.  That is what the Lisp interpreter does.\
\
Technically speaking, @code\{when\} is a Lisp macro.  A Lisp @dfn\{macro\}\
enables you to define new control constructs and other language\
features.  It tells the interpreter how to compute another Lisp\
expression which will in turn compute the value.  In this case, the\
`other expression' is an @code\{if\} expression.\
\
The @code\{kill-region\} function definition also has an @code\{unless\}\
macro; it is the converse of @code\{when\}.  The @code\{unless\} macro is\
an @code\{if\} without a then clause\
\
For more about Lisp macros, see @ref\{Macros, , Macros, elisp, The GNU\
Emacs Lisp Reference Manual\}.  The C programming language also\
provides macros.  These are different, but also useful.\
\
@ignore\
We will briefly look at C macros in\
@ref\{Digression into C\}.\
@end ignore\
\
@need 1200\
Regarding the @code\{when\} macro, in the @code\{condition-case\}\
expression, when the string has content, then another conditional\
expression is executed.  This is an @code\{if\} with both a then-part\
and an else-part.\
\
@smallexample\
@group\
(if (eq last-command 'kill-region)\
    (kill-append string (< end beg) yank-handler)\
  (kill-new string nil yank-handler))\
@end group\
@end smallexample\
\
The then-part is evaluated if the previous command was another call to\
@code\{kill-region\}; if not, the else-part is evaluated.\
\
@code\{yank-handler\} is an optional argument to @code\{kill-region\} that\
tells the @code\{kill-append\} and @code\{kill-new\} functions how deal\
with properties added to the text, such as `bold' or `italics'.\
\
@code\{last-command\} is a variable that comes with Emacs that we have\
not seen before.  Normally, whenever a function is executed, Emacs\
sets the value of @code\{last-command\} to the previous command.\
\
@need 1200\
In this segment of the definition, the @code\{if\} expression checks\
whether the previous command was @code\{kill-region\}.  If it was,\
\
@smallexample\
(kill-append string (< end beg) yank-handler)\
@end smallexample\
\
@noindent\
concatenates a copy of the newly clipped text to the just previously\
clipped text in the kill ring.\
\
@node copy-region-as-kill, Digression into C, kill-region, Cutting & Storing Text\
@comment  node-name,  next,  previous,  up\
@section @code\{copy-region-as-kill\}\
@findex copy-region-as-kill\
@findex nthcdr\
\
The @code\{copy-region-as-kill\} function copies a region of text from a\
buffer and (via either @code\{kill-append\} or @code\{kill-new\}) saves it\
in the @code\{kill-ring\}.\
\
If you call @code\{copy-region-as-kill\} immediately after a\
@code\{kill-region\} command, Emacs appends the newly copied text to the\
previously copied text.  This means that if you yank back the text, you\
get it all, from both this and the previous operation.  On the other\
hand, if some other command precedes the @code\{copy-region-as-kill\},\
the function copies the text into a separate entry in the kill ring.\
\
@menu\
* Complete copy-region-as-kill::  The complete function definition.\
* copy-region-as-kill body::      The body of @code\{copy-region-as-kill\}.\
@end menu\
\
@node Complete copy-region-as-kill, copy-region-as-kill body, copy-region-as-kill, copy-region-as-kill\
@ifnottex\
@unnumberedsubsec The complete @code\{copy-region-as-kill\} function definition\
@end ifnottex\
\
@need 1200\
Here is the complete text of the version 22 @code\{copy-region-as-kill\}\
function:\
\
@smallexample\
@group\
(defun copy-region-as-kill (beg end)\
  "Save the region as if killed, but don't kill it.\
In Transient Mark mode, deactivate the mark.\
If `interprogram-cut-function' is non-nil, also save the text for a window\
system cut and paste."\
  (interactive "r")\
@end group\
@group\
  (if (eq last-command 'kill-region)\
      (kill-append (filter-buffer-substring beg end) (< end beg))\
    (kill-new (filter-buffer-substring beg end)))\
@end group\
@group\
  (if transient-mark-mode\
      (setq deactivate-mark t))\
  nil)\
@end group\
@end smallexample\
\
@need 800\
As usual, this function can be divided into its component parts:\
\
@smallexample\
@group\
(defun copy-region-as-kill (@var\{argument-list\})\
  "@var\{documentation\}@dots\{\}"\
  (interactive "r")\
  @var\{body\}@dots\{\})\
@end group\
@end smallexample\
\
The arguments are @code\{beg\} and @code\{end\} and the function is\
interactive with @code\{"r"\}, so the two arguments must refer to the\
beginning and end of the region.  If you have been reading though this\
document from the beginning, understanding these parts of a function is\
almost becoming routine.\
\
The documentation is somewhat confusing unless you remember that the\
word `kill' has a meaning different from usual.  The `Transient Mark'\
and @code\{interprogram-cut-function\} comments explain certain\
side-effects.\
\
After you once set a mark, a buffer always contains a region.  If you\
wish, you can use Transient Mark mode to highlight the region\
temporarily.  (No one wants to highlight the region all the time, so\
Transient Mark mode highlights it only at appropriate times.  Many\
people turn off Transient Mark mode, so the region is never\
highlighted.)\
\
Also, a windowing system allows you to copy, cut, and paste among\
different programs.  In the X windowing system, for example, the\
@code\{interprogram-cut-function\} function is @code\{x-select-text\},\
which works with the windowing system's equivalent of the Emacs kill\
ring.\
\
The body of the @code\{copy-region-as-kill\} function starts with an\
@code\{if\} clause.  What this clause does is distinguish between two\
different situations: whether or not this command is executed\
immediately after a previous @code\{kill-region\} command.  In the first\
case, the new region is appended to the previously copied text.\
Otherwise, it is inserted into the beginning of the kill ring as a\
separate piece of text from the previous piece.\
\
The last two lines of the function prevent the region from lighting up\
if Transient Mark mode is turned on.\
\
The body of @code\{copy-region-as-kill\} merits discussion in detail.\
\
@node copy-region-as-kill body,  , Complete copy-region-as-kill, copy-region-as-kill\
@comment  node-name,  next,  previous,  up\
@subsection The Body of @code\{copy-region-as-kill\}\
\
The @code\{copy-region-as-kill\} function works in much the same way as\
the @code\{kill-region\} function.  Both are written so that two or more\
kills in a row combine their text into a single entry.  If you yank\
back the text from the kill ring, you get it all in one piece.\
Moreover, kills that kill forward from the current position of the\
cursor are added to the end of the previously copied text and commands\
that copy text backwards add it to the beginning of the previously\
copied text.  This way, the words in the text stay in the proper\
order.\
\
Like @code\{kill-region\}, the @code\{copy-region-as-kill\} function makes\
use of the @code\{last-command\} variable that keeps track of the\
previous Emacs command.\
\
@menu\
* last-command & this-command::\
* kill-append function::\
* kill-new function::\
@end menu\
\
@node last-command & this-command, kill-append function, copy-region-as-kill body, copy-region-as-kill body\
@ifnottex\
@unnumberedsubsubsec @code\{last-command\} and @code\{this-command\}\
@end ifnottex\
\
Normally, whenever a function is executed, Emacs sets the value of\
@code\{this-command\} to the function being executed (which in this case\
would be @code\{copy-region-as-kill\}).  At the same time, Emacs sets\
the value of @code\{last-command\} to the previous value of\
@code\{this-command\}.\
\
In the first part of the body of the @code\{copy-region-as-kill\}\
function, an @code\{if\} expression determines whether the value of\
@code\{last-command\} is @code\{kill-region\}.  If so, the then-part of\
the @code\{if\} expression is evaluated; it uses the @code\{kill-append\}\
function to concatenate the text copied at this call to the function\
with the text already in the first element (the @sc\{car\}) of the kill\
ring.  On the other hand, if the value of @code\{last-command\} is not\
@code\{kill-region\}, then the @code\{copy-region-as-kill\} function\
attaches a new element to the kill ring using the @code\{kill-new\}\
function.\
\
@need 1250\
The @code\{if\} expression reads as follows; it uses @code\{eq\}:\
\
@smallexample\
@group\
  (if (eq last-command 'kill-region)\
      ;; @r\{then-part\}\
      (kill-append  (filter-buffer-substring beg end) (< end beg))\
    ;; @r\{else-part\}\
    (kill-new  (filter-buffer-substring beg end)))\
@end group\
@end smallexample\
\
@findex filter-buffer-substring\
(The @code\{filter-buffer-substring\} function returns a filtered\
substring of the buffer, if any.  Optionally---the arguments are not\
here, so neither is done---the function may delete the initial text or\
return the text without its properties; this function is a replacement\
for the older @code\{buffer-substring\} function, which came before text\
properties were implemented.)\
\
@findex eq @r\{(example of use)\}\
@noindent\
The @code\{eq\} function tests whether its first argument is the same Lisp\
object as its second argument.  The @code\{eq\} function is similar to the\
@code\{equal\} function in that it is used to test for equality, but\
differs in that it determines whether two representations are actually\
the same object inside the computer, but with different names.\
@code\{equal\} determines whether the structure and contents of two\
expressions are the same.\
\
If the previous command was @code\{kill-region\}, then the Emacs Lisp\
interpreter calls the @code\{kill-append\} function\
\
@node kill-append function, kill-new function, last-command & this-command, copy-region-as-kill body\
@unnumberedsubsubsec The @code\{kill-append\} function\
@findex kill-append\
\
@need 800\
The @code\{kill-append\} function looks like this:\
\
@c in GNU Emacs 22\
@smallexample\
@group\
(defun kill-append (string before-p &optional yank-handler)\
  "Append STRING to the end of the latest kill in the kill ring.\
If BEFORE-P is non-nil, prepend STRING to the kill.\
@dots\{\} "\
  (let* ((cur (car kill-ring)))\
    (kill-new (if before-p (concat string cur) (concat cur string))\
              (or (= (length cur) 0)\
                  (equal yank-handler\
                         (get-text-property 0 'yank-handler cur)))\
              yank-handler)))\
@end group\
@end smallexample\
\
@ignore\
was:\
(defun kill-append (string before-p)\
  "Append STRING to the end of the latest kill in the kill ring.\
If BEFORE-P is non-nil, prepend STRING to the kill.\
If `interprogram-cut-function' is set, pass the resulting kill to\
it."\
  (kill-new (if before-p\
                (concat string (car kill-ring))\
              (concat (car kill-ring) string))\
            t))\
@end ignore\
\
@noindent\
The @code\{kill-append\} function is fairly straightforward.  It uses\
the @code\{kill-new\} function, which we will discuss in more detail in\
a moment.\
\
(Also, the function provides an optional argument called\
@code\{yank-handler\}; when invoked, this argument tells the function\
how to deal with properties added to the text, such as `bold' or\
`italics'.)\
\
@c !!! bug in GNU Emacs 22 version of  kill-append ?\
It has a @code\{let*\} function to set the value of the first element of\
the kill ring to @code\{cur\}.  (I do not know why the function does not\
use @code\{let\} instead; only one value is set in the expression.\
Perhaps this is a bug that produces no problems?)\
\
Consider the conditional that is one of the two arguments to\
@code\{kill-new\}.  It uses @code\{concat\} to concatenate the new text to\
the @sc\{car\} of the kill ring.  Whether it prepends or appends the\
text depends on the results of an @code\{if\} expression:\
\
@smallexample\
@group\
(if before-p                            ; @r\{if-part\}\
    (concat string cur)                 ; @r\{then-part\}\
  (concat cur string))                  ; @r\{else-part\}\
@end group\
@end smallexample\
\
@noindent\
If the region being killed is before the region that was killed in the\
last command, then it should be prepended before the material that was\
saved in the previous kill; and conversely, if the killed text follows\
what was just killed, it should be appended after the previous text.\
The @code\{if\} expression depends on the predicate @code\{before-p\} to\
decide whether the newly saved text should be put before or after the\
previously saved text.\
\
The symbol @code\{before-p\} is the name of one of the arguments to\
@code\{kill-append\}.  When the @code\{kill-append\} function is\
evaluated, it is bound to the value returned by evaluating the actual\
argument.  In this case, this is the expression @code\{(< end beg)\}.\
This expression does not directly determine whether the killed text in\
this command is located before or after the kill text of the last\
command; what it does is determine whether the value of the variable\
@code\{end\} is less than the value of the variable @code\{beg\}.  If it\
is, it means that the user is most likely heading towards the\
beginning of the buffer.  Also, the result of evaluating the predicate\
expression, @code\{(< end beg)\}, will be true and the text will be\
prepended before the previous text.  On the other hand, if the value of\
the variable @code\{end\} is greater than the value of the variable\
@code\{beg\}, the text will be appended after the previous text.\
\
@need 800\
When the newly saved text will be prepended, then the string with the new\
text will be concatenated before the old text:\
\
@smallexample\
(concat string cur)\
@end smallexample\
\
@need 1200\
@noindent\
But if the text will be appended, it will be concatenated\
after the old text:\
\
@smallexample\
(concat cur string))\
@end smallexample\
\
To understand how this works, we first need to review the\
@code\{concat\} function.  The @code\{concat\} function links together or\
unites two strings of text.  The result is a string.  For example:\
\
@smallexample\
@group\
(concat "abc" "def")\
     @result\{\} "abcdef"\
@end group\
\
@group\
(concat "new "\
        (car '("first element" "second element")))\
     @result\{\} "new first element"\
\
(concat (car\
        '("first element" "second element")) " modified")\
     @result\{\} "first element modified"\
@end group\
@end smallexample\
\
We can now make sense of @code\{kill-append\}: it modifies the contents\
of the kill ring.  The kill ring is a list, each element of which is\
saved text.  The @code\{kill-append\} function uses the @code\{kill-new\}\
function which in turn uses the @code\{setcar\} function.\
\
@node kill-new function,  , kill-append function, copy-region-as-kill body\
@unnumberedsubsubsec The @code\{kill-new\} function\
@findex kill-new\
\
@c in GNU Emacs 22, additional documentation to kill-new:\
@ignore\
Optional third arguments YANK-HANDLER controls how the STRING is later\
inserted into a buffer; see `insert-for-yank' for details.\
When a yank handler is specified, STRING must be non-empty (the yank\
handler, if non-nil, is stored as a `yank-handler' text property on STRING).\
\
When the yank handler has a non-nil PARAM element, the original STRING\
argument is not used by `insert-for-yank'.  However, since Lisp code\
may access and use elements from the kill ring directly, the STRING\
argument should still be a \\"useful\\" string for such uses."\
@end ignore\
@need 1200\
The @code\{kill-new\} function looks like this:\
\
@smallexample\
@group\
(defun kill-new (string &optional replace yank-handler)\
  "Make STRING the latest kill in the kill ring.\
Set `kill-ring-yank-pointer' to point to it.\
\
If `interprogram-cut-function' is non-nil, apply it to STRING.\
Optional second argument REPLACE non-nil means that STRING will replace\
the front of the kill ring, rather than being added to the list.\
@dots\{\}"\
@end group\
@group\
  (if (> (length string) 0)\
      (if yank-handler\
          (put-text-property 0 (length string)\
                             'yank-handler yank-handler string))\
    (if yank-handler\
        (signal 'args-out-of-range\
                (list string "yank-handler specified for empty string"))))\
@end group\
@group\
  (if (fboundp 'menu-bar-update-yank-menu)\
      (menu-bar-update-yank-menu string (and replace (car kill-ring))))\
@end group\
@group\
  (if (and replace kill-ring)\
      (setcar kill-ring string)\
    (push string kill-ring)\
    (if (> (length kill-ring) kill-ring-max)\
        (setcdr (nthcdr (1- kill-ring-max) kill-ring) nil)))\
@end group\
@group\
  (setq kill-ring-yank-pointer kill-ring)\
  (if interprogram-cut-function\
      (funcall interprogram-cut-function string (not replace))))\
@end group\
@end smallexample\
@ignore\
was:\
(defun kill-new (string &optional replace)\
  "Make STRING the latest kill in the kill ring.\
Set the kill-ring-yank pointer to point to it.\
If `interprogram-cut-function' is non-nil, apply it to STRING.\
Optional second argument REPLACE non-nil means that STRING will replace\
the front of the kill ring, rather than being added to the list."\
  (and (fboundp 'menu-bar-update-yank-menu)\
       (menu-bar-update-yank-menu string (and replace (car kill-ring))))\
  (if (and replace kill-ring)\
      (setcar kill-ring string)\
    (setq kill-ring (cons string kill-ring))\
    (if (> (length kill-ring) kill-ring-max)\
        (setcdr (nthcdr (1- kill-ring-max) kill-ring) nil)))\
  (setq kill-ring-yank-pointer kill-ring)\
  (if interprogram-cut-function\
      (funcall interprogram-cut-function string (not replace))))\
@end ignore\
\
(Notice that the function is not interactive.)\
\
As usual, we can look at this function in parts.\
\
The function definition has an optional @code\{yank-handler\} argument,\
which when invoked tells the function how to deal with properties\
added to the text, such as `bold' or `italics'.  We will skip that.\
\
@need 1200\
The first line of the documentation makes sense:\
\
@smallexample\
Make STRING the latest kill in the kill ring.\
@end smallexample\
\
@noindent\
Let's skip over the rest of the documentation for the moment.\
\
@noindent\
Also, let's skip over the initial @code\{if\} expression and those lines\
of code involving @code\{menu-bar-update-yank-menu\}.  We will explain\
them below.\
\
@need 1200\
The critical lines are these:\
\
@smallexample\
@group\
  (if (and replace kill-ring)\
      ;; @r\{then\}\
      (setcar kill-ring string)\
@end group\
@group\
    ;; @r\{else\}\
  (push string kill-ring)\
@end group\
@group\
    (setq kill-ring (cons string kill-ring))\
    (if (> (length kill-ring) kill-ring-max)\
        ;; @r\{avoid overly long kill ring\}\
        (setcdr (nthcdr (1- kill-ring-max) kill-ring) nil)))\
@end group\
@group\
  (setq kill-ring-yank-pointer kill-ring)\
  (if interprogram-cut-function\
      (funcall interprogram-cut-function string (not replace))))\
@end group\
@end smallexample\
\
The conditional test is @w\{@code\{(and replace kill-ring)\}\}.\
This will be true when two conditions are met:  the kill ring has\
something in it, and the @code\{replace\} variable is true.\
\
@need 1250\
When the @code\{kill-append\} function sets @code\{replace\} to be true\
and when the kill ring has at least one item in it, the @code\{setcar\}\
expression is executed:\
\
@smallexample\
(setcar kill-ring string)\
@end smallexample\
\
The @code\{setcar\} function actually changes the first element of the\
@code\{kill-ring\} list to the value of @code\{string\}.  It replaces the\
first element.\
\
@need 1250\
On the other hand, if the kill ring is empty, or replace is false, the\
else-part of the condition is executed:\
\
@smallexample\
(push string kill-ring)\
@end smallexample\
\
@noindent\
@need 1250\
@code\{push\} puts its first argument onto the second.  It is similar to\
the older\
\
@smallexample\
(setq kill-ring (cons string kill-ring))\
@end smallexample\
\
@noindent\
@need 1250\
or the newer\
\
@smallexample\
(add-to-list kill-ring string)\
@end smallexample\
\
@noindent\
When it is false, the expression first constructs a new version of the\
kill ring by prepending @code\{string\} to the existing kill ring as a\
new element (that is what the @code\{push\} does).  Then it executes a\
second @code\{if\} clause.  This second @code\{if\} clause keeps the kill\
ring from growing too long.\
\
Let's look at these two expressions in order.\
\
The @code\{push\} line of the else-part sets the new value of the kill\
ring to what results from adding the string being killed to the old\
kill ring.\
\
We can see how this works with an example.\
\
@need 800\
First,\
\
@smallexample\
(setq example-list '("here is a clause" "another clause"))\
@end smallexample\
\
@need 1200\
@noindent\
After evaluating this expression with @kbd\{C-x C-e\}, you can evaluate\
@code\{example-list\} and see what it returns:\
\
@smallexample\
@group\
example-list\
     @result\{\} ("here is a clause" "another clause")\
@end group\
@end smallexample\
\
@need 1200\
@noindent\
Now, we can add a new element on to this list by evaluating the\
following expression:\
@findex push, @r\{example\}\
\
@smallexample\
(push "a third clause" example-list)\
@end smallexample\
\
@need 800\
@noindent\
When we evaluate @code\{example-list\}, we find its value is:\
\
@smallexample\
@group\
example-list\
     @result\{\} ("a third clause" "here is a clause" "another clause")\
@end group\
@end smallexample\
\
@noindent\
Thus, the third clause is added to the list by @code\{push\}.\
\
@need 1200\
Now for the second part of the @code\{if\} clause.  This expression\
keeps the kill ring from growing too long.  It looks like this:\
\
@smallexample\
@group\
(if (> (length kill-ring) kill-ring-max)\
    (setcdr (nthcdr (1- kill-ring-max) kill-ring) nil))\
@end group\
@end smallexample\
\
The code checks whether the length of the kill ring is greater than\
the maximum permitted length.  This is the value of\
@code\{kill-ring-max\} (which is 60, by default).  If the length of the\
kill ring is too long, then this code sets the last element of the\
kill ring to @code\{nil\}.  It does this by using two functions,\
@code\{nthcdr\} and @code\{setcdr\}.\
\
We looked at @code\{setcdr\} earlier (@pxref\{setcdr, , @code\{setcdr\}\}).\
It sets the @sc\{cdr\} of a list, just as @code\{setcar\} sets the\
@sc\{car\} of a list.  In this case, however, @code\{setcdr\} will not be\
setting the @sc\{cdr\} of the whole kill ring; the @code\{nthcdr\}\
function is used to cause it to set the @sc\{cdr\} of the next to last\
element of the kill ring---this means that since the @sc\{cdr\} of the\
next to last element is the last element of the kill ring, it will set\
the last element of the kill ring.\
\
@findex nthcdr, @r\{example\}\
The @code\{nthcdr\} function works by repeatedly taking the @sc\{cdr\} of a\
list---it takes the @sc\{cdr\} of the @sc\{cdr\} of the @sc\{cdr\}\
@dots\{\}  It does this @var\{N\} times and returns the results.\
(@xref\{nthcdr, , @code\{nthcdr\}\}.)\
\
@findex setcdr, @r\{example\}\
Thus, if we had a four element list that was supposed to be three\
elements long, we could set the @sc\{cdr\} of the next to last element\
to @code\{nil\}, and thereby shorten the list.  (If you set the last\
element to some other value than @code\{nil\}, which you could do, then\
you would not have shortened the list.  @xref\{setcdr, ,\
@code\{setcdr\}\}.)\
\
You can see shortening by evaluating the following three expressions\
in turn.  First set the value of @code\{trees\} to @code\{(maple oak pine\
birch)\}, then set the @sc\{cdr\} of its second @sc\{cdr\} to @code\{nil\}\
and then find the value of @code\{trees\}:\
\
@smallexample\
@group\
(setq trees '(maple oak pine birch))\
     @result\{\} (maple oak pine birch)\
@end group\
\
@group\
(setcdr (nthcdr 2 trees) nil)\
     @result\{\} nil\
\
trees\
     @result\{\} (maple oak pine)\
@end group\
@end smallexample\
\
@noindent\
(The value returned by the @code\{setcdr\} expression is @code\{nil\} since\
that is what the @sc\{cdr\} is set to.)\
\
To repeat, in @code\{kill-new\}, the @code\{nthcdr\} function takes the\
@sc\{cdr\} a number of times that is one less than the maximum permitted\
size of the kill ring and @code\{setcdr\} sets the @sc\{cdr\} of that\
element (which will be the rest of the elements in the kill ring) to\
@code\{nil\}.  This prevents the kill ring from growing too long.\
\
@need 800\
The next to last expression in the @code\{kill-new\} function is\
\
@smallexample\
(setq kill-ring-yank-pointer kill-ring)\
@end smallexample\
\
The @code\{kill-ring-yank-pointer\} is a global variable that is set to be\
the @code\{kill-ring\}.\
\
Even though the @code\{kill-ring-yank-pointer\} is called a\
@samp\{pointer\}, it is a variable just like the kill ring.  However, the\
name has been chosen to help humans understand how the variable is used.\
\
@need 1200\
Now, to return to an early expression in the body of the function:\
\
@smallexample\
@group\
  (if (fboundp 'menu-bar-update-yank-menu)\
       (menu-bar-update-yank-menu string (and replace (car kill-ring))))\
@end group\
@end smallexample\
\
@noindent\
It starts with an @code\{if\} expression\
\
In this case, the expression tests first to see whether\
@code\{menu-bar-update-yank-menu\} exists as a function, and if so,\
calls it.  The @code\{fboundp\} function returns true if the symbol it\
is testing has a function definition that `is not void'.  If the\
symbol's function definition were void, we would receive an error\
message, as we did when we created errors intentionally (@pxref\{Making\
Errors, , Generate an Error Message\}).\
\
@noindent\
The then-part contains an expression whose first element is the\
function @code\{and\}.\
\
@findex and\
The @code\{and\} special form evaluates each of its arguments until one\
of the arguments returns a value of @code\{nil\}, in which case the\
@code\{and\} expression returns @code\{nil\}; however, if none of the\
arguments returns a value of @code\{nil\}, the value resulting from\
evaluating the last argument is returned.  (Since such a value is not\
@code\{nil\}, it is considered true in Emacs Lisp.)  In other words, an\
@code\{and\} expression returns a true value only if all its arguments\
are true.  (@xref\{Second Buffer Related Review\}.)\
\
The expression determines whether the second argument to\
@code\{menu-bar-update-yank-menu\} is true or not.\
@ignore\
    ;; If we're supposed to be extending an existing string, and that\
    ;; string really is at the front of the menu, then update it in place.\
@end ignore\
\
@code\{menu-bar-update-yank-menu\} is one of the functions that make it\
possible to use the `Select and Paste' menu in the Edit item of a menu\
bar; using a mouse, you can look at the various pieces of text you\
have saved and select one piece to paste.\
\
The last expression in the @code\{kill-new\} function adds the newly\
copied string to whatever facility exists for copying and pasting\
among different programs running in a windowing system.  In the X\
Windowing system, for example, the @code\{x-select-text\} function takes\
the string and stores it in memory operated by X.  You can paste the\
string in another program, such as an Xterm.\
\
@need 1200\
The expression looks like this:\
\
@smallexample\
@group\
  (if interprogram-cut-function\
      (funcall interprogram-cut-function string (not replace))))\
@end group\
@end smallexample\
\
If an @code\{interprogram-cut-function\} exists, then Emacs executes\
@code\{funcall\}, which in turn calls its first argument as a function\
and passes the remaining arguments to it.  (Incidentally, as far as I\
can see, this @code\{if\} expression could be replaced by an @code\{and\}\
expression similar to the one in the first part of the function.)\
\
We are not going to discuss windowing systems and other programs\
further, but merely note that this is a mechanism that enables GNU\
Emacs to work easily and well with other programs.\
\
This code for placing text in the kill ring, either concatenated with\
an existing element or as a new element, leads us to the code for\
bringing back text that has been cut out of the buffer---the yank\
commands.  However, before discussing the yank commands, it is better\
to learn how lists are implemented in a computer.  This will make\
clear such mysteries as the use of the term `pointer'.  But before\
that, we will digress into C.\
\
@ignore\
@c is this true in Emacs 22?   Does not seems to be\
\
  (If the @w\{@code\{(< end beg))\}\}\
expression is true, @code\{kill-append\} prepends the string to the just\
previously clipped text.  For a detailed discussion, see\
@ref\{kill-append function, , The @code\{kill-append\} function\}.)\
\
If you then yank back the text, i.e., `paste' it, you get both\
pieces of text at once.  That way, if you delete two words in a row,\
and then yank them back, you get both words, in their proper order,\
with one yank.  (The @w\{@code\{(< end beg))\}\} expression makes sure the\
order is correct.)\
\
On the other hand, if the previous command is not @code\{kill-region\},\
then the @code\{kill-new\} function is called, which adds the text to\
the kill ring as the latest item, and sets the\
@code\{kill-ring-yank-pointer\} variable to point to it.\
@end ignore\
@ignore\
\
@c Evidently, changed for Emacs 22. The zap-to-char command does not\
@c use the delete-and-extract-region function\
\
2006 Oct 26, the Digression into C is now OK but should come after\
copy-region-as-kill and filter-buffer-substring\
\
2006 Oct 24\
In Emacs 22,\
copy-region-as-kill is short, 12 lines, and uses\
filter-buffer-substring, which is longer, 39 lines\
and has delete-and-extract-region in it.\
delete-and-extract-region is written in C.\
\
see Initializing a Variable with @code\{defvar\}\
@end ignore\
\
@node Digression into C, defvar, copy-region-as-kill, Cutting & Storing Text\
@comment  node-name,  next,  previous,  up\
@section Digression into C\
@findex delete-and-extract-region\
@cindex C, a digression into\
@cindex Digression into C\
\
The @code\{copy-region-as-kill\} function (@pxref\{copy-region-as-kill, ,\
@code\{copy-region-as-kill\}\}) uses the @code\{filter-buffer-substring\}\
function, which in turn uses the @code\{delete-and-extract-region\}\
function.  It removes the contents of a region and you cannot get them\
back.\
\
Unlike the other code discussed here, the\
@code\{delete-and-extract-region\} function is not written in Emacs\
Lisp; it is written in C and is one of the primitives of the GNU Emacs\
system.  Since it is very simple, I will digress briefly from Lisp and\
describe it here.\
\
@c GNU Emacs 22  in /usr/local/src/emacs/src/editfns.c\
@c the DEFUN for  buffer-substring-no-properties\
\
@need 1500\
Like many of the other Emacs primitives,\
@code\{delete-and-extract-region\} is written as an instance of a C\
macro, a macro being a template for code.  The complete macro looks\
like this:\
\
@smallexample\
@group\
DEFUN ("buffer-substring-no-properties", Fbuffer_substring_no_properties,\
       Sbuffer_substring_no_properties, 2, 2, 0,\
       doc: /* Return the characters of part of the buffer,\
without the text properties.\
The two arguments START and END are character positions;\
they can be in either order.  */)\
     (start, end)\
     Lisp_Object start, end;\
@\{\
  register int b, e;\
\
  validate_region (&start, &end);\
  b = XINT (start);\
  e = XINT (end);\
\
  return make_buffer_string (b, e, 0);\
@\}\
@end group\
@end smallexample\
\
Without going into the details of the macro writing process, let me\
point out that this macro starts with the word @code\{DEFUN\}.  The word\
@code\{DEFUN\} was chosen since the code serves the same purpose as\
@code\{defun\} does in Lisp.  (The @code\{DEFUN\} C macro is defined in\
@file\{emacs/src/lisp.h\}.)\
\
The word @code\{DEFUN\} is followed by seven parts inside of\
parentheses:\
\
@itemize @bullet\
@item\
The first part is the name given to the function in Lisp,\
@code\{delete-and-extract-region\}.\
\
@item\
The second part is the name of the function in C,\
@code\{Fdelete_and_extract_region\}.  By convention, it starts with\
@samp\{F\}.  Since C does not use hyphens in names, underscores are used\
instead.\
\
@item\
The third part is the name for the C constant structure that records\
information on this function for internal use.  It is the name of the\
function in C but begins with an @samp\{S\} instead of an @samp\{F\}.\
\
@item\
The fourth and fifth parts specify the minimum and maximum number of\
arguments the function can have.  This function demands exactly 2\
arguments.\
\
@item\
The sixth part is nearly like the argument that follows the\
@code\{interactive\} declaration in a function written in Lisp: a letter\
followed, perhaps, by a prompt.  The only difference from the Lisp is\
when the macro is called with no arguments.  Then you write a @code\{0\}\
(which is a `null string'), as in this macro.\
\
If you were to specify arguments, you would place them between\
quotation marks.  The C macro for @code\{goto-char\} includes\
@code\{"NGoto char: "\} in this position to indicate that the function\
expects a raw prefix, in this case, a numerical location in a buffer,\
and provides a prompt.\
\
@item\
The seventh part is a documentation string, just like the one for a\
function written in Emacs Lisp, except that every newline must be\
written explicitly as @samp\{\\n\} followed by a backslash and carriage\
return.\
\
@need 1000\
Thus, the first two lines of documentation for  @code\{goto-char\} are\
written like this:\
\
@smallexample\
@group\
  "Set point to POSITION, a number or marker.\\n\\\
Beginning of buffer is position (point-min), end is (point-max)."\
@end group\
@end smallexample\
@end itemize\
\
@need 1200\
In a C macro, the formal parameters come next, with a statement of\
what kind of object they are, followed by what might be called the `body'\
of the macro.  For @code\{delete-and-extract-region\} the `body'\
consists of the following four lines:\
\
@smallexample\
@group\
validate_region (&start, &end);\
if (XINT (start) == XINT (end))\
  return build_string ("");\
return del_range_1 (XINT (start), XINT (end), 1, 1);\
@end group\
@end smallexample\
\
The   @code\{validate_region\} function checks whether the values\
passed as the beginning and end of the region are the proper type and\
are within range.  If the beginning and end positions are the same,\
then return and empty string.\
\
The @code\{del_range_1\} function actually deletes the text.  It is a\
complex function we will not look into.  It updates the buffer and\
does other things.  However, it is worth looking at the two arguments\
passed to @code\{del_range\}.  These are @w\{@code\{XINT (start)\}\} and\
@w\{@code\{XINT (end)\}\}.\
\
As far as the C language is concerned, @code\{start\} and @code\{end\} are\
two integers that mark the beginning and end of the region to be\
deleted@footnote\{More precisely, and requiring more expert knowledge\
to understand, the two integers are of type `Lisp_Object', which can\
also be a C union instead of an integer type.\}.\
\
In early versions of Emacs, these two numbers were thirty-two bits\
long, but the code is slowly being generalized to handle other\
lengths.  Three of the available bits are used to specify the type of\
information; the remaining bits are used as `content'.\
\
@samp\{XINT\} is a C macro that extracts the relevant number from the\
longer collection of bits; the three other bits are discarded.\
\
@need 800\
The command in @code\{delete-and-extract-region\} looks like this:\
\
@smallexample\
del_range_1 (XINT (start), XINT (end), 1, 1);\
@end smallexample\
\
@noindent\
It deletes the region between the beginning position, @code\{start\},\
and the ending position, @code\{end\}.\
\
From the point of view of the person writing Lisp, Emacs is all very\
simple; but hidden underneath is a great deal of complexity to make it\
all work.\
\
@node defvar, cons & search-fwd Review, Digression into C, Cutting & Storing Text\
@comment  node-name,  next,  previous,  up\
@section Initializing a Variable with @code\{defvar\}\
@findex defvar\
@cindex Initializing a variable\
@cindex Variable initialization\
\
@ignore\
2006 Oct 24\
In Emacs 22,\
copy-region-as-kill is short, 12 lines, and uses\
filter-buffer-substring, which is longer, 39 lines\
and has delete-and-extract-region in it.\
delete-and-extract-region is written in C.\
\
see Initializing a Variable with @code\{defvar\}\
\
@end ignore\
\
The @code\{copy-region-as-kill\} function is written in Emacs Lisp.  Two\
functions within it, @code\{kill-append\} and @code\{kill-new\}, copy a\
region in a buffer and save it in a variable called the\
@code\{kill-ring\}.  This section describes how the @code\{kill-ring\}\
variable is created and initialized using the @code\{defvar\} special\
form.\
\
(Again we note that the term @code\{kill-ring\} is a misnomer.  The text\
that is clipped out of the buffer can be brought back; it is not a ring\
of corpses, but a ring of resurrectable text.)\
\
In Emacs Lisp, a variable such as the @code\{kill-ring\} is created and\
given an initial value by using the @code\{defvar\} special form.  The\
name comes from ``define variable''.\
\
The @code\{defvar\} special form is similar to @code\{setq\} in that it sets\
the value of a variable.  It is unlike @code\{setq\} in two ways: first,\
it only sets the value of the variable if the variable does not already\
have a value.  If the variable already has a value, @code\{defvar\} does\
not override the existing value.  Second, @code\{defvar\} has a\
documentation string.\
\
(Another special form, @code\{defcustom\}, is designed for variables\
that people customize.  It has more features than @code\{defvar\}.\
(@xref\{defcustom, , Setting Variables with @code\{defcustom\}\}.)\
\
@menu\
* See variable current value::\
* defvar and asterisk::\
@end menu\
\
@node See variable current value, defvar and asterisk, defvar, defvar\
@ifnottex\
@unnumberedsubsec Seeing the Current Value of a Variable\
@end ifnottex\
\
You can see the current value of a variable, any variable, by using\
the @code\{describe-variable\} function, which is usually invoked by\
typing @kbd\{C-h v\}.  If you type @kbd\{C-h v\} and then @code\{kill-ring\}\
(followed by @key\{RET\}) when prompted, you will see what is in your\
current kill ring---this may be quite a lot!  Conversely, if you have\
been doing nothing this Emacs session except read this document, you\
may have nothing in it.  Also, you will see the documentation for\
@code\{kill-ring\}:\
\
@smallexample\
@group\
Documentation:\
List of killed text sequences.\
Since the kill ring is supposed to interact nicely with cut-and-paste\
facilities offered by window systems, use of this variable should\
@end group\
@group\
interact nicely with `interprogram-cut-function' and\
`interprogram-paste-function'.  The functions `kill-new',\
`kill-append', and `current-kill' are supposed to implement this\
interaction; you may want to use them instead of manipulating the kill\
ring directly.\
@end group\
@end smallexample\
\
@need 800\
The kill ring is defined by a @code\{defvar\} in the following way:\
\
@smallexample\
@group\
(defvar kill-ring nil\
  "List of killed text sequences.\
@dots\{\}")\
@end group\
@end smallexample\
\
@noindent\
In this variable definition, the variable is given an initial value of\
@code\{nil\}, which makes sense, since if you have saved nothing, you want\
nothing back if you give a @code\{yank\} command.  The documentation\
string is written just like the documentation string of a @code\{defun\}.\
As with the documentation string of the @code\{defun\}, the first line of\
the documentation should be a complete sentence, since some commands,\
like @code\{apropos\}, print only the first line of documentation.\
Succeeding lines should not be indented; otherwise they look odd when\
you use @kbd\{C-h v\} (@code\{describe-variable\}).\
\
@node defvar and asterisk,  , See variable current value, defvar\
@subsection @code\{defvar\} and an asterisk\
@findex defvar @r\{for a user customizable variable\}\
@findex defvar @r\{with an asterisk\}\
\
In the past, Emacs used the @code\{defvar\} special form both for\
internal variables that you would not expect a user to change and for\
variables that you do expect a user to change.  Although you can still\
use @code\{defvar\} for user customizable variables, please use\
@code\{defcustom\} instead, since that special form provides a path into\
the Customization commands.  (@xref\{defcustom, , Specifying Variables\
using @code\{defcustom\}\}.)\
\
When you specified a variable using the @code\{defvar\} special form,\
you could distinguish a variable that a user might want to change from\
others by typing an asterisk, @samp\{*\}, in the first column of its\
documentation string.  For example:\
\
@smallexample\
@group\
(defvar shell-command-default-error-buffer nil\
  "*Buffer name for `shell-command' @dots\{\} error output.\
@dots\{\} ")\
@end group\
@end smallexample\
\
@findex set-variable\
@noindent\
You could (and still can) use the @code\{set-variable\} command to\
change the value of @code\{shell-command-default-error-buffer\}\
temporarily.  However, options set using @code\{set-variable\} are set\
only for the duration of your editing session.  The new values are not\
saved between sessions.  Each time Emacs starts, it reads the original\
value, unless you change the value within your @file\{.emacs\} file,\
either by setting it manually or by using @code\{customize\}.\
@xref\{Emacs Initialization, , Your @file\{.emacs\} File\}.\
\
For me, the major use of the @code\{set-variable\} command is to suggest\
variables that I might want to set in my @file\{.emacs\} file.  There\
are now more than 700 such variables --- far too many to remember\
readily.  Fortunately, you can press @key\{TAB\} after calling the\
@code\{M-x set-variable\} command to see the list of variables.\
(@xref\{Examining, , Examining and Setting Variables, emacs,\
The GNU Emacs Manual\}.)\
\
@need 1250\
@node cons & search-fwd Review, search Exercises, defvar, Cutting & Storing Text\
@comment  node-name,  next,  previous,  up\
@section Review\
\
Here is a brief summary of some recently introduced functions.\
\
@table @code\
@item car\
@itemx cdr\
@code\{car\} returns the first element of a list; @code\{cdr\} returns the\
second and subsequent elements of a list.\
\
@need 1250\
For example:\
\
@smallexample\
@group\
(car '(1 2 3 4 5 6 7))\
     @result\{\} 1\
(cdr '(1 2 3 4 5 6 7))\
     @result\{\} (2 3 4 5 6 7)\
@end group\
@end smallexample\
\
@item cons\
@code\{cons\} constructs a list by prepending its first argument to its\
second argument.\
\
@need 1250\
For example:\
\
@smallexample\
@group\
(cons 1 '(2 3 4))\
     @result\{\} (1 2 3 4)\
@end group\
@end smallexample\
\
@item funcall\
@code\{funcall\} evaluates its first argument as a function.  It passes\
its remaining arguments to its first argument.\
\
@item nthcdr\
Return the result of taking @sc\{cdr\} `n' times on a list.\
@iftex\
The\
@tex\
$n^\{th\}$\
@end tex\
@code\{cdr\}.\
@end iftex\
The `rest of the rest', as it were.\
\
@need 1250\
For example:\
\
@smallexample\
@group\
(nthcdr 3 '(1 2 3 4 5 6 7))\
     @result\{\} (4 5 6 7)\
@end group\
@end smallexample\
\
@item setcar\
@itemx setcdr\
@code\{setcar\} changes the first element of a list; @code\{setcdr\}\
changes the second and subsequent elements of a list.\
\
@need 1250\
For example:\
\
@smallexample\
@group\
(setq triple '(1 2 3))\
\
(setcar triple '37)\
\
triple\
     @result\{\} (37 2 3)\
\
(setcdr triple '("foo" "bar"))\
\
triple\
     @result\{\} (37 "foo" "bar")\
@end group\
@end smallexample\
\
@item progn\
Evaluate each argument in sequence and then return the value of the\
last.\
\
@need 1250\
For example:\
\
@smallexample\
@group\
(progn 1 2 3 4)\
     @result\{\} 4\
@end group\
@end smallexample\
\
@item save-restriction\
Record whatever narrowing is in effect in the current buffer, if any,\
and restore that narrowing after evaluating the arguments.\
\
@item search-forward\
Search for a string, and if the string is found, move point.  With a\
regular expression, use the similar @code\{re-search-forward\}.\
(@xref\{Regexp Search, , Regular Expression Searches\}, for an\
explanation of regular expression patterns and searches.)\
\
@need 1250\
@noindent\
@code\{search-forward\} and @code\{re-search-forward\} take four\
arguments:\
\
@enumerate\
@item\
The string or regular expression to search for.\
\
@item\
Optionally, the limit of the search.\
\
@item\
Optionally, what to do if the search fails, return @code\{nil\} or an\
error message.\
\
@item\
Optionally, how many times to repeat the search; if negative, the\
search goes backwards.\
@end enumerate\
\
@item kill-region\
@itemx delete-and-extract-region\
@itemx copy-region-as-kill\
\
@code\{kill-region\} cuts the text between point and mark from the\
buffer and stores that text in the kill ring, so you can get it back\
by yanking.\
\
@code\{copy-region-as-kill\} copies the text between point and mark into\
the kill ring, from which you can get it by yanking.  The function\
does not cut or remove the text from the buffer.\
@end table\
\
@code\{delete-and-extract-region\} removes the text between point and\
mark from the buffer and throws it away.  You cannot get it back.\
(This is not an interactive command.)\
\
@need 1500\
@node search Exercises,  , cons & search-fwd Review, Cutting & Storing Text\
@section Searching Exercises\
\
@itemize @bullet\
@item\
Write an interactive function that searches for a string.  If the\
search finds the string, leave point after it and display a message\
that says ``Found!''.  (Do not use @code\{search-forward\} for the name\
of this function; if you do, you will overwrite the existing version of\
@code\{search-forward\} that comes with Emacs.  Use a name such as\
@code\{test-search\} instead.)\
\
@item\
Write a function that prints the third element of the kill ring in the\
echo area, if any; if the kill ring does not contain a third element,\
print an appropriate message.\
@end itemize}