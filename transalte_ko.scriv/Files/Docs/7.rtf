{\rtf1\ansi\ansicpg949\cocoartf1187\cocoasubrtf340
{\fonttbl\f0\fnil\fcharset129 AppleSDGothicNeo-Regular;}
{\colortbl;\red255\green255\blue255;}
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\fi360\sl288\slmult1\pardirnatural

\f0\fs28 \cf0 \
@node Practicing Evaluation, Writing Defuns, List Processing, Top\
@comment  node-name,  next,  previous,  up\
@chapter Practicing Evaluation\
@cindex Practicing evaluation\
@cindex Evaluation practice\
\
Before learning how to write a function definition in Emacs Lisp, it is\
useful to spend a little time evaluating various expressions that have\
already been written.  These expressions will be lists with the\
functions as their first (and often only) element.  Since some of the\
functions associated with buffers are both simple and interesting, we\
will start with those.  In this section, we will evaluate a few of\
these.  In another section, we will study the code of several other\
buffer-related functions, to see how they were written.\
\
@menu\
* How to Evaluate::            Typing editing commands or @kbd\{C-x C-e\}\
                                 causes evaluation.\
* Buffer Names::               Buffers and files are different.\
* Getting Buffers::            Getting a buffer itself, not merely its name.\
* Switching Buffers::          How to change to another buffer.\
* Buffer Size & Locations::    Where point is located and the size of\
                               the buffer.\
* Evaluation Exercise::\
@end menu\
\
@node How to Evaluate, Buffer Names, Practicing Evaluation, Practicing Evaluation\
@ifnottex\
@unnumberedsec How to Evaluate\
@end ifnottex\
\
@i\{Whenever you give an editing command\} to Emacs Lisp, such as the\
command to move the cursor or to scroll the screen, @i\{you are evaluating\
an expression,\} the first element of which is a function.  @i\{This is\
how Emacs works.\}\
\
@cindex @samp\{interactive function\} defined\
@cindex @samp\{command\} defined\
When you type keys, you cause the Lisp interpreter to evaluate an\
expression and that is how you get your results.  Even typing plain text\
involves evaluating an Emacs Lisp function, in this case, one that uses\
@code\{self-insert-command\}, which simply inserts the character you\
typed.  The functions you evaluate by typing keystrokes are called\
@dfn\{interactive\} functions, or @dfn\{commands\}; how you make a function\
interactive will be illustrated in the chapter on how to write function\
definitions.  @xref\{Interactive, , Making a Function Interactive\}.\
\
In addition to typing keyboard commands, we have seen a second way to\
evaluate an expression: by positioning the cursor after a list and\
typing @kbd\{C-x C-e\}.  This is what we will do in the rest of this\
section.  There are other ways to evaluate an expression as well; these\
will be described as we come to them.\
\
Besides being used for practicing evaluation, the functions shown in the\
next few sections are important in their own right.  A study of these\
functions makes clear the distinction between buffers and files, how to\
switch to a buffer, and how to determine a location within it.\
\
@node Buffer Names, Getting Buffers, How to Evaluate, Practicing Evaluation\
@comment  node-name,  next,  previous,  up\
@section Buffer Names\
@findex buffer-name\
@findex buffer-file-name\
\
The two functions, @code\{buffer-name\} and @code\{buffer-file-name\}, show\
the difference between a file and a buffer.  When you evaluate the\
following expression, @code\{(buffer-name)\}, the name of the buffer\
appears in the echo area.  When you evaluate @code\{(buffer-file-name)\},\
the name of the file to which the buffer refers appears in the echo\
area.  Usually, the name returned by @code\{(buffer-name)\} is the same as\
the name of the file to which it refers, and the name returned by\
@code\{(buffer-file-name)\} is the full path-name of the file.\
\
A file and a buffer are two different entities.  A file is information\
recorded permanently in the computer (unless you delete it).  A buffer,\
on the other hand, is information inside of Emacs that will vanish at\
the end of the editing session (or when you kill the buffer).  Usually,\
a buffer contains information that you have copied from a file; we say\
the buffer is @dfn\{visiting\} that file.  This copy is what you work on\
and modify.  Changes to the buffer do not change the file, until you\
save the buffer.  When you save the buffer, the buffer is copied to the file\
and is thus saved permanently.\
\
@need 1250\
If you are reading this in Info inside of GNU Emacs, you can evaluate\
each of the following expressions by positioning the cursor after it and\
typing @kbd\{C-x C-e\}.\
\
@example\
@group\
(buffer-name)\
\
(buffer-file-name)\
@end group\
@end example\
\
@noindent\
When I do this in Info, the value returned by evaluating\
@code\{(buffer-name)\} is @file\{"*info*"\}, and the value returned by\
evaluating @code\{(buffer-file-name)\} is @file\{nil\}.\
\
On the other hand, while I am writing this document, the value\
returned by evaluating @code\{(buffer-name)\} is\
@file\{"introduction.texinfo"\}, and the value returned by evaluating\
@code\{(buffer-file-name)\} is\
@file\{"/gnu/work/intro/introduction.texinfo"\}.\
\
@cindex @code\{nil\}, history of word\
The former is the name of the buffer and the latter is the name of the\
file.  In Info, the buffer name is @file\{"*info*"\}.  Info does not\
point to any file, so the result of evaluating\
@code\{(buffer-file-name)\} is @file\{nil\}.  The symbol @code\{nil\} is\
from the Latin word for `nothing'; in this case, it means that the\
buffer is not associated with any file.  (In Lisp, @code\{nil\} is also\
used to mean `false' and is a synonym for the empty list, @code\{()\}.)\
\
When I am writing, the name of my buffer is\
@file\{"introduction.texinfo"\}.  The name of the file to which it\
points is @file\{"/gnu/work/intro/introduction.texinfo"\}.\
\
(In the expressions, the parentheses tell the Lisp interpreter to\
treat @w\{@code\{buffer-name\}\} and @w\{@code\{buffer-file-name\}\} as\
functions; without the parentheses, the interpreter would attempt to\
evaluate the symbols as variables.  @xref\{Variables\}.)\
\
In spite of the distinction between files and buffers, you will often\
find that people refer to a file when they mean a buffer and vice-verse.\
Indeed, most people say, ``I am editing a file,'' rather than saying,\
``I am editing a buffer which I will soon save to a file.''  It is\
almost always clear from context what people mean.  When dealing with\
computer programs, however, it is important to keep the distinction in mind,\
since the computer is not as smart as a person.\
\
@cindex Buffer, history of word\
The word `buffer', by the way, comes from the meaning of the word as a\
cushion that deadens the force of a collision.  In early computers, a\
buffer cushioned the interaction between files and the computer's\
central processing unit.  The drums or tapes that held a file and the\
central processing unit were pieces of equipment that were very\
different from each other, working at their own speeds, in spurts.  The\
buffer made it possible for them to work together effectively.\
Eventually, the buffer grew from being an intermediary, a temporary\
holding place, to being the place where work is done.  This\
transformation is rather like that of a small seaport that grew into a\
great city: once it was merely the place where cargo was warehoused\
temporarily before being loaded onto ships; then it became a business\
and cultural center in its own right.\
\
Not all buffers are associated with files.  For example, a\
@file\{*scratch*\} buffer does not visit any file.  Similarly, a\
@file\{*Help*\} buffer is not associated with any file.\
\
In the old days, when you lacked a @file\{~/.emacs\} file and started an\
Emacs session by typing the command @code\{emacs\} alone, without naming\
any files, Emacs started with the @file\{*scratch*\} buffer visible.\
Nowadays, you will see a splash screen.  You can follow one of the\
commands suggested on the splash screen, visit a file, or press the\
spacebar to reach the @file\{*scratch*\} buffer.\
\
If you switch to the @file\{*scratch*\} buffer, type\
@code\{(buffer-name)\}, position the cursor after it, and then type\
@kbd\{C-x C-e\} to evaluate the expression.  The name @code\{"*scratch*"\}\
will be returned and will appear in the echo area.  @code\{"*scratch*"\}\
is the name of the buffer.  When you type @code\{(buffer-file-name)\} in\
the @file\{*scratch*\} buffer and evaluate that, @code\{nil\} will appear\
in the echo area, just as it does when you evaluate\
@code\{(buffer-file-name)\} in Info.\
\
Incidentally, if you are in the @file\{*scratch*\} buffer and want the\
value returned by an expression to appear in the @file\{*scratch*\}\
buffer itself rather than in the echo area, type @kbd\{C-u C-x C-e\}\
instead of @kbd\{C-x C-e\}.  This causes the value returned to appear\
after the expression.  The buffer will look like this:\
\
@smallexample\
(buffer-name)"*scratch*"\
@end smallexample\
\
@noindent\
You cannot do this in Info since Info is read-only and it will not allow\
you to change the contents of the buffer.  But you can do this in any\
buffer you can edit; and when you write code or documentation (such as\
this book), this feature is very useful.\
\
@node Getting Buffers, Switching Buffers, Buffer Names, Practicing Evaluation\
@comment  node-name,  next,  previous,  up\
@section Getting Buffers\
@findex current-buffer\
@findex other-buffer\
@cindex Getting a buffer\
\
The @code\{buffer-name\} function returns the @emph\{name\} of the buffer;\
to get the buffer @emph\{itself\}, a different function is needed: the\
@code\{current-buffer\} function.  If you use this function in code, what\
you get is the buffer itself.\
\
A name and the object or entity to which the name refers are different\
from each other.  You are not your name.  You are a person to whom\
others refer by name.  If you ask to speak to George and someone hands you\
a card with the letters @samp\{G\}, @samp\{e\}, @samp\{o\}, @samp\{r\},\
@samp\{g\}, and @samp\{e\} written on it, you might be amused, but you would\
not be satisfied.  You do not want to speak to the name, but to the\
person to whom the name refers.  A buffer is similar: the name of the\
scratch buffer is @file\{*scratch*\}, but the name is not the buffer.  To\
get a buffer itself, you need to use a function such as\
@code\{current-buffer\}.\
\
However, there is a slight complication: if you evaluate\
@code\{current-buffer\} in an expression on its own, as we will do here,\
what you see is a printed representation of the name of the buffer\
without the contents of the buffer.  Emacs works this way for two\
reasons: the buffer may be thousands of lines long---too long to be\
conveniently displayed; and, another buffer may have the same contents\
but a different name, and it is important to distinguish between them.\
\
@need 800\
Here is an expression containing the function:\
\
@smallexample\
(current-buffer)\
@end smallexample\
\
@noindent\
If you evaluate this expression in Info in Emacs in the usual way,\
@file\{#<buffer *info*>\} will appear in the echo area.  The special\
format indicates that the buffer itself is being returned, rather than\
just its name.\
\
Incidentally, while you can type a number or symbol into a program, you\
cannot do that with the printed representation of a buffer: the only way\
to get a buffer itself is with a function such as @code\{current-buffer\}.\
\
A related function is @code\{other-buffer\}.  This returns the most\
recently selected buffer other than the one you are in currently, not\
a printed representation of its name.  If you have recently switched\
back and forth from the @file\{*scratch*\} buffer, @code\{other-buffer\}\
will return that buffer.\
\
@need 800\
You can see this by evaluating the expression:\
\
@smallexample\
(other-buffer)\
@end smallexample\
\
@noindent\
You should see @file\{#<buffer *scratch*>\} appear in the echo area, or\
the name of whatever other buffer you switched back from most\
recently@footnote\{Actually, by default, if the buffer from which you\
just switched is visible to you in another window, @code\{other-buffer\}\
will choose the most recent buffer that you cannot see; this is a\
subtlety that I often forget.\}.\
\
@node Switching Buffers, Buffer Size & Locations, Getting Buffers, Practicing Evaluation\
@comment  node-name,  next,  previous,  up\
@section Switching Buffers\
@findex switch-to-buffer\
@findex set-buffer\
@cindex Switching to a buffer\
\
The @code\{other-buffer\} function actually provides a buffer when it is\
used as an argument to a function that requires one.  We can see this\
by using @code\{other-buffer\} and @code\{switch-to-buffer\} to switch to a\
different buffer.\
\
But first, a brief introduction to the @code\{switch-to-buffer\}\
function.  When you switched back and forth from Info to the\
@file\{*scratch*\} buffer to evaluate @code\{(buffer-name)\}, you most\
likely typed @kbd\{C-x b\} and then typed @file\{*scratch*\}@footnote\{Or\
rather, to save typing, you probably only typed @kbd\{RET\} if the\
default buffer was @file\{*scratch*\}, or if it was different, then you\
typed just part of the name, such as @code\{*sc\}, pressed your\
@kbd\{TAB\} key to cause it to expand to the full name, and then typed\
your @kbd\{RET\} key.\} when prompted in the minibuffer for the name of\
the buffer to which you wanted to switch.  The keystrokes, @kbd\{C-x\
b\}, cause the Lisp interpreter to evaluate the interactive function\
@code\{switch-to-buffer\}.  As we said before, this is how Emacs works:\
different keystrokes call or run different functions.  For example,\
@kbd\{C-f\} calls @code\{forward-char\}, @kbd\{M-e\} calls\
@code\{forward-sentence\}, and so on.\
\
By writing @code\{switch-to-buffer\} in an expression, and giving it a\
buffer to switch to, we can switch buffers just the way @kbd\{C-x b\}\
does.\
\
@need 1000\
Here is the Lisp expression:\
\
@smallexample\
(switch-to-buffer (other-buffer))\
@end smallexample\
\
@noindent\
The symbol @code\{switch-to-buffer\} is the first element of the list,\
so the Lisp interpreter will treat it as a function and carry out the\
instructions that are attached to it.  But before doing that, the\
interpreter will note that @code\{other-buffer\} is inside parentheses\
and work on that symbol first.  @code\{other-buffer\} is the first (and\
in this case, the only) element of this list, so the Lisp interpreter\
calls or runs the function.  It returns another buffer.  Next, the\
interpreter runs @code\{switch-to-buffer\}, passing to it, as an\
argument, the other buffer, which is what Emacs will switch to.  If\
you are reading this in Info, try this now.  Evaluate the expression.\
(To get back, type @kbd\{C-x b @key\{RET\}\}.)@footnote\{Remember, this\
expression will move you to your most recent other buffer that you\
cannot see.  If you really want to go to your most recently selected\
buffer, even if you can still see it, you need to evaluate the\
following more complex expression:\
\
@smallexample\
(switch-to-buffer (other-buffer (current-buffer) t))\
@end smallexample\
\
@c noindent\
In this case, the first argument to @code\{other-buffer\} tells it which\
buffer to skip---the current one---and the second argument tells\
@code\{other-buffer\} it is OK to switch to a visible buffer.\
In regular use, @code\{switch-to-buffer\} takes you to an invisible\
window since you would most likely use @kbd\{C-x o\} (@code\{other-window\})\
to go to another visible buffer.\}\
\
In the programming examples in later sections of this document, you will\
see the function @code\{set-buffer\} more often than\
@code\{switch-to-buffer\}.  This is because of a difference between\
computer programs and humans: humans have eyes and expect to see the\
buffer on which they are working on their computer terminals.  This is\
so obvious, it almost goes without saying.  However, programs do not\
have eyes.  When a computer program works on a buffer, that buffer does\
not need to be visible on the screen.\
\
@code\{switch-to-buffer\} is designed for humans and does two different\
things: it switches the buffer to which Emacs' attention is directed; and\
it switches the buffer displayed in the window to the new buffer.\
@code\{set-buffer\}, on the other hand, does only one thing: it switches\
the attention of the computer program to a different buffer.  The buffer\
on the screen remains unchanged (of course, normally nothing happens\
there until the command finishes running).\
\
@cindex @samp\{call\} defined\
Also, we have just introduced another jargon term, the word @dfn\{call\}.\
When you evaluate a list in which the first symbol is a function, you\
are calling that function.  The use of the term comes from the notion of\
the function as an entity that can do something for you if you `call'\
it---just as a plumber is an entity who can fix a leak if you call him\
or her.\
\
@node Buffer Size & Locations, Evaluation Exercise, Switching Buffers, Practicing Evaluation\
@comment  node-name,  next,  previous,  up\
@section Buffer Size and the Location of Point\
@cindex Size of buffer\
@cindex Buffer size\
@cindex Point location\
@cindex Location of point\
\
Finally, let's look at several rather simple functions,\
@code\{buffer-size\}, @code\{point\}, @code\{point-min\}, and\
@code\{point-max\}.  These give information about the size of a buffer and\
the location of point within it.\
\
The function @code\{buffer-size\} tells you the size of the current\
buffer; that is, the function returns a count of the number of\
characters in the buffer.\
\
@smallexample\
(buffer-size)\
@end smallexample\
\
@noindent\
You can evaluate this in the usual way, by positioning the\
cursor after the expression and typing @kbd\{C-x C-e\}.\
\
@cindex @samp\{point\} defined\
In Emacs, the current  position of the cursor is called @dfn\{point\}.\
The expression @code\{(point)\} returns a number that tells you where the\
cursor is located as a count of the number of characters from the\
beginning of the buffer up to point.\
\
@need 1250\
You can see the character count for point in this buffer by evaluating\
the following expression in the usual way:\
\
@smallexample\
(point)\
@end smallexample\
\
@noindent\
As I write this, the value of @code\{point\} is 65724.  The @code\{point\}\
function is frequently used in some of the examples later in this\
book.\
\
@need 1250\
The value of point depends, of course, on its location within the\
buffer.  If you evaluate point in this spot, the number will be larger:\
\
@smallexample\
(point)\
@end smallexample\
\
@noindent\
For me, the value of point in this location is 66043, which means that\
there are 319 characters (including spaces) between the two\
expressions.  (Doubtless, you will see different numbers, since I will\
have edited this since I first evaluated point.)\
\
@cindex @samp\{narrowing\} defined\
The function @code\{point-min\} is somewhat similar to @code\{point\}, but\
it returns the value of the minimum permissible value of point in the\
current buffer.  This is the number 1 unless @dfn\{narrowing\} is in\
effect.  (Narrowing is a mechanism whereby you can restrict yourself,\
or a program, to operations on just a part of a buffer.\
@xref\{Narrowing & Widening, , Narrowing and Widening\}.)  Likewise, the\
function @code\{point-max\} returns the value of the maximum permissible\
value of point in the current buffer.\
\
@node Evaluation Exercise,  , Buffer Size & Locations, Practicing Evaluation\
@section Exercise\
\
Find a file with which you are working and move towards its middle.\
Find its buffer name, file name, length, and your position in the file.}