{\rtf1\ansi\ansicpg949\cocoartf1187\cocoasubrtf340
{\fonttbl\f0\fnil\fcharset129 AppleSDGothicNeo-Regular;}
{\colortbl;\red255\green255\blue255;}
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\fi360\sl288\slmult1\pardirnatural

\f0\fs28 \cf0 \
@node Loops & Recursion, Regexp Search, Yanking, Top\
@comment  node-name,  next,  previous,  up\
@chapter Loops and Recursion\
@cindex Loops and recursion\
@cindex Recursion and loops\
@cindex Repetition (loops)\
\
Emacs Lisp has two primary ways to cause an expression, or a series of\
expressions, to be evaluated repeatedly: one uses a @code\{while\}\
loop, and the other uses @dfn\{recursion\}.\
\
Repetition can be very valuable.  For example, to move forward four\
sentences, you need only write a program that will move forward one\
sentence and then repeat the process four times.  Since a computer does\
not get bored or tired, such repetitive action does not have the\
deleterious effects that excessive or the wrong kinds of repetition can\
have on humans.\
\
People mostly write Emacs Lisp functions using @code\{while\} loops and\
their kin; but you can use recursion, which provides a very powerful\
way to think about and then to solve problems@footnote\{You can write\
recursive functions to be frugal or wasteful of mental or computer\
resources; as it happens, methods that people find easy---that are\
frugal of `mental resources'---sometimes use considerable computer\
resources.  Emacs was designed to run on machines that we now consider\
limited and its default settings are conservative.  You may want to\
increase the values of @code\{max-specpdl-size\} and\
@code\{max-lisp-eval-depth\}.  In my @file\{.emacs\} file, I set them to\
15 and 30 times their default value.\}.\
\
@menu\
* while::                       Causing a stretch of code to repeat.\
* dolist dotimes::\
* Recursion::                   Causing a function to call itself.\
* Looping exercise::\
@end menu\
\
@node while, dolist dotimes, Loops & Recursion, Loops & Recursion\
@comment  node-name,  next,  previous,  up\
@section @code\{while\}\
@cindex Loops\
@findex while\
\
The @code\{while\} special form tests whether the value returned by\
evaluating its first argument is true or false.  This is similar to what\
the Lisp interpreter does with an @code\{if\}; what the interpreter does\
next, however, is different.\
\
In a @code\{while\} expression, if the value returned by evaluating the\
first argument is false, the Lisp interpreter skips the rest of the\
expression (the @dfn\{body\} of the expression) and does not evaluate it.\
However, if the value is true, the Lisp interpreter evaluates the body\
of the expression and then again tests whether the first argument to\
@code\{while\} is true or false.  If the value returned by evaluating the\
first argument is again true, the Lisp interpreter again evaluates the\
body of the expression.\
\
@need 1200\
The template for a @code\{while\} expression looks like this:\
\
@smallexample\
@group\
(while @var\{true-or-false-test\}\
  @var\{body\}@dots\{\})\
@end group\
@end smallexample\
\
@menu\
* Looping with while::          Repeat so long as test returns true.\
* Loop Example::                A @code\{while\} loop that uses a list.\
* print-elements-of-list::      Uses @code\{while\}, @code\{car\}, @code\{cdr\}.\
* Incrementing Loop::           A loop with an incrementing counter.\
* Incrementing Loop Details::\
* Decrementing Loop::           A loop with a decrementing counter.\
@end menu\
\
@node Looping with while, Loop Example, while, while\
@ifnottex\
@unnumberedsubsec Looping with @code\{while\}\
@end ifnottex\
\
So long as the true-or-false-test of the @code\{while\} expression\
returns a true value when it is evaluated, the body is repeatedly\
evaluated.  This process is called a loop since the Lisp interpreter\
repeats the same thing again and again, like an airplane doing a loop.\
When the result of evaluating the true-or-false-test is false, the\
Lisp interpreter does not evaluate the rest of the @code\{while\}\
expression and `exits the loop'.\
\
Clearly, if the value returned by evaluating the first argument to\
@code\{while\} is always true, the body following will be evaluated\
again and again @dots\{\} and again @dots\{\} forever.  Conversely, if the\
value returned is never true, the expressions in the body will never\
be evaluated.  The craft of writing a @code\{while\} loop consists of\
choosing a mechanism such that the true-or-false-test returns true\
just the number of times that you want the subsequent expressions to\
be evaluated, and then have the test return false.\
\
The value returned by evaluating a @code\{while\} is the value of the\
true-or-false-test.  An interesting consequence of this is that a\
@code\{while\} loop that evaluates without error will return @code\{nil\}\
or false regardless of whether it has looped 1 or 100 times or none at\
all.  A @code\{while\} expression that evaluates successfully never\
returns a true value!  What this means is that @code\{while\} is always\
evaluated for its side effects, which is to say, the consequences of\
evaluating the expressions within the body of the @code\{while\} loop.\
This makes sense.  It is not the mere act of looping that is desired,\
but the consequences of what happens when the expressions in the loop\
are repeatedly evaluated.\
\
@node Loop Example, print-elements-of-list, Looping with while, while\
@comment  node-name,  next,  previous,  up\
@subsection A @code\{while\} Loop and a List\
\
A common way to control a @code\{while\} loop is to test whether a list\
has any elements.  If it does, the loop is repeated; but if it does not,\
the repetition is ended.  Since this is an important technique, we will\
create a short example to illustrate it.\
\
A simple way to test whether a list has elements is to evaluate the\
list: if it has no elements, it is an empty list and will return the\
empty list, @code\{()\}, which is a synonym for @code\{nil\} or false.  On\
the other hand, a list with elements will return those elements when it\
is evaluated.  Since Emacs Lisp considers as true any value that is not\
@code\{nil\}, a list that returns elements will test true in a\
@code\{while\} loop.\
\
@need 1200\
For example, you can set the variable @code\{empty-list\} to @code\{nil\} by\
evaluating the following @code\{setq\} expression:\
\
@smallexample\
(setq empty-list ())\
@end smallexample\
\
@noindent\
After evaluating the @code\{setq\} expression, you can evaluate the\
variable @code\{empty-list\} in the usual way, by placing the cursor after\
the symbol and typing @kbd\{C-x C-e\}; @code\{nil\} will appear in your\
echo area:\
\
@smallexample\
empty-list\
@end smallexample\
\
On the other hand, if you set a variable to be a list with elements, the\
list will appear when you evaluate the variable, as you can see by\
evaluating the following two expressions:\
\
@smallexample\
@group\
(setq animals '(gazelle giraffe lion tiger))\
\
animals\
@end group\
@end smallexample\
\
Thus, to create a @code\{while\} loop that tests whether there are any\
items in the list @code\{animals\}, the first part of the loop will be\
written like this:\
\
@smallexample\
@group\
(while animals\
       @dots\{\}\
@end group\
@end smallexample\
\
@noindent\
When the @code\{while\} tests its first argument, the variable\
@code\{animals\} is evaluated.  It returns a list.  So long as the list\
has elements, the @code\{while\} considers the results of the test to be\
true; but when the list is empty, it considers the results of the test\
to be false.\
\
To prevent the @code\{while\} loop from running forever, some mechanism\
needs to be provided to empty the list eventually.  An oft-used\
technique is to have one of the subsequent forms in the @code\{while\}\
expression set the value of the list to be the @sc\{cdr\} of the list.\
Each time the @code\{cdr\} function is evaluated, the list will be made\
shorter, until eventually only the empty list will be left.  At this\
point, the test of the @code\{while\} loop will return false, and the\
arguments to the @code\{while\} will no longer be evaluated.\
\
For example, the list of animals bound to the variable @code\{animals\}\
can be set to be the @sc\{cdr\} of the original list with the\
following expression:\
\
@smallexample\
(setq animals (cdr animals))\
@end smallexample\
\
@noindent\
If you have evaluated the previous expressions and then evaluate this\
expression, you will see @code\{(giraffe lion tiger)\} appear in the echo\
area.  If you evaluate the expression again, @code\{(lion tiger)\} will\
appear in the echo area.  If you evaluate it again and yet again,\
@code\{(tiger)\} appears and then the empty list, shown by @code\{nil\}.\
\
A template for a @code\{while\} loop that uses the @code\{cdr\} function\
repeatedly to cause the true-or-false-test eventually to test false\
looks like this:\
\
@smallexample\
@group\
(while @var\{test-whether-list-is-empty\}\
  @var\{body\}@dots\{\}\
  @var\{set-list-to-cdr-of-list\})\
@end group\
@end smallexample\
\
This test and use of @code\{cdr\} can be put together in a function that\
goes through a list and prints each element of the list on a line of its\
own.\
\
@node print-elements-of-list, Incrementing Loop, Loop Example, while\
@subsection An Example: @code\{print-elements-of-list\}\
@findex print-elements-of-list\
\
The @code\{print-elements-of-list\} function illustrates a @code\{while\}\
loop with a list.\
\
@cindex @file\{*scratch*\} buffer\
The function requires several lines for its output.  If you are\
reading this in a recent instance of GNU Emacs,\
@c GNU Emacs 21, GNU Emacs 22, or a later version,\
you can evaluate the following expression inside of Info, as usual.\
\
If you are using an earlier version of Emacs, you need to copy the\
necessary expressions to your @file\{*scratch*\} buffer and evaluate\
them there.  This is because the echo area had only one line in the\
earlier versions.\
\
You can copy the expressions by marking the beginning of the region\
with @kbd\{C-@key\{SPC\}\} (@code\{set-mark-command\}), moving the cursor to\
the end of the region and then copying the region using @kbd\{M-w\}\
(@code\{kill-ring-save\}, which calls @code\{copy-region-as-kill\} and\
then provides visual feedback).  In the @file\{*scratch*\}\
buffer, you can yank the expressions back by typing @kbd\{C-y\}\
(@code\{yank\}).\
\
After you have copied the expressions to the @file\{*scratch*\} buffer,\
evaluate each expression in turn.  Be sure to evaluate the last\
expression, @code\{(print-elements-of-list animals)\}, by typing\
@kbd\{C-u C-x C-e\}, that is, by giving an argument to\
@code\{eval-last-sexp\}.  This will cause the result of the evaluation\
to be printed in the @file\{*scratch*\} buffer instead of being printed\
in the echo area.  (Otherwise you will see something like this in your\
echo area: @code\{^Jgazelle^J^Jgiraffe^J^Jlion^J^Jtiger^Jnil\}, in which\
each @samp\{^J\} stands for a `newline'.)\
\
@need 1500\
In a recent instance of GNU Emacs, you can evaluate these expressions\
directly in the Info buffer, and the echo area will grow to show the\
results.\
\
@smallexample\
@group\
(setq animals '(gazelle giraffe lion tiger))\
\
(defun print-elements-of-list (list)\
  "Print each element of LIST on a line of its own."\
  (while list\
    (print (car list))\
    (setq list (cdr list))))\
\
(print-elements-of-list animals)\
@end group\
@end smallexample\
\
@need 1200\
@noindent\
When you evaluate the three expressions in sequence, you will see\
this:\
\
@smallexample\
@group\
gazelle\
\
giraffe\
\
lion\
\
tiger\
nil\
@end group\
@end smallexample\
\
Each element of the list is printed on a line of its own (that is what\
the function @code\{print\} does) and then the value returned by the\
function is printed.  Since the last expression in the function is the\
@code\{while\} loop, and since @code\{while\} loops always return\
@code\{nil\}, a @code\{nil\} is printed after the last element of the list.\
\
@node Incrementing Loop, Incrementing Loop Details, print-elements-of-list, while\
@comment  node-name,  next,  previous,  up\
@subsection A Loop with an Incrementing Counter\
\
A loop is not useful unless it stops when it ought.  Besides\
controlling a loop with a list, a common way of stopping a loop is to\
write the first argument as a test that returns false when the correct\
number of repetitions are complete.  This means that the loop must\
have a counter---an expression that counts how many times the loop\
repeats itself.\
\
@node Incrementing Loop Details, Decrementing Loop, Incrementing Loop, while\
@ifnottex\
@unnumberedsubsec Details of an Incrementing Loop\
@end ifnottex\
\
The test for a loop with an incrementing counter can be an expression\
such as @code\{(< count desired-number)\} which returns @code\{t\} for\
true if the value of @code\{count\} is less than the\
@code\{desired-number\} of repetitions and @code\{nil\} for false if the\
value of @code\{count\} is equal to or is greater than the\
@code\{desired-number\}.  The expression that increments the count can\
be a simple @code\{setq\} such as @code\{(setq count (1+ count))\}, where\
@code\{1+\} is a built-in function in Emacs Lisp that adds 1 to its\
argument.  (The expression @w\{@code\{(1+ count)\}\} has the same result\
as @w\{@code\{(+ count 1)\}\}, but is easier for a human to read.)\
\
@need 1250\
The template for a @code\{while\} loop controlled by an incrementing\
counter looks like this:\
\
@smallexample\
@group\
@var\{set-count-to-initial-value\}\
(while (< count desired-number)         ; @r\{true-or-false-test\}\
  @var\{body\}@dots\{\}\
  (setq count (1+ count)))              ; @r\{incrementer\}\
@end group\
@end smallexample\
\
@noindent\
Note that you need to set the initial value of @code\{count\}; usually it\
is set to 1.\
\
@menu\
* Incrementing Example::        Counting pebbles in a triangle.\
* Inc Example parts::           The parts of the function definition.\
* Inc Example altogether::      Putting the function definition together.\
@end menu\
\
@node Incrementing Example, Inc Example parts, Incrementing Loop Details, Incrementing Loop Details\
@unnumberedsubsubsec  Example with incrementing counter\
\
Suppose you are playing on the beach and decide to make a triangle of\
pebbles, putting one pebble in the first row, two in the second row,\
three in the third row and so on, like this:\
\
@sp 1\
@c pebble diagram\
@ifnottex\
@smallexample\
@group\
               *\
              * *\
             * * *\
            * * * *\
@end group\
@end smallexample\
@end ifnottex\
@iftex\
@smallexample\
@group\
               @bullet\{\}\
              @bullet\{\} @bullet\{\}\
             @bullet\{\} @bullet\{\} @bullet\{\}\
            @bullet\{\} @bullet\{\} @bullet\{\} @bullet\{\}\
@end group\
@end smallexample\
@end iftex\
@sp 1\
\
@noindent\
(About 2500 years ago, Pythagoras and others developed the beginnings of\
number theory by considering questions such as this.)\
\
Suppose you want to know how many pebbles you will need to make a\
triangle with 7 rows?\
\
Clearly, what you need to do is add up the numbers from 1 to 7.  There\
are two ways to do this; start with the smallest number, one, and add up\
the list in sequence, 1, 2, 3, 4 and so on; or start with the largest\
number and add the list going down: 7, 6, 5, 4 and so on.  Because both\
mechanisms illustrate common ways of writing @code\{while\} loops, we will\
create two examples, one counting up and the other counting down.  In\
this first example, we will start with 1 and add 2, 3, 4 and so on.\
\
If you are just adding up a short list of numbers, the easiest way to do\
it is to add up all the numbers at once.  However, if you do not know\
ahead of time how many numbers your list will have, or if you want to be\
prepared for a very long list, then you need to design your addition so\
that what you do is repeat a simple process many times instead of doing\
a more complex process once.\
\
For example, instead of adding up all the pebbles all at once, what you\
can do is add the number of pebbles in the first row, 1, to the number\
in the second row, 2, and then add the total of those two rows to the\
third row, 3.  Then you can add the number in the fourth row, 4, to the\
total of the first three rows; and so on.\
\
The critical characteristic of the process is that each repetitive\
action is simple.  In this case, at each step we add only two numbers,\
the number of pebbles in the row and the total already found.  This\
process of adding two numbers is repeated again and again until the last\
row has been added to the total of all the preceding rows.  In a more\
complex loop the repetitive action might not be so simple, but it will\
be simpler than doing everything all at once.\
\
@node Inc Example parts, Inc Example altogether, Incrementing Example, Incrementing Loop Details\
@unnumberedsubsubsec The parts of the function definition\
\
The preceding analysis gives us the bones of our function definition:\
first, we will need a variable that we can call @code\{total\} that will\
be the total number of pebbles.  This will be the value returned by\
the function.\
\
Second, we know that the function will require an argument: this\
argument will be the total number of rows in the triangle.  It can be\
called @code\{number-of-rows\}.\
\
Finally, we need a variable to use as a counter.  We could call this\
variable @code\{counter\}, but a better name is @code\{row-number\}.  That\
is because what the counter does in this function is count rows, and a\
program should be written to be as understandable as possible.\
\
When the Lisp interpreter first starts evaluating the expressions in the\
function, the value of @code\{total\} should be set to zero, since we have\
not added anything to it.  Then the function should add the number of\
pebbles in the first row to the total, and then add the number of\
pebbles in the second to the total, and then add the number of\
pebbles in the third row to the total, and so on, until there are no\
more rows left to add.\
\
Both @code\{total\} and @code\{row-number\} are used only inside the\
function, so they can be declared as local variables with @code\{let\}\
and given initial values.  Clearly, the initial value for @code\{total\}\
should be 0.  The initial value of @code\{row-number\} should be 1,\
since we start with the first row.  This means that the @code\{let\}\
statement will look like this:\
\
@smallexample\
@group\
  (let ((total 0)\
        (row-number 1))\
    @var\{body\}@dots\{\})\
@end group\
@end smallexample\
\
After the internal variables are declared and bound to their initial\
values, we can begin the @code\{while\} loop.  The expression that serves\
as the test should return a value of @code\{t\} for true so long as the\
@code\{row-number\} is less than or equal to the @code\{number-of-rows\}.\
(If the expression tests true only so long as the row number is less\
than the number of rows in the triangle, the last row will never be\
added to the total; hence the row number has to be either less than or\
equal to the number of rows.)\
\
@need 1500\
@findex <= @r\{(less than or equal)\}\
Lisp provides the @code\{<=\} function that returns true if the value of\
its first argument is less than or equal to the value of its second\
argument and false otherwise.  So the expression that the @code\{while\}\
will evaluate as its test should look like this:\
\
@smallexample\
(<= row-number number-of-rows)\
@end smallexample\
\
The total number of pebbles can be found by repeatedly adding the number\
of pebbles in a row to the total already found.  Since the number of\
pebbles in the row is equal to the row number, the total can be found by\
adding the row number to the total.  (Clearly, in a more complex\
situation, the number of pebbles in the row might be related to the row\
number in a more complicated way; if this were the case, the row number\
would be replaced by the appropriate expression.)\
\
@smallexample\
(setq total (+ total row-number))\
@end smallexample\
\
@noindent\
What this does is set the new value of @code\{total\} to be equal to the\
sum of adding the number of pebbles in the row to the previous total.\
\
After setting the value of @code\{total\}, the conditions need to be\
established for the next repetition of the loop, if there is one.  This\
is done by incrementing the value of the @code\{row-number\} variable,\
which serves as a counter.  After the @code\{row-number\} variable has\
been incremented, the true-or-false-test at the beginning of the\
@code\{while\} loop tests whether its value is still less than or equal to\
the value of the @code\{number-of-rows\} and if it is, adds the new value\
of the @code\{row-number\} variable to the @code\{total\} of the previous\
repetition of the loop.\
\
@need 1200\
The built-in Emacs Lisp function @code\{1+\} adds 1 to a number, so the\
@code\{row-number\} variable can be incremented with this expression:\
\
@smallexample\
(setq row-number (1+ row-number))\
@end smallexample\
\
@node Inc Example altogether,  , Inc Example parts, Incrementing Loop Details\
@unnumberedsubsubsec Putting the function definition together\
\
We have created the parts for the function definition; now we need to\
put them together.\
\
@need 800\
First, the contents of the @code\{while\} expression:\
\
@smallexample\
@group\
(while (<= row-number number-of-rows)   ; @r\{true-or-false-test\}\
  (setq total (+ total row-number))\
  (setq row-number (1+ row-number)))    ; @r\{incrementer\}\
@end group\
@end smallexample\
\
Along with the @code\{let\} expression varlist, this very nearly\
completes the body of the function definition.  However, it requires\
one final element, the need for which is somewhat subtle.\
\
The final touch is to place the variable @code\{total\} on a line by\
itself after the @code\{while\} expression.  Otherwise, the value returned\
by the whole function is the value of the last expression that is\
evaluated in the body of the @code\{let\}, and this is the value\
returned by the @code\{while\}, which is always @code\{nil\}.\
\
This may not be evident at first sight.  It almost looks as if the\
incrementing expression is the last expression of the whole function.\
But that expression is part of the body of the @code\{while\}; it is the\
last element of the list that starts with the symbol @code\{while\}.\
Moreover, the whole of the @code\{while\} loop is a list within the body\
of the @code\{let\}.\
\
@need 1250\
In outline, the function will look like this:\
\
@smallexample\
@group\
(defun @var\{name-of-function\} (@var\{argument-list\})\
  "@var\{documentation\}@dots\{\}"\
  (let (@var\{varlist\})\
    (while (@var\{true-or-false-test\})\
      @var\{body-of-while\}@dots\{\} )\
    @dots\{\} ))                    ; @r\{Need final expression here.\}\
@end group\
@end smallexample\
\
The result of evaluating the @code\{let\} is what is going to be returned\
by the @code\{defun\} since the @code\{let\} is not embedded within any\
containing list, except for the @code\{defun\} as a whole.  However, if\
the @code\{while\} is the last element of the @code\{let\} expression, the\
function will always return @code\{nil\}.  This is not what we want!\
Instead, what we want is the value of the variable @code\{total\}.  This\
is returned by simply placing the symbol as the last element of the list\
starting with @code\{let\}.  It gets evaluated after the preceding\
elements of the list are evaluated, which means it gets evaluated after\
it has been assigned the correct value for the total.\
\
It may be easier to see this by printing the list starting with\
@code\{let\} all on one line.  This format makes it evident that the\
@var\{varlist\} and @code\{while\} expressions are the second and third\
elements of the list starting with @code\{let\}, and the @code\{total\} is\
the last element:\
\
@smallexample\
@group\
(let (@var\{varlist\}) (while (@var\{true-or-false-test\}) @var\{body-of-while\}@dots\{\} ) total)\
@end group\
@end smallexample\
\
@need 1200\
Putting everything together, the @code\{triangle\} function definition\
looks like this:\
\
@smallexample\
@group\
(defun triangle (number-of-rows)    ; @r\{Version with\}\
                                    ; @r\{  incrementing counter.\}\
  "Add up the number of pebbles in a triangle.\
The first row has one pebble, the second row two pebbles,\
the third row three pebbles, and so on.\
The argument is NUMBER-OF-ROWS."\
@end group\
@group\
  (let ((total 0)\
        (row-number 1))\
    (while (<= row-number number-of-rows)\
      (setq total (+ total row-number))\
      (setq row-number (1+ row-number)))\
    total))\
@end group\
@end smallexample\
\
@need 1200\
After you have installed @code\{triangle\} by evaluating the function, you\
can try it out.  Here are two examples:\
\
@smallexample\
@group\
(triangle 4)\
\
(triangle 7)\
@end group\
@end smallexample\
\
@noindent\
The sum of the first four numbers is 10 and the sum of the first seven\
numbers is 28.\
\
@node Decrementing Loop,  , Incrementing Loop Details, while\
@comment  node-name,  next,  previous,  up\
@subsection Loop with a Decrementing Counter\
\
Another common way to write a @code\{while\} loop is to write the test\
so that it determines whether a counter is greater than zero.  So long\
as the counter is greater than zero, the loop is repeated.  But when\
the counter is equal to or less than zero, the loop is stopped.  For\
this to work, the counter has to start out greater than zero and then\
be made smaller and smaller by a form that is evaluated\
repeatedly.\
\
The test will be an expression such as @code\{(> counter 0)\} which\
returns @code\{t\} for true if the value of @code\{counter\} is greater\
than zero, and @code\{nil\} for false if the value of @code\{counter\} is\
equal to or less than zero.  The expression that makes the number\
smaller and smaller can be a simple @code\{setq\} such as @code\{(setq\
counter (1- counter))\}, where @code\{1-\} is a built-in function in\
Emacs Lisp that subtracts 1 from its argument.\
\
@need 1250\
The template for a decrementing @code\{while\} loop looks like this:\
\
@smallexample\
@group\
(while (> counter 0)                    ; @r\{true-or-false-test\}\
  @var\{body\}@dots\{\}\
  (setq counter (1- counter)))          ; @r\{decrementer\}\
@end group\
@end smallexample\
\
@menu\
* Decrementing Example::        More pebbles on the beach.\
* Dec Example parts::           The parts of the function definition.\
* Dec Example altogether::      Putting the function definition together.\
@end menu\
\
@node Decrementing Example, Dec Example parts, Decrementing Loop, Decrementing Loop\
@unnumberedsubsubsec Example with decrementing counter\
\
To illustrate a loop with a decrementing counter, we will rewrite the\
@code\{triangle\} function so the counter decreases to zero.\
\
This is the reverse of the earlier version of the function.  In this\
case, to find out how many pebbles are needed to make a triangle with\
3 rows, add the number of pebbles in the third row, 3, to the number\
in the preceding row, 2, and then add the total of those two rows to\
the row that precedes them, which is 1.\
\
Likewise, to find the number of pebbles in a triangle with 7 rows, add\
the number of pebbles in the seventh row, 7, to the number in the\
preceding row, which is 6, and then add the total of those two rows to\
the row that precedes them, which is 5, and so on.  As in the previous\
example, each addition only involves adding two numbers, the total of\
the rows already added up and the number of pebbles in the row that is\
being added to the total.  This process of adding two numbers is\
repeated again and again until there are no more pebbles to add.\
\
We know how many pebbles to start with: the number of pebbles in the\
last row is equal to the number of rows.  If the triangle has seven\
rows, the number of pebbles in the last row is 7.  Likewise, we know how\
many pebbles are in the preceding row: it is one less than the number in\
the row.\
\
@node Dec Example parts, Dec Example altogether, Decrementing Example, Decrementing Loop\
@unnumberedsubsubsec The parts of the function definition\
\
We start with three variables: the total number of rows in the\
triangle; the number of pebbles in a row; and the total number of\
pebbles, which is what we want to calculate.  These variables can be\
named @code\{number-of-rows\}, @code\{number-of-pebbles-in-row\}, and\
@code\{total\}, respectively.\
\
Both @code\{total\} and @code\{number-of-pebbles-in-row\} are used only\
inside the function and are declared with @code\{let\}.  The initial\
value of @code\{total\} should, of course, be zero.  However, the\
initial value of @code\{number-of-pebbles-in-row\} should be equal to\
the number of rows in the triangle, since the addition will start with\
the longest row.\
\
@need 1250\
This means that the beginning of the @code\{let\} expression will look\
like this:\
\
@smallexample\
@group\
(let ((total 0)\
      (number-of-pebbles-in-row number-of-rows))\
  @var\{body\}@dots\{\})\
@end group\
@end smallexample\
\
The total number of pebbles can be found by repeatedly adding the number\
of pebbles in a row to the total already found, that is, by repeatedly\
evaluating the following expression:\
\
@smallexample\
(setq total (+ total number-of-pebbles-in-row))\
@end smallexample\
\
@noindent\
After the @code\{number-of-pebbles-in-row\} is added to the @code\{total\},\
the @code\{number-of-pebbles-in-row\} should be decremented by one, since\
the next time the loop repeats, the preceding row will be\
added to the total.\
\
The number of pebbles in a preceding row is one less than the number of\
pebbles in a row, so the built-in Emacs Lisp function @code\{1-\} can be\
used to compute the number of pebbles in the preceding row.  This can be\
done with the following expression:\
\
@smallexample\
@group\
(setq number-of-pebbles-in-row\
      (1- number-of-pebbles-in-row))\
@end group\
@end smallexample\
\
Finally, we know that the @code\{while\} loop should stop making repeated\
additions when there are no pebbles in a row.  So the test for\
the @code\{while\} loop is simply:\
\
@smallexample\
(while (> number-of-pebbles-in-row 0)\
@end smallexample\
\
@node Dec Example altogether,  , Dec Example parts, Decrementing Loop\
@unnumberedsubsubsec Putting the function definition together\
\
We can put these expressions together to create a function definition\
that works.  However, on examination, we find that one of the local\
variables is unneeded!\
\
@need 1250\
The function definition looks like this:\
\
@smallexample\
@group\
;;; @r\{First subtractive version.\}\
(defun triangle (number-of-rows)\
  "Add up the number of pebbles in a triangle."\
  (let ((total 0)\
        (number-of-pebbles-in-row number-of-rows))\
    (while (> number-of-pebbles-in-row 0)\
      (setq total (+ total number-of-pebbles-in-row))\
      (setq number-of-pebbles-in-row\
            (1- number-of-pebbles-in-row)))\
    total))\
@end group\
@end smallexample\
\
As written, this function works.\
\
However, we do not need @code\{number-of-pebbles-in-row\}.\
\
@cindex Argument as local variable\
When the @code\{triangle\} function is evaluated, the symbol\
@code\{number-of-rows\} will be bound to a number, giving it an initial\
value.  That number can be changed in the body of the function as if\
it were a local variable, without any fear that such a change will\
effect the value of the variable outside of the function.  This is a\
very useful characteristic of Lisp; it means that the variable\
@code\{number-of-rows\} can be used anywhere in the function where\
@code\{number-of-pebbles-in-row\} is used.\
\
@need 800\
Here is a second version of the function written a bit more cleanly:\
\
@smallexample\
@group\
(defun triangle (number)                ; @r\{Second version.\}\
  "Return sum of numbers 1 through NUMBER inclusive."\
  (let ((total 0))\
    (while (> number 0)\
      (setq total (+ total number))\
      (setq number (1- number)))\
    total))\
@end group\
@end smallexample\
\
In brief, a properly written @code\{while\} loop will consist of three parts:\
\
@enumerate\
@item\
A test that will return false after the loop has repeated itself the\
correct number of times.\
\
@item\
An expression the evaluation of which will return the value desired\
after being repeatedly evaluated.\
\
@item\
An expression to change the value passed to the true-or-false-test so\
that the test returns false after the loop has repeated itself the right\
number of times.\
@end enumerate\
\
@node dolist dotimes, Recursion, while, Loops & Recursion\
@comment  node-name,  next,  previous,  up\
@section Save your time: @code\{dolist\} and @code\{dotimes\}\
\
In addition to @code\{while\}, both @code\{dolist\} and @code\{dotimes\}\
provide for looping.  Sometimes these are quicker to write than the\
equivalent @code\{while\} loop.  Both are Lisp macros.  (@xref\{Macros, ,\
Macros, elisp, The GNU Emacs Lisp Reference Manual\}. )\
\
@code\{dolist\} works like a @code\{while\} loop that `@sc\{cdr\}s down a\
list':  @code\{dolist\} automatically shortens the list each time it\
loops---takes the @sc\{cdr\} of the list---and binds the @sc\{car\} of\
each shorter version of the list to the first of its arguments.\
\
@code\{dotimes\} loops a specific number of times: you specify the number.\
\
@menu\
* dolist::\
* dotimes::\
@end menu\
\
@node dolist, dotimes, dolist dotimes, dolist dotimes\
@unnumberedsubsubsec The @code\{dolist\} Macro\
@findex dolist\
\
Suppose, for example, you want to reverse a list, so that\
``first'' ``second'' ``third'' becomes ``third'' ``second'' ``first''.\
\
@need 1250\
In practice, you would use the @code\{reverse\} function, like this:\
\
@smallexample\
@group\
(setq animals '(gazelle giraffe lion tiger))\
\
(reverse animals)\
@end group\
@end smallexample\
\
@need 800\
@noindent\
Here is how you could reverse the list using a @code\{while\} loop:\
\
@smallexample\
@group\
(setq animals '(gazelle giraffe lion tiger))\
\
(defun reverse-list-with-while (list)\
  "Using while, reverse the order of LIST."\
  (let (value)  ; make sure list starts empty\
    (while list\
      (setq value (cons (car list) value))\
      (setq list (cdr list)))\
    value))\
\
(reverse-list-with-while animals)\
@end group\
@end smallexample\
\
@need 800\
@noindent\
And here is how you could use the @code\{dolist\} macro:\
\
@smallexample\
@group\
(setq animals '(gazelle giraffe lion tiger))\
\
(defun reverse-list-with-dolist (list)\
  "Using dolist, reverse the order of LIST."\
  (let (value)  ; make sure list starts empty\
    (dolist (element list value)\
      (setq value (cons element value)))))\
\
(reverse-list-with-dolist animals)\
@end group\
@end smallexample\
\
@need 1250\
@noindent\
In Info, you can place your cursor after the closing parenthesis of\
each expression and type @kbd\{C-x C-e\}; in each case, you should see\
\
@smallexample\
(tiger lion giraffe gazelle)\
@end smallexample\
\
@noindent\
in the echo area.\
\
For this example, the existing @code\{reverse\} function is obviously best.\
The @code\{while\} loop is just like our first example (@pxref\{Loop\
Example, , A @code\{while\} Loop and a List\}).  The @code\{while\} first\
checks whether the list has elements; if so, it constructs a new list\
by adding the first element of the list to the existing list (which in\
the first iteration of the loop is @code\{nil\}).  Since the second\
element is prepended in front of the first element, and the third\
element is prepended in front of the second element, the list is reversed.\
\
In the expression using a @code\{while\} loop,\
the @w\{@code\{(setq list (cdr list))\}\}\
expression shortens the list, so the @code\{while\} loop eventually\
stops.  In addition, it provides the @code\{cons\} expression with a new\
first element by creating a new and shorter list at each repetition of\
the loop.\
\
The @code\{dolist\} expression does very much the same as the\
@code\{while\} expression, except that the @code\{dolist\} macro does some\
of the work you have to do when writing a @code\{while\} expression.\
\
Like a @code\{while\} loop, a @code\{dolist\} loops.  What is different is\
that it automatically shortens the list each time it loops --- it\
`@sc\{cdr\}s down the list' on its own --- and it automatically binds\
the @sc\{car\} of each shorter version of the list to the first of its\
arguments.\
\
In the example, the @sc\{car\} of each shorter version of the list is\
referred to using the symbol @samp\{element\}, the list itself is called\
@samp\{list\}, and the value returned is called @samp\{value\}.  The\
remainder of the @code\{dolist\} expression is the body.\
\
The @code\{dolist\} expression binds the @sc\{car\} of each shorter\
version of the list to @code\{element\} and then evaluates the body of\
the expression; and repeats the loop.  The result is returned in\
@code\{value\}.\
\
@node dotimes,  , dolist, dolist dotimes\
@unnumberedsubsubsec The @code\{dotimes\} Macro\
@findex dotimes\
\
The @code\{dotimes\} macro is similar to @code\{dolist\}, except that it\
loops a specific number of times.\
\
The first argument to @code\{dotimes\} is assigned the numbers 0, 1, 2\
and so forth each time around the loop, and the value of the third\
argument is returned.  You need to provide the value of the second\
argument, which is how many times the macro loops.\
\
@need 1250\
For example, the following binds the numbers from 0 up to, but not\
including, the number 3 to the first argument, @var\{number\}, and then\
constructs a list of the three numbers.  (The first number is 0, the\
second number is 1, and the third number is 2; this makes a total of\
three numbers in all, starting with zero as the first number.)\
\
@smallexample\
@group\
(let (value)      ; otherwise a value is a void variable\
  (dotimes (number 3 value)\
    (setq value (cons number value))))\
\
@result\{\} (2 1 0)\
@end group\
@end smallexample\
\
@noindent\
@code\{dotimes\} returns @code\{value\}, so the way to use\
@code\{dotimes\} is to operate on some expression @var\{number\} number of\
times and then return the result, either as a list or an atom.\
\
@need 1250\
Here is an example of a @code\{defun\} that uses @code\{dotimes\} to add\
up the number of pebbles in a triangle.\
\
@smallexample\
@group\
(defun triangle-using-dotimes (number-of-rows)\
  "Using dotimes, add up the number of pebbles in a triangle."\
(let ((total 0))  ; otherwise a total is a void variable\
  (dotimes (number number-of-rows total)\
    (setq total (+ total (1+ number))))))\
\
(triangle-using-dotimes 4)\
@end group\
@end smallexample\
\
@node Recursion, Looping exercise, dolist dotimes, Loops & Recursion\
@comment  node-name,  next,  previous,  up\
@section Recursion\
@cindex Recursion\
\
A recursive function contains code that tells the Lisp interpreter to\
call a program that runs exactly like itself, but with slightly\
different arguments.  The code runs exactly the same because it has\
the same name.  However, even though the program has the same name, it\
is not the same entity.  It is different.  In the jargon, it is a\
different `instance'.\
\
Eventually, if the program is written correctly, the `slightly\
different arguments' will become sufficiently different from the first\
arguments that the final instance will stop.\
\
@menu\
* Building Robots::             Same model, different serial number ...\
* Recursive Definition Parts::  Walk until you stop ...\
* Recursion with list::         Using a list as the test whether to recurse.\
* Recursive triangle function::\
* Recursion with cond::\
* Recursive Patterns::          Often used templates.\
* No Deferment::                Don't store up work ...\
* No deferment solution::\
@end menu\
\
@node Building Robots, Recursive Definition Parts, Recursion, Recursion\
@comment  node-name,  next,  previous,  up\
@subsection Building Robots: Extending the Metaphor\
@cindex Building robots\
@cindex Robots, building\
\
It is sometimes helpful to think of a running program as a robot that\
does a job.  In doing its job, a recursive function calls on a second\
robot to help it.  The second robot is identical to the first in every\
way, except that the second robot helps the first and has been\
passed different arguments than the first.\
\
In a recursive function, the second robot may call a third; and the\
third may call a fourth, and so on.  Each of these is a different\
entity; but all are clones.\
\
Since each robot has slightly different instructions---the arguments\
will differ from one robot to the next---the last robot should know\
when to stop.\
\
Let's expand on the metaphor in which a computer program is a robot.\
\
A function definition provides the blueprints for a robot.  When you\
install a function definition, that is, when you evaluate a\
@code\{defun\} special form, you install the necessary equipment to\
build robots.  It is as if you were in a factory, setting up an\
assembly line.  Robots with the same name are built according to the\
same blueprints.  So they have, as it were, the same `model number',\
but a different `serial number'.\
\
We often say that a recursive function `calls itself'.  What we mean\
is that the instructions in a recursive function cause the Lisp\
interpreter to run a different function that has the same name and\
does the same job as the first, but with different arguments.\
\
It is important that the arguments differ from one instance to the\
next; otherwise, the process will never stop.\
\
@node Recursive Definition Parts, Recursion with list, Building Robots, Recursion\
@comment  node-name,  next,  previous,  up\
@subsection The Parts of a Recursive Definition\
@cindex Parts of a Recursive Definition\
@cindex Recursive Definition Parts\
\
A recursive function typically contains a conditional expression which\
has three parts:\
\
@enumerate\
@item\
A true-or-false-test that determines whether the function is called\
again, here called the @dfn\{do-again-test\}.\
\
@item\
The name of the function.  When this name is called, a new instance of\
the function---a new robot, as it were---is created and told what to do.\
\
@item\
An expression that returns a different value each time the function is\
called, here called the @dfn\{next-step-expression\}.  Consequently, the\
argument (or arguments) passed to the new instance of the function\
will be different from that passed to the previous instance.  This\
causes the conditional expression, the @dfn\{do-again-test\}, to test\
false after the correct number of repetitions.\
@end enumerate\
\
Recursive functions can be much simpler than any other kind of\
function.  Indeed, when people first start to use them, they often look\
so mysteriously simple as to be incomprehensible.  Like riding a\
bicycle, reading a recursive function definition takes a certain knack\
which is hard at first but then seems simple.\
\
@need 1200\
There are several different common recursive patterns.  A very simple\
pattern looks like this:\
\
@smallexample\
@group\
(defun @var\{name-of-recursive-function\} (@var\{argument-list\})\
  "@var\{documentation\}@dots\{\}"\
  (if @var\{do-again-test\}\
    @var\{body\}@dots\{\}\
    (@var\{name-of-recursive-function\}\
         @var\{next-step-expression\})))\
@end group\
@end smallexample\
\
Each time a recursive function is evaluated, a new instance of it is\
created and told what to do.  The arguments tell the instance what to do.\
\
An argument is bound to the value of the next-step-expression.  Each\
instance runs with a different value of the next-step-expression.\
\
The value in the next-step-expression is used in the do-again-test.\
\
The value returned by the next-step-expression is passed to the new\
instance of the function, which evaluates it (or some\
transmogrification of it) to determine whether to continue or stop.\
The next-step-expression is designed so that the do-again-test returns\
false when the function should no longer be repeated.\
\
The do-again-test is sometimes called the @dfn\{stop condition\},\
since it stops the repetitions when it tests false.\
\
@node Recursion with list, Recursive triangle function, Recursive Definition Parts, Recursion\
@comment  node-name,  next,  previous,  up\
@subsection Recursion with a List\
\
The example of a @code\{while\} loop that printed the elements of a list\
of numbers can be written recursively.  Here is the code, including\
an expression to set the value of the variable @code\{animals\} to a list.\
\
If you are using GNU Emacs 20 or before, this example must be copied\
to the @file\{*scratch*\} buffer and each expression must be evaluated\
there.  Use @kbd\{C-u C-x C-e\} to evaluate the\
@code\{(print-elements-recursively animals)\} expression so that the\
results are printed in the buffer; otherwise the Lisp interpreter will\
try to squeeze the results into the one line of the echo area.\
\
Also, place your cursor immediately after the last closing parenthesis\
of the @code\{print-elements-recursively\} function, before the comment.\
Otherwise, the Lisp interpreter will try to evaluate the comment.\
\
If you are using a more recent version of Emacs, you can evaluate this\
expression directly in Info.\
\
@findex print-elements-recursively\
@smallexample\
@group\
(setq animals '(gazelle giraffe lion tiger))\
\
(defun print-elements-recursively (list)\
  "Print each element of LIST on a line of its own.\
Uses recursion."\
  (when list                            ; @r\{do-again-test\}\
        (print (car list))              ; @r\{body\}\
        (print-elements-recursively     ; @r\{recursive call\}\
         (cdr list))))                  ; @r\{next-step-expression\}\
\
(print-elements-recursively animals)\
@end group\
@end smallexample\
\
The @code\{print-elements-recursively\} function first tests whether\
there is any content in the list; if there is, the function prints the\
first element of the list, the @sc\{car\} of the list.  Then the\
function `invokes itself', but gives itself as its argument, not the\
whole list, but the second and subsequent elements of the list, the\
@sc\{cdr\} of the list.\
\
Put another way, if the list is not empty, the function invokes\
another instance of code that is similar to the initial code, but is a\
different thread of execution, with different arguments than the first\
instance.\
\
Put in yet another way, if the list is not empty, the first robot\
assembles a second robot and tells it what to do; the second robot is\
a different individual from the first, but is the same model.\
\
When the second evaluation occurs, the @code\{when\} expression is\
evaluated and if true, prints the first element of the list it\
receives as its argument (which is the second element of the original\
list).  Then the function `calls itself' with the @sc\{cdr\} of the list\
it is invoked with, which (the second time around) is the @sc\{cdr\} of\
the @sc\{cdr\} of the original list.\
\
Note that although we say that the function `calls itself', what we\
mean is that the Lisp interpreter assembles and instructs a new\
instance of the program.  The new instance is a clone of the first,\
but is a separate individual.\
\
Each time the function `invokes itself', it invokes itself on a\
shorter version of the original list.  It creates a new instance that\
works on a shorter list.\
\
Eventually, the function invokes itself on an empty list.  It creates\
a new instance whose argument is @code\{nil\}.  The conditional expression\
tests the value of @code\{list\}.  Since the value of @code\{list\} is\
@code\{nil\}, the @code\{when\} expression tests false so the then-part is\
not evaluated.  The function as a whole then returns @code\{nil\}.\
\
@need 1200\
When you evaluate the expression @code\{(print-elements-recursively\
animals)\} in the @file\{*scratch*\} buffer, you see this result:\
\
@smallexample\
@group\
gazelle\
\
giraffe\
\
lion\
\
tiger\
nil\
@end group\
@end smallexample\
\
@need 2000\
@node Recursive triangle function, Recursion with cond, Recursion with list, Recursion\
@comment  node-name,  next,  previous,  up\
@subsection Recursion in Place of a Counter\
@findex triangle-recursively\
\
@need 1200\
The @code\{triangle\} function described in a previous section can also\
be written recursively.  It looks like this:\
\
@smallexample\
@group\
(defun triangle-recursively (number)\
  "Return the sum of the numbers 1 through NUMBER inclusive.\
Uses recursion."\
  (if (= number 1)                    ; @r\{do-again-test\}\
      1                               ; @r\{then-part\}\
    (+ number                         ; @r\{else-part\}\
       (triangle-recursively          ; @r\{recursive call\}\
        (1- number)))))               ; @r\{next-step-expression\}\
\
(triangle-recursively 7)\
@end group\
@end smallexample\
\
@noindent\
You can install this function by evaluating it and then try it by\
evaluating @code\{(triangle-recursively 7)\}.  (Remember to put your\
cursor immediately after the last parenthesis of the function\
definition, before the comment.)  The function evaluates to 28.\
\
To understand how this function works, let's consider what happens in the\
various cases when the function is passed 1, 2, 3, or 4 as the value of\
its argument.\
\
@menu\
* Recursive Example arg of 1 or 2::\
* Recursive Example arg of 3 or 4::\
@end menu\
\
@node Recursive Example arg of 1 or 2, Recursive Example arg of 3 or 4, Recursive triangle function, Recursive triangle function\
@ifnottex\
@unnumberedsubsubsec An argument of 1 or 2\
@end ifnottex\
\
First, what happens if the value of the argument is 1?\
\
The function has an @code\{if\} expression after the documentation\
string.  It tests whether the value of @code\{number\} is equal to 1; if\
so, Emacs evaluates the then-part of the @code\{if\} expression, which\
returns the number 1 as the value of the function.  (A triangle with\
one row has one pebble in it.)\
\
Suppose, however, that the value of the argument is 2.  In this case,\
Emacs evaluates the else-part of the @code\{if\} expression.\
\
@need 1200\
The else-part consists of an addition, the recursive call to\
@code\{triangle-recursively\} and a decrementing action; and it looks like\
this:\
\
@smallexample\
(+ number (triangle-recursively (1- number)))\
@end smallexample\
\
When Emacs evaluates this expression, the innermost expression is\
evaluated first; then the other parts in sequence.  Here are the steps\
in detail:\
\
@table @i\
@item Step 1 @w\{  \} Evaluate the innermost expression.\
\
The innermost expression is @code\{(1- number)\} so Emacs decrements the\
value of @code\{number\} from 2 to 1.\
\
@item Step 2 @w\{  \} Evaluate the @code\{triangle-recursively\} function.\
\
The Lisp interpreter creates an individual instance of\
@code\{triangle-recursively\}.  It does not matter that this function is\
contained within itself.  Emacs passes the result Step 1 as the\
argument used by this instance of the @code\{triangle-recursively\}\
function\
\
In this case, Emacs evaluates @code\{triangle-recursively\} with an\
argument of 1.  This means that this evaluation of\
@code\{triangle-recursively\} returns 1.\
\
@item Step 3 @w\{  \} Evaluate the value of @code\{number\}.\
\
The variable @code\{number\} is the second element of the list that\
starts with @code\{+\}; its value is 2.\
\
@item Step 4 @w\{  \} Evaluate the @code\{+\} expression.\
\
The @code\{+\} expression receives two arguments, the first\
from the evaluation of @code\{number\} (Step 3) and the second from the\
evaluation of @code\{triangle-recursively\} (Step 2).\
\
The result of the addition is the sum of 2 plus 1, and the number 3 is\
returned, which is correct.  A triangle with two rows has three\
pebbles in it.\
@end table\
\
@node Recursive Example arg of 3 or 4,  , Recursive Example arg of 1 or 2, Recursive triangle function\
@unnumberedsubsubsec An argument of 3 or 4\
\
Suppose that @code\{triangle-recursively\} is called with an argument of\
3.\
\
@table @i\
@item Step 1 @w\{  \} Evaluate the do-again-test.\
\
The @code\{if\} expression is evaluated first.  This is the do-again\
test and returns false, so the else-part of the @code\{if\} expression\
is evaluated.  (Note that in this example, the do-again-test causes\
the function to call itself when it tests false, not when it tests\
true.)\
\
@item Step 2 @w\{  \} Evaluate the innermost expression of the else-part.\
\
The innermost expression of the else-part is evaluated, which decrements\
3 to 2.  This is the next-step-expression.\
\
@item Step 3 @w\{  \} Evaluate the @code\{triangle-recursively\} function.\
\
The number 2 is passed to the @code\{triangle-recursively\} function.\
\
We already know what happens when Emacs evaluates @code\{triangle-recursively\} with\
an argument of 2.  After going through the sequence of actions described\
earlier, it returns a value of 3.  So that is what will happen here.\
\
@item Step 4 @w\{  \} Evaluate the addition.\
\
3 will be passed as an argument to the addition and will be added to the\
number with which the function was called, which is 3.\
@end table\
\
@noindent\
The value returned by the function as a whole will be 6.\
\
Now that we know what will happen when @code\{triangle-recursively\} is\
called with an argument of 3, it is evident what will happen if it is\
called with an argument of 4:\
\
@quotation\
@need 800\
In the recursive call, the evaluation of\
\
@smallexample\
(triangle-recursively (1- 4))\
@end smallexample\
\
@need 800\
@noindent\
will return the value of evaluating\
\
@smallexample\
(triangle-recursively 3)\
@end smallexample\
\
@noindent\
which is 6 and this value will be added to 4 by the addition in the\
third line.\
@end quotation\
\
@noindent\
The value returned by the function as a whole will be 10.\
\
Each time @code\{triangle-recursively\} is evaluated, it evaluates a\
version of itself---a different instance of itself---with a smaller\
argument, until the argument is small enough so that it does not\
evaluate itself.\
\
Note that this particular design for a recursive function\
requires that operations be deferred.\
\
Before @code\{(triangle-recursively 7)\} can calculate its answer, it\
must call @code\{(triangle-recursively 6)\}; and before\
@code\{(triangle-recursively 6)\} can calculate its answer, it must call\
@code\{(triangle-recursively 5)\}; and so on.  That is to say, the\
calculation that @code\{(triangle-recursively 7)\} makes must be\
deferred until @code\{(triangle-recursively 6)\} makes its calculation;\
and @code\{(triangle-recursively 6)\} must defer until\
@code\{(triangle-recursively 5)\} completes; and so on.\
\
If each of these instances of @code\{triangle-recursively\} are thought\
of as different robots, the first robot must wait for the second to\
complete its job, which must wait until the third completes, and so\
on.\
\
There is a way around this kind of waiting, which we will discuss in\
@ref\{No Deferment, , Recursion without Deferments\}.\
\
@node Recursion with cond, Recursive Patterns, Recursive triangle function, Recursion\
@comment  node-name,  next,  previous,  up\
@subsection Recursion Example Using @code\{cond\}\
@findex cond\
\
The version of @code\{triangle-recursively\} described earlier is written\
with the @code\{if\} special form.  It can also be written using another\
special form called @code\{cond\}.  The name of the special form\
@code\{cond\} is an abbreviation of the word @samp\{conditional\}.\
\
Although the @code\{cond\} special form is not used as often in the\
Emacs Lisp sources as @code\{if\}, it is used often enough to justify\
explaining it.\
\
@need 800\
The template for a @code\{cond\} expression looks like this:\
\
@smallexample\
@group\
(cond\
 @var\{body\}@dots\{\})\
@end group\
@end smallexample\
\
@noindent\
where the @var\{body\} is a series of lists.\
\
@need 800\
Written out more fully, the template looks like this:\
\
@smallexample\
@group\
(cond\
 (@var\{first-true-or-false-test\} @var\{first-consequent\})\
 (@var\{second-true-or-false-test\} @var\{second-consequent\})\
 (@var\{third-true-or-false-test\} @var\{third-consequent\})\
  @dots\{\})\
@end group\
@end smallexample\
\
When the Lisp interpreter evaluates the @code\{cond\} expression, it\
evaluates the first element (the @sc\{car\} or true-or-false-test) of\
the first expression in a series of expressions within the body of the\
@code\{cond\}.\
\
If the true-or-false-test returns @code\{nil\} the rest of that\
expression, the consequent, is skipped and  the true-or-false-test of the\
next expression is evaluated.  When an expression is found whose\
true-or-false-test returns a value that is not @code\{nil\}, the\
consequent of that expression is evaluated.  The consequent can be one\
or more expressions.  If the consequent consists of more than one\
expression, the expressions are evaluated in sequence and the value of\
the last one is returned.  If the expression does not have a consequent,\
the value of the true-or-false-test is returned.\
\
If none of the true-or-false-tests test true, the @code\{cond\} expression\
returns @code\{nil\}.\
\
@need 1250\
Written using @code\{cond\}, the @code\{triangle\} function looks like this:\
\
@smallexample\
@group\
(defun triangle-using-cond (number)\
  (cond ((<= number 0) 0)\
        ((= number 1) 1)\
        ((> number 1)\
         (+ number (triangle-using-cond (1- number))))))\
@end group\
@end smallexample\
\
@noindent\
In this example, the @code\{cond\} returns 0 if the number is less than or\
equal to 0, it returns 1 if the number is 1 and it evaluates @code\{(+\
number (triangle-using-cond (1- number)))\} if the number is greater than\
1.\
\
@node Recursive Patterns, No Deferment, Recursion with cond, Recursion\
@comment  node-name,  next,  previous,  up\
@subsection Recursive Patterns\
@cindex Recursive Patterns\
\
Here are three common recursive patterns.  Each involves a list.\
Recursion does not need to involve lists, but Lisp is designed for lists\
and this provides a sense of its primal capabilities.\
\
@menu\
* Every::\
* Accumulate::\
* Keep::\
@end menu\
\
@node Every, Accumulate, Recursive Patterns, Recursive Patterns\
@comment  node-name,  next,  previous,  up\
@unnumberedsubsubsec Recursive Pattern: @emph\{every\}\
@cindex Every, type of recursive pattern\
@cindex Recursive pattern: every\
\
In the @code\{every\} recursive pattern, an action is performed on every\
element of a list.\
\
@need 1500\
The basic pattern is:\
\
@itemize @bullet\
@item\
If a list be empty, return @code\{nil\}.\
@item\
Else, act on the beginning of the list (the @sc\{car\} of the list)\
    @itemize @minus\
    @item\
    through a recursive call by the function on the rest (the\
    @sc\{cdr\}) of the list,\
    @item\
    and, optionally, combine the acted-on element, using @code\{cons\},\
    with the results of acting on the rest.\
    @end itemize\
@end itemize\
\
@need 1500\
Here is example:\
\
@smallexample\
@group\
(defun square-each (numbers-list)\
  "Square each of a NUMBERS LIST, recursively."\
  (if (not numbers-list)                ; do-again-test\
      nil\
    (cons\
     (* (car numbers-list) (car numbers-list))\
     (square-each (cdr numbers-list))))) ; next-step-expression\
@end group\
\
@group\
(square-each '(1 2 3))\
    @result\{\} (1 4 9)\
@end group\
@end smallexample\
\
@need 1200\
@noindent\
If @code\{numbers-list\} is empty, do nothing.  But if it has content,\
construct a list combining the square of the first number in the list\
with the result of the recursive call.\
\
(The example follows the pattern exactly: @code\{nil\} is returned if\
the numbers' list is empty.  In practice, you would write the\
conditional so it carries out the action when the numbers' list is not\
empty.)\
\
The @code\{print-elements-recursively\} function (@pxref\{Recursion with\
list, , Recursion with a List\}) is another example of an @code\{every\}\
pattern, except in this case, rather than bring the results together\
using @code\{cons\}, we print each element of output.\
\
@need 1250\
The @code\{print-elements-recursively\} function looks like this:\
\
@smallexample\
@group\
(setq animals '(gazelle giraffe lion tiger))\
@end group\
\
@group\
(defun print-elements-recursively (list)\
  "Print each element of LIST on a line of its own.\
Uses recursion."\
  (when list                            ; @r\{do-again-test\}\
        (print (car list))              ; @r\{body\}\
        (print-elements-recursively     ; @r\{recursive call\}\
         (cdr list))))                  ; @r\{next-step-expression\}\
\
(print-elements-recursively animals)\
@end group\
@end smallexample\
\
@need 1500\
The pattern for @code\{print-elements-recursively\} is:\
\
@itemize @bullet\
@item\
When the list is empty, do nothing.\
@item\
But when the list has at least one element,\
    @itemize @minus\
    @item\
    act on the beginning of the list (the @sc\{car\} of the list),\
    @item\
    and make a recursive call on the rest (the @sc\{cdr\}) of the list.\
    @end itemize\
@end itemize\
\
@node Accumulate, Keep, Every, Recursive Patterns\
@comment  node-name,  next,  previous,  up\
@unnumberedsubsubsec Recursive Pattern: @emph\{accumulate\}\
@cindex Accumulate, type of recursive pattern\
@cindex Recursive pattern: accumulate\
\
Another recursive pattern is called the @code\{accumulate\} pattern.  In\
the @code\{accumulate\} recursive pattern, an action is performed on\
every element of a list and the result of that action is accumulated\
with the results of performing the action on the other elements.\
\
This is very like the `every' pattern using @code\{cons\}, except that\
@code\{cons\} is not used, but some other combiner.\
\
@need 1500\
The pattern is:\
\
@itemize @bullet\
@item\
If a list be empty, return zero or some other constant.\
@item\
Else, act on the beginning of the list (the @sc\{car\} of the list),\
    @itemize @minus\
    @item\
    and combine that acted-on element, using @code\{+\} or\
    some other combining function, with\
    @item\
    a recursive call by the function on the rest (the @sc\{cdr\}) of the list.\
    @end itemize\
@end itemize\
\
@need 1500\
Here is an example:\
\
@smallexample\
@group\
(defun add-elements (numbers-list)\
  "Add the elements of NUMBERS-LIST together."\
  (if (not numbers-list)\
      0\
    (+ (car numbers-list) (add-elements (cdr numbers-list)))))\
@end group\
\
@group\
(add-elements '(1 2 3 4))\
    @result\{\} 10\
@end group\
@end smallexample\
\
@xref\{Files List, , Making a List of Files\}, for an example of the\
accumulate pattern.\
\
@node Keep,  , Accumulate, Recursive Patterns\
@comment  node-name,  next,  previous,  up\
@unnumberedsubsubsec Recursive Pattern: @emph\{keep\}\
@cindex Keep, type of recursive pattern\
@cindex Recursive pattern: keep\
\
A third recursive pattern is called the @code\{keep\} pattern.\
In the @code\{keep\} recursive pattern, each element of a list is tested;\
the element is acted on and the results are kept only if the element\
meets a criterion.\
\
Again, this is very like the `every' pattern, except the element is\
skipped unless it meets a criterion.\
\
@need 1500\
The pattern has three parts:\
\
@itemize @bullet\
@item\
If a list be empty, return @code\{nil\}.\
@item\
Else, if the beginning of the list (the @sc\{car\} of the list) passes\
        a test\
    @itemize @minus\
    @item\
    act on that element and combine it, using @code\{cons\} with\
    @item\
    a recursive call by the function on the rest (the @sc\{cdr\}) of the list.\
    @end itemize\
@item\
Otherwise, if the beginning of the list (the @sc\{car\} of the list) fails\
the test\
    @itemize @minus\
    @item\
    skip on that element,\
    @item\
    and, recursively call the function on the rest (the @sc\{cdr\}) of the list.\
    @end itemize\
@end itemize\
\
@need 1500\
Here is an example that uses @code\{cond\}:\
\
@smallexample\
@group\
(defun keep-three-letter-words (word-list)\
  "Keep three letter words in WORD-LIST."\
  (cond\
   ;; First do-again-test: stop-condition\
   ((not word-list) nil)\
\
   ;; Second do-again-test: when to act\
   ((eq 3 (length (symbol-name (car word-list))))\
    ;; combine acted-on element with recursive call on shorter list\
    (cons (car word-list) (keep-three-letter-words (cdr word-list))))\
\
   ;; Third do-again-test: when to skip element;\
   ;;   recursively call shorter list with next-step expression\
   (t (keep-three-letter-words (cdr word-list)))))\
@end group\
\
@group\
(keep-three-letter-words '(one two three four five six))\
    @result\{\} (one two six)\
@end group\
@end smallexample\
\
It goes without saying that you need not use @code\{nil\} as the test for\
when to stop; and you can, of course, combine these patterns.\
\
@node No Deferment, No deferment solution, Recursive Patterns, Recursion\
@subsection Recursion without Deferments\
@cindex Deferment in recursion\
@cindex Recursion without Deferments\
\
Let's consider again what happens with the @code\{triangle-recursively\}\
function.  We will find that the intermediate calculations are\
deferred until all can be done.\
\
@need 800\
Here is the function definition:\
\
@smallexample\
@group\
(defun triangle-recursively (number)\
  "Return the sum of the numbers 1 through NUMBER inclusive.\
Uses recursion."\
  (if (= number 1)                    ; @r\{do-again-test\}\
      1                               ; @r\{then-part\}\
    (+ number                         ; @r\{else-part\}\
       (triangle-recursively          ; @r\{recursive call\}\
        (1- number)))))               ; @r\{next-step-expression\}\
@end group\
@end smallexample\
\
What happens when we call this function with a argument of 7?\
\
The first instance of the @code\{triangle-recursively\} function adds\
the number 7 to the value returned by a second instance of\
@code\{triangle-recursively\}, an instance that has been passed an\
argument of 6.  That is to say, the first calculation is:\
\
@smallexample\
(+ 7 (triangle-recursively 6))\
@end smallexample\
\
@noindent\
The first instance of @code\{triangle-recursively\}---you may want to\
think of it as a little robot---cannot complete its job.  It must hand\
off the calculation for @code\{(triangle-recursively 6)\} to a second\
instance of the program, to a second robot.  This second individual is\
completely different from the first one; it is, in the jargon, a\
`different instantiation'.  Or, put another way, it is a different\
robot.  It is the same model as the first; it calculates triangle\
numbers recursively; but it has a different serial number.\
\
And what does @code\{(triangle-recursively 6)\} return?  It returns the\
number 6 added to the value returned by evaluating\
@code\{triangle-recursively\} with an argument of 5.  Using the robot\
metaphor, it asks yet another robot to help it.\
\
@need 800\
Now the total is:\
\
@smallexample\
(+ 7 6 (triangle-recursively 5))\
@end smallexample\
\
@need 800\
And what happens next?\
\
@smallexample\
(+ 7 6 5 (triangle-recursively 4))\
@end smallexample\
\
Each time @code\{triangle-recursively\} is called, except for the last\
time, it creates another instance of the program---another robot---and\
asks it to make a calculation.\
\
@need 800\
Eventually, the full addition is set up and performed:\
\
@smallexample\
(+ 7 6 5 4 3 2 1)\
@end smallexample\
\
This design for the function defers the calculation of the first step\
until the second can be done, and defers that until the third can be\
done, and so on.  Each deferment means the computer must remember what\
is being waited on.  This is not a problem when there are only a few\
steps, as in this example.  But it can be a problem when there are\
more steps.\
\
@node No deferment solution,  , No Deferment, Recursion\
@subsection No Deferment Solution\
@cindex No deferment solution\
@cindex Defermentless solution\
@cindex Solution without deferment\
\
The solution to the problem of deferred operations is to write in a\
manner that does not defer operations@footnote\{The phrase @dfn\{tail\
recursive\} is used to describe such a process, one that uses\
`constant space'.\}.  This requires\
writing to a different pattern, often one that involves writing two\
function definitions, an `initialization' function and a `helper'\
function.\
\
The `initialization' function sets up the job; the `helper' function\
does the work.\
\
@need 1200\
Here are the two function definitions for adding up numbers.  They are\
so simple, I find them hard to understand.\
\
@smallexample\
@group\
(defun triangle-initialization (number)\
  "Return the sum of the numbers 1 through NUMBER inclusive.\
This is the `initialization' component of a two function\
duo that uses recursion."\
  (triangle-recursive-helper 0 0 number))\
@end group\
@end smallexample\
\
@smallexample\
@group\
(defun triangle-recursive-helper (sum counter number)\
  "Return SUM, using COUNTER, through NUMBER inclusive.\
This is the `helper' component of a two function duo\
that uses recursion."\
  (if (> counter number)\
      sum\
    (triangle-recursive-helper (+ sum counter)  ; @r\{sum\}\
                               (1+ counter)     ; @r\{counter\}\
                               number)))        ; @r\{number\}\
@end group\
@end smallexample\
\
@need 1250\
Install both function definitions by evaluating them, then call\
@code\{triangle-initialization\} with 2 rows:\
\
@smallexample\
@group\
(triangle-initialization 2)\
    @result\{\} 3\
@end group\
@end smallexample\
\
The `initialization' function calls the first instance of the `helper'\
function with three arguments: zero, zero, and a number which is the\
number of rows in the triangle.\
\
The first two arguments passed to the `helper' function are\
initialization values.  These values are changed when\
@code\{triangle-recursive-helper\} invokes new instances.@footnote\{The\
jargon is mildly confusing:  @code\{triangle-recursive-helper\} uses a\
process that is iterative in a procedure that is recursive.  The\
process is called iterative because the computer need only record the\
three values, @code\{sum\}, @code\{counter\}, and @code\{number\}; the\
procedure is recursive because the function `calls itself'.  On the\
other hand, both the process and the procedure used by\
@code\{triangle-recursively\} are called recursive.  The word\
`recursive' has different meanings in the two contexts.\}\
\
Let's see what happens when we have a triangle that has one row.  (This\
triangle will have one pebble in it!)\
\
@need 1200\
@code\{triangle-initialization\} will call its helper with\
the arguments @w\{@code\{0 0 1\}\}.  That function will run the conditional\
test whether @code\{(> counter number)\}:\
\
@smallexample\
(> 0 1)\
@end smallexample\
\
@need 1200\
@noindent\
and find that the result is false, so it will invoke\
the else-part of the @code\{if\} clause:\
\
@smallexample\
@group\
    (triangle-recursive-helper\
     (+ sum counter)  ; @r\{sum plus counter\} @result\{\} @r\{sum\}\
     (1+ counter)     ; @r\{increment counter\} @result\{\} @r\{counter\}\
     number)          ; @r\{number stays the same\}\
@end group\
@end smallexample\
\
@need 800\
@noindent\
which will first compute:\
\
@smallexample\
@group\
(triangle-recursive-helper (+ 0 0)  ; @r\{sum\}\
                           (1+ 0)   ; @r\{counter\}\
                           1)       ; @r\{number\}\
@exdent which is:\
\
(triangle-recursive-helper 0 1 1)\
@end group\
@end smallexample\
\
Again, @code\{(> counter number)\} will be false, so again, the Lisp\
interpreter will evaluate @code\{triangle-recursive-helper\}, creating a\
new instance with new arguments.\
\
@need 800\
This new instance will be;\
\
@smallexample\
@group\
    (triangle-recursive-helper\
     (+ sum counter)  ; @r\{sum plus counter\} @result\{\} @r\{sum\}\
     (1+ counter)     ; @r\{increment counter\} @result\{\} @r\{counter\}\
     number)          ; @r\{number stays the same\}\
\
@exdent which is:\
\
(triangle-recursive-helper 1 2 1)\
@end group\
@end smallexample\
\
In this case, the @code\{(> counter number)\} test will be true!  So the\
instance will return the value of the sum, which will be 1, as\
expected.\
\
Now, let's pass @code\{triangle-initialization\} an argument\
of 2, to find out how many pebbles there are in a triangle with two rows.\
\
That function calls @code\{(triangle-recursive-helper 0 0 2)\}.\
\
@need 800\
In stages, the instances called will be:\
\
@smallexample\
@group\
                          @r\{sum counter number\}\
(triangle-recursive-helper 0    1       2)\
\
(triangle-recursive-helper 1    2       2)\
\
(triangle-recursive-helper 3    3       2)\
@end group\
@end smallexample\
\
When the last instance is called, the @code\{(> counter number)\} test\
will be true, so the instance will return the value of @code\{sum\},\
which will be 3.\
\
This kind of pattern helps when you are writing functions that can use\
many resources in a computer.\
\
@need 1500\
@node Looping exercise,  , Recursion, Loops & Recursion\
@section Looping Exercise\
\
@itemize @bullet\
@item\
Write a function similar to @code\{triangle\} in which each row has a\
value which is the square of the row number.  Use a @code\{while\} loop.\
\
@item\
Write a function similar to @code\{triangle\} that multiplies instead of\
adds the values.\
\
@item\
Rewrite these two functions recursively.  Rewrite these functions\
using @code\{cond\}.\
\
@c comma in printed title causes problem in Info cross reference\
@item\
Write a function for Texinfo mode that creates an index entry at the\
beginning of a paragraph for every @samp\{@@dfn\} within the paragraph.\
(In a Texinfo file, @samp\{@@dfn\} marks a definition.  This book is\
written in Texinfo.)\
\
Many of the functions you will need are described in two of the\
previous chapters, @ref\{Cutting & Storing Text, , Cutting and Storing\
Text\}, and @ref\{Yanking, , Yanking Text Back\}.  If you use\
@code\{forward-paragraph\} to put the index entry at the beginning of\
the paragraph, you will have to use @w\{@kbd\{C-h f\}\}\
(@code\{describe-function\}) to find out how to make the command go\
backwards.\
\
For more information, see\
@ifinfo\
@ref\{Indicating, , Indicating Definitions, texinfo\}.\
@end ifinfo\
@ifhtml\
@ref\{Indicating, , Indicating, texinfo, Texinfo Manual\}, which goes to\
a Texinfo manual in the current directory.  Or, if you are on the\
Internet, see\
@uref\{http://www.gnu.org/software/texinfo/manual/texinfo/\}\
@end ifhtml\
@iftex\
``Indicating Definitions, Commands, etc.'' in @cite\{Texinfo, The GNU\
Documentation Format\}.\
@end iftex\
@end itemize}