{\rtf1\ansi\ansicpg949\cocoartf1187\cocoasubrtf340
{\fonttbl\f0\fnil\fcharset129 AppleSDGothicNeo-Regular;}
{\colortbl;\red255\green255\blue255;}
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\fi360\sl288\slmult1\pardirnatural

\f0\fs28 \cf0 \
@node More Complex, Narrowing & Widening, Buffer Walk Through, Top\
@comment  node-name,  next,  previous,  up\
@chapter A Few More Complex Functions\
\
In this chapter, we build on what we have learned in previous chapters\
by looking at more complex functions.  The @code\{copy-to-buffer\}\
function illustrates use of two @code\{save-excursion\} expressions in\
one definition, while the @code\{insert-buffer\} function illustrates\
use of an asterisk in an @code\{interactive\} expression, use of\
@code\{or\}, and the important distinction between a name and the object\
to which the name refers.\
\
@menu\
* copy-to-buffer::              With @code\{set-buffer\}, @code\{get-buffer-create\}.\
* insert-buffer::               Read-only, and with @code\{or\}.\
* beginning-of-buffer::         Shows @code\{goto-char\},\
                                @code\{point-min\}, and @code\{push-mark\}.\
* Second Buffer Related Review::\
* optional Exercise::\
@end menu\
\
@node copy-to-buffer, insert-buffer, More Complex, More Complex\
@comment  node-name,  next,  previous,  up\
@section The Definition of @code\{copy-to-buffer\}\
@findex copy-to-buffer\
\
After understanding how @code\{append-to-buffer\} works, it is easy to\
understand @code\{copy-to-buffer\}.  This function copies text into a\
buffer, but instead of adding to the second buffer, it replaces all the\
previous text in the second buffer.\
\
@need 800\
The body of @code\{copy-to-buffer\} looks like this,\
\
@smallexample\
@group\
@dots\{\}\
(interactive "BCopy to buffer: \\nr")\
(let ((oldbuf (current-buffer)))\
  (with-current-buffer (get-buffer-create buffer)\
    (barf-if-buffer-read-only)\
    (erase-buffer)\
    (save-excursion\
      (insert-buffer-substring oldbuf start end)))))\
@end group\
@end smallexample\
\
The @code\{copy-to-buffer\} function has a simpler @code\{interactive\}\
expression than @code\{append-to-buffer\}.\
\
@need 800\
The definition then says\
\
@smallexample\
(with-current-buffer (get-buffer-create buffer) @dots\{\}\
@end smallexample\
\
First, look at the earliest inner expression; that is evaluated first.\
That expression starts with @code\{get-buffer-create buffer\}.  The\
function tells the computer to use the buffer with the name specified\
as the one to which you are copying, or if such a buffer does not\
exist, to create it.  Then, the @code\{with-current-buffer\} function\
evaluates its body with that buffer temporarily current.\
\
(This demonstrates another way to shift the computer's attention but\
not the user's.  The @code\{append-to-buffer\} function showed how to do\
the same with @code\{save-excursion\} and @code\{set-buffer\}.\
@code\{with-current-buffer\} is a newer, and arguably easier,\
mechanism.)\
\
The @code\{barf-if-buffer-read-only\} function sends you an error\
message saying the buffer is read-only if you cannot modify it.\
\
The next line has the @code\{erase-buffer\} function as its sole\
contents.  That function erases the buffer.\
\
Finally, the last two lines contain the @code\{save-excursion\}\
expression with @code\{insert-buffer-substring\} as its body.\
The  @code\{insert-buffer-substring\} expression copies the text from\
the buffer you are in (and you have not seen the computer shift its\
attention, so you don't know that that buffer is now called\
@code\{oldbuf\}).\
\
Incidentally, this is what is meant by `replacement'.  To replace text,\
Emacs erases the previous text and then inserts new text.\
\
@need 1250\
In outline, the body of @code\{copy-to-buffer\} looks like this:\
\
@smallexample\
@group\
(let (@var\{bind-\}@code\{oldbuf\}@var\{-to-value-of-\}@code\{current-buffer\})\
    (@var\{with-the-buffer-you-are-copying-to\}\
      (@var\{but-do-not-erase-or-copy-to-a-read-only-buffer\})\
      (erase-buffer)\
      (save-excursion\
        @var\{insert-substring-from-\}@code\{oldbuf\}@var\{-into-buffer\})))\
@end group\
@end smallexample\
\
@node insert-buffer, beginning-of-buffer, copy-to-buffer, More Complex\
@comment  node-name,  next,  previous,  up\
@section The Definition of @code\{insert-buffer\}\
@findex insert-buffer\
\
@code\{insert-buffer\} is yet another buffer-related function.  This\
command copies another buffer @emph\{into\} the current buffer.  It is the\
reverse of @code\{append-to-buffer\} or @code\{copy-to-buffer\}, since they\
copy a region of text @emph\{from\} the current buffer to another buffer.\
\
Here is a discussion based on the original code.  The code was\
simplified in 2003 and is harder to understand.\
\
(@xref\{New insert-buffer, , New Body for @code\{insert-buffer\}\}, to see\
a discussion of the new body.)\
\
In addition, this code illustrates the use of @code\{interactive\} with a\
buffer that might be @dfn\{read-only\} and the important distinction\
between the name of an object and the object actually referred to.\
\
@menu\
* insert-buffer code::\
* insert-buffer interactive::   When you can read, but not write.\
* insert-buffer body::          The body has an @code\{or\} and a @code\{let\}.\
* if & or::                     Using an @code\{if\} instead of an @code\{or\}.\
* Insert or::                   How the @code\{or\} expression works.\
* Insert let::                  Two @code\{save-excursion\} expressions.\
* New insert-buffer::\
@end menu\
\
@node insert-buffer code, insert-buffer interactive, insert-buffer, insert-buffer\
@ifnottex\
@unnumberedsubsec The Code for @code\{insert-buffer\}\
@end ifnottex\
\
@need 800\
Here is the earlier code:\
\
@smallexample\
@group\
(defun insert-buffer (buffer)\
  "Insert after point the contents of BUFFER.\
Puts mark after the inserted text.\
BUFFER may be a buffer or a buffer name."\
  (interactive "*bInsert buffer:@: ")\
@end group\
@group\
  (or (bufferp buffer)\
      (setq buffer (get-buffer buffer)))\
  (let (start end newmark)\
    (save-excursion\
      (save-excursion\
        (set-buffer buffer)\
        (setq start (point-min) end (point-max)))\
@end group\
@group\
      (insert-buffer-substring buffer start end)\
      (setq newmark (point)))\
    (push-mark newmark)))\
@end group\
@end smallexample\
\
@need 1200\
As with other function definitions, you can use a template to see an\
outline of the function:\
\
@smallexample\
@group\
(defun insert-buffer (buffer)\
  "@var\{documentation\}@dots\{\}"\
  (interactive "*bInsert buffer:@: ")\
  @var\{body\}@dots\{\})\
@end group\
@end smallexample\
\
@node insert-buffer interactive, insert-buffer body, insert-buffer code, insert-buffer\
@comment  node-name,  next,  previous,  up\
@subsection The Interactive Expression in @code\{insert-buffer\}\
@findex interactive, @r\{example use of\}\
\
In @code\{insert-buffer\}, the argument to the @code\{interactive\}\
declaration has two parts, an asterisk, @samp\{*\}, and @samp\{bInsert\
buffer:@: \}.\
\
@menu\
* Read-only buffer::            When a buffer cannot be modified.\
* b for interactive::           An existing buffer or else its name.\
@end menu\
\
@node Read-only buffer, b for interactive, insert-buffer interactive, insert-buffer interactive\
@comment  node-name,  next,  previous,  up\
@unnumberedsubsubsec A Read-only Buffer\
@cindex Read-only buffer\
@cindex Asterisk for read-only buffer\
@findex * @r\{for read-only buffer\}\
\
The asterisk is for the situation when the current buffer is a\
read-only buffer---a buffer that cannot be modified.  If\
@code\{insert-buffer\} is called when the current buffer is read-only, a\
message to this effect is printed in the echo area and the terminal\
may beep or blink at you; you will not be permitted to insert anything\
into current buffer.  The asterisk does not need to be followed by a\
newline to separate it from the next argument.\
\
@node b for interactive,  , Read-only buffer, insert-buffer interactive\
@comment  node-name,  next,  previous,  up\
@unnumberedsubsubsec @samp\{b\} in an Interactive Expression\
\
The next argument in the interactive expression starts with a lower\
case @samp\{b\}.  (This is different from the code for\
@code\{append-to-buffer\}, which uses an upper-case @samp\{B\}.\
@xref\{append-to-buffer, , The Definition of @code\{append-to-buffer\}\}.)\
The lower-case @samp\{b\} tells the Lisp interpreter that the argument\
for @code\{insert-buffer\} should be an existing buffer or else its\
name.  (The upper-case @samp\{B\} option provides for the possibility\
that the buffer does not exist.)  Emacs will prompt you for the name\
of the buffer, offering you a default buffer, with name completion\
enabled.  If the buffer does not exist, you receive a message that\
says ``No match''; your terminal may beep at you as well.\
\
The new and simplified code generates a list for @code\{interactive\}.\
It uses the @code\{barf-if-buffer-read-only\} and @code\{read-buffer\}\
functions with which we are already familiar and the @code\{progn\}\
special form with which we are not.  (It will be described later.)\
\
@node insert-buffer body, if & or, insert-buffer interactive, insert-buffer\
@comment  node-name,  next,  previous,  up\
@subsection The Body of the @code\{insert-buffer\} Function\
\
The body of the @code\{insert-buffer\} function has two major parts: an\
@code\{or\} expression and a @code\{let\} expression.  The purpose of the\
@code\{or\} expression is to ensure that the argument @code\{buffer\} is\
bound to a buffer and not just the name of a buffer.  The body of the\
@code\{let\} expression contains the code which copies the other buffer\
into the current buffer.\
\
@need 1250\
In outline, the two expressions fit into the @code\{insert-buffer\}\
function like this:\
\
@smallexample\
@group\
(defun insert-buffer (buffer)\
  "@var\{documentation\}@dots\{\}"\
  (interactive "*bInsert buffer:@: ")\
  (or @dots\{\}\
      @dots\{\}\
@end group\
@group\
  (let (@var\{varlist\})\
      @var\{body-of-\}@code\{let\}@dots\{\} )\
@end group\
@end smallexample\
\
To understand how the @code\{or\} expression ensures that the argument\
@code\{buffer\} is bound to a buffer and not to the name of a buffer, it\
is first necessary to understand the @code\{or\} function.\
\
Before doing this, let me rewrite this part of the function using\
@code\{if\} so that you can see what is done in a manner that will be familiar.\
\
@node if & or, Insert or, insert-buffer body, insert-buffer\
@comment  node-name,  next,  previous,  up\
@subsection @code\{insert-buffer\} With an @code\{if\} Instead of an @code\{or\}\
\
The job to be done is to make sure the value of @code\{buffer\} is a\
buffer itself and not the name of a buffer.  If the value is the name,\
then the buffer itself must be got.\
\
You can imagine yourself at a conference where an usher is wandering\
around holding a list with your name on it and looking for you: the\
usher is ``bound'' to your name, not to you; but when the usher finds\
you and takes your arm, the usher becomes ``bound'' to you.\
\
@need 800\
In Lisp, you might describe this situation like this:\
\
@smallexample\
@group\
(if (not (holding-on-to-guest))\
    (find-and-take-arm-of-guest))\
@end group\
@end smallexample\
\
We want to do the same thing with a buffer---if we do not have the\
buffer itself, we want to get it.\
\
@need 1200\
Using a predicate called @code\{bufferp\} that tells us whether we have a\
buffer (rather than its name), we can write the code like this:\
\
@smallexample\
@group\
(if (not (bufferp buffer))              ; @r\{if-part\}\
    (setq buffer (get-buffer buffer)))  ; @r\{then-part\}\
@end group\
@end smallexample\
\
@noindent\
Here, the true-or-false-test of the @code\{if\} expression is\
@w\{@code\{(not (bufferp buffer))\}\}; and the then-part is the expression\
@w\{@code\{(setq buffer (get-buffer buffer))\}\}.\
\
In the test, the function @code\{bufferp\} returns true if its argument is\
a buffer---but false if its argument is the name of the buffer.  (The\
last character of the function name @code\{bufferp\} is the character\
@samp\{p\}; as we saw earlier, such use of @samp\{p\} is a convention that\
indicates that the function is a predicate, which is a term that means\
that the function will determine whether some property is true or false.\
@xref\{Wrong Type of Argument, , Using the Wrong Type Object as an\
Argument\}.)\
\
@need 1200\
The function @code\{not\} precedes the expression @code\{(bufferp buffer)\},\
so the true-or-false-test looks like this:\
\
@smallexample\
(not (bufferp buffer))\
@end smallexample\
\
@noindent\
@code\{not\} is a function that returns true if its argument is false\
and false if its argument is true.  So if @code\{(bufferp buffer)\}\
returns true, the @code\{not\} expression returns false and vice-verse:\
what is ``not true'' is false and what is ``not false'' is true.\
\
Using this test, the @code\{if\} expression works as follows: when the\
value of the variable @code\{buffer\} is actually a buffer rather than\
its name, the true-or-false-test returns false and the @code\{if\}\
expression does not evaluate the then-part.  This is fine, since we do\
not need to do anything to the variable @code\{buffer\} if it really is\
a buffer.\
\
On the other hand, when the value of @code\{buffer\} is not a buffer\
itself, but the name of a buffer, the true-or-false-test returns true\
and the then-part of the expression is evaluated.  In this case, the\
then-part is @code\{(setq buffer (get-buffer buffer))\}.  This\
expression uses the @code\{get-buffer\} function to return an actual\
buffer itself, given its name.  The @code\{setq\} then sets the variable\
@code\{buffer\} to the value of the buffer itself, replacing its previous\
value (which was the name of the buffer).\
\
@node Insert or, Insert let, if & or, insert-buffer\
@comment  node-name,  next,  previous,  up\
@subsection The @code\{or\} in the Body\
\
The purpose of the @code\{or\} expression in the @code\{insert-buffer\}\
function is to ensure that the argument @code\{buffer\} is bound to a\
buffer and not just to the name of a buffer.  The previous section shows\
how the job could have been done using an @code\{if\} expression.\
However, the @code\{insert-buffer\} function actually uses @code\{or\}.\
To understand this, it is necessary to understand how @code\{or\} works.\
\
@findex or\
An @code\{or\} function can have any number of arguments.  It evaluates\
each argument in turn and returns the value of the first of its\
arguments that is not @code\{nil\}.  Also, and this is a crucial feature\
of @code\{or\}, it does not evaluate any subsequent arguments after\
returning the first non-@code\{nil\} value.\
\
@need 800\
The @code\{or\} expression looks like this:\
\
@smallexample\
@group\
(or (bufferp buffer)\
    (setq buffer (get-buffer buffer)))\
@end group\
@end smallexample\
\
@noindent\
The first argument to @code\{or\} is the expression @code\{(bufferp buffer)\}.\
This expression returns true (a non-@code\{nil\} value) if the buffer is\
actually a buffer, and not just the name of a buffer.  In the @code\{or\}\
expression, if this is the case, the @code\{or\} expression returns this\
true value and does not evaluate the next expression---and this is fine\
with us, since we do not want to do anything to the value of\
@code\{buffer\} if it really is a buffer.\
\
On the other hand, if the value of @code\{(bufferp buffer)\} is @code\{nil\},\
which it will be if the value of @code\{buffer\} is the name of a buffer,\
the Lisp interpreter evaluates the next element of the @code\{or\}\
expression.  This is the expression @code\{(setq buffer (get-buffer\
buffer))\}.  This expression returns a non-@code\{nil\} value, which\
is the value to which it sets the variable @code\{buffer\}---and this\
value is a buffer itself, not the name of a buffer.\
\
The result of all this is that the symbol @code\{buffer\} is always\
bound to a buffer itself rather than to the name of a buffer.  All\
this is necessary because the @code\{set-buffer\} function in a\
following line only works with a buffer itself, not with the name to a\
buffer.\
\
@need 1250\
Incidentally, using @code\{or\}, the situation with the usher would be\
written like this:\
\
@smallexample\
(or (holding-on-to-guest) (find-and-take-arm-of-guest))\
@end smallexample\
\
@node Insert let, New insert-buffer, Insert or, insert-buffer\
@comment  node-name,  next,  previous,  up\
@subsection The @code\{let\} Expression in @code\{insert-buffer\}\
\
After ensuring that the variable @code\{buffer\} refers to a buffer itself\
and not just to the name of a buffer, the @code\{insert-buffer function\}\
continues with a @code\{let\} expression.  This specifies three local\
variables, @code\{start\}, @code\{end\}, and @code\{newmark\} and binds them\
to the initial value @code\{nil\}.  These variables are used inside the\
remainder of the @code\{let\} and temporarily hide any other occurrence of\
variables of the same name in Emacs until the end of the @code\{let\}.\
\
@need 1200\
The body of the @code\{let\} contains two @code\{save-excursion\}\
expressions.  First, we will look at the inner @code\{save-excursion\}\
expression in detail.  The expression looks like this:\
\
@smallexample\
@group\
(save-excursion\
  (set-buffer buffer)\
  (setq start (point-min) end (point-max)))\
@end group\
@end smallexample\
\
@noindent\
The expression @code\{(set-buffer buffer)\} changes Emacs' attention\
from the current buffer to the one from which the text will copied.\
In that buffer, the variables @code\{start\} and @code\{end\} are set to\
the beginning and end of the buffer, using the commands\
@code\{point-min\} and @code\{point-max\}.  Note that we have here an\
illustration of how @code\{setq\} is able to set two variables in the\
same expression.  The first argument of @code\{setq\} is set to the\
value of its second, and its third argument is set to the value of its\
fourth.\
\
After the body of the inner @code\{save-excursion\} is evaluated, the\
@code\{save-excursion\} restores the original buffer, but @code\{start\} and\
@code\{end\} remain set to the values of the beginning and end of the\
buffer from which the text will be copied.\
\
@need 1250\
The outer @code\{save-excursion\} expression looks like this:\
\
@smallexample\
@group\
(save-excursion\
  (@var\{inner-\}@code\{save-excursion\}@var\{-expression\}\
     (@var\{go-to-new-buffer-and-set-\}@code\{start\}@var\{-and-\}@code\{end\})\
  (insert-buffer-substring buffer start end)\
  (setq newmark (point)))\
@end group\
@end smallexample\
\
@noindent\
The @code\{insert-buffer-substring\} function copies the text\
@emph\{into\} the current buffer @emph\{from\} the region indicated by\
@code\{start\} and @code\{end\} in @code\{buffer\}.  Since the whole of the\
second buffer lies between @code\{start\} and @code\{end\}, the whole of\
the second buffer is copied into the buffer you are editing.  Next,\
the value of point, which will be at the end of the inserted text, is\
recorded in the variable @code\{newmark\}.\
\
After the body of the outer @code\{save-excursion\} is evaluated, point\
and mark are relocated to their original places.\
\
However, it is convenient to locate a mark at the end of the newly\
inserted text and locate point at its beginning.  The @code\{newmark\}\
variable records the end of the inserted text.  In the last line of\
the @code\{let\} expression, the @code\{(push-mark newmark)\} expression\
function sets a mark to this location.  (The previous location of the\
mark is still accessible; it is recorded on the mark ring and you can\
go back to it with @kbd\{C-u C-@key\{SPC\}\}.)  Meanwhile, point is\
located at the beginning of the inserted text, which is where it was\
before you called the insert function, the position of which was saved\
by the first @code\{save-excursion\}.\
\
@need 1250\
The whole @code\{let\} expression looks like this:\
\
@smallexample\
@group\
(let (start end newmark)\
  (save-excursion\
    (save-excursion\
      (set-buffer buffer)\
      (setq start (point-min) end (point-max)))\
    (insert-buffer-substring buffer start end)\
    (setq newmark (point)))\
  (push-mark newmark))\
@end group\
@end smallexample\
\
Like the @code\{append-to-buffer\} function, the @code\{insert-buffer\}\
function uses @code\{let\}, @code\{save-excursion\}, and\
@code\{set-buffer\}.  In addition, the function illustrates one way to\
use @code\{or\}.  All these functions are building blocks that we will\
find and use again and again.\
\
@node New insert-buffer,  , Insert let, insert-buffer\
@comment  node-name,  next,  previous,  up\
@subsection New Body for @code\{insert-buffer\}\
@findex insert-buffer, new version body\
@findex new version body for insert-buffer\
\
The body in the GNU Emacs 22 version is more confusing than the original.\
\
@need 1250\
It consists of two expressions,\
\
@smallexample\
@group\
  (push-mark\
   (save-excursion\
     (insert-buffer-substring (get-buffer buffer))\
     (point)))\
\
   nil\
@end group\
@end smallexample\
\
@noindent\
except, and this is what confuses novices, very important work is done\
inside the @code\{push-mark\} expression.\
\
The @code\{get-buffer\} function returns a buffer with the name\
provided.  You will note that the function is @emph\{not\} called\
@code\{get-buffer-create\}; it does not create a buffer if one does not\
already exist.  The buffer returned by @code\{get-buffer\}, an existing\
buffer, is passed to @code\{insert-buffer-substring\}, which inserts the\
whole of the buffer (since you did not specify anything else).\
\
The location into which the buffer is inserted is recorded by\
@code\{push-mark\}.  Then the function returns @code\{nil\}, the value of\
its last command.  Put another way, the @code\{insert-buffer\} function\
exists only to produce a side effect, inserting another buffer, not to\
return any value.\
\
@node beginning-of-buffer, Second Buffer Related Review, insert-buffer, More Complex\
@comment  node-name,  next,  previous,  up\
@section Complete Definition of @code\{beginning-of-buffer\}\
@findex beginning-of-buffer\
\
The basic structure of the @code\{beginning-of-buffer\} function has\
already been discussed.  (@xref\{simplified-beginning-of-buffer, , A\
Simplified @code\{beginning-of-buffer\} Definition\}.)\
This section describes the complex part of the definition.\
\
As previously described, when invoked without an argument,\
@code\{beginning-of-buffer\} moves the cursor to the beginning of the\
buffer (in truth, the beginning of the accessible portion of the\
buffer), leaving the mark at the previous position.  However, when the\
command is invoked with a number between one and ten, the function\
considers that number to be a fraction of the length of the buffer,\
measured in tenths, and Emacs moves the cursor that fraction of the\
way from the beginning of the buffer.  Thus, you can either call this\
function with the key command @kbd\{M-<\}, which will move the cursor to\
the beginning of the buffer, or with a key command such as @kbd\{C-u 7\
M-<\} which will move the cursor to a point 70% of the way through the\
buffer.  If a number bigger than ten is used for the argument, it\
moves to the end of the buffer.\
\
The @code\{beginning-of-buffer\} function can be called with or without an\
argument.  The use of the argument is optional.\
\
@menu\
* Optional Arguments::\
* beginning-of-buffer opt arg::  Example with optional argument.\
* beginning-of-buffer complete::\
@end menu\
\
@node Optional Arguments, beginning-of-buffer opt arg, beginning-of-buffer, beginning-of-buffer\
@subsection Optional Arguments\
\
Unless told otherwise, Lisp expects that a function with an argument in\
its function definition will be called with a value for that argument.\
If that does not happen, you get an error and a message that says\
@samp\{Wrong number of arguments\}.\
\
@cindex Optional arguments\
@cindex Keyword\
@findex optional\
However, optional arguments are a feature of Lisp: a particular\
@dfn\{keyword\} is used to tell the Lisp interpreter that an argument is\
optional.  The keyword is @code\{&optional\}.  (The @samp\{&\} in front of\
@samp\{optional\} is part of the keyword.)  In a function definition, if\
an argument follows the keyword @code\{&optional\}, no value need be\
passed to that argument when the function is called.\
\
@need 1200\
The first line of the function definition of @code\{beginning-of-buffer\}\
therefore looks like this:\
\
@smallexample\
(defun beginning-of-buffer (&optional arg)\
@end smallexample\
\
@need 1250\
In outline, the whole function looks like this:\
\
@smallexample\
@group\
(defun beginning-of-buffer (&optional arg)\
  "@var\{documentation\}@dots\{\}"\
  (interactive "P")\
  (or (@var\{is-the-argument-a-cons-cell\} arg)\
      (and @var\{are-both-transient-mark-mode-and-mark-active-true\})\
      (push-mark))\
  (let (@var\{determine-size-and-set-it\})\
  (goto-char\
    (@var\{if-there-is-an-argument\}\
        @var\{figure-out-where-to-go\}\
      @var\{else-go-to\}\
      (point-min))))\
   @var\{do-nicety\}\
@end group\
@end smallexample\
\
The function is similar to the @code\{simplified-beginning-of-buffer\}\
function except that the @code\{interactive\} expression has @code\{"P"\}\
as an argument and the @code\{goto-char\} function is followed by an\
if-then-else expression that figures out where to put the cursor if\
there is an argument that is not a cons cell.\
\
(Since I do not explain a cons cell for many more chapters, please\
consider ignoring the function @code\{consp\}.  @xref\{List\
Implementation, , How Lists are Implemented\}, and @ref\{Cons Cell Type,\
, Cons Cell and List Types, elisp, The GNU Emacs Lisp Reference\
Manual\}.)\
\
The @code\{"P"\} in the @code\{interactive\} expression tells Emacs to\
pass a prefix argument, if there is one, to the function in raw form.\
A prefix argument is made by typing the @key\{META\} key followed by a\
number, or by typing @kbd\{C-u\} and then a number.  (If you don't type\
a number, @kbd\{C-u\} defaults to a cons cell with a 4.  A lowercase\
@code\{"p"\} in the @code\{interactive\} expression causes the function to\
convert a prefix arg to a number.)\
\
The true-or-false-test of the @code\{if\} expression looks complex, but\
it is not: it checks whether @code\{arg\} has a value that is not\
@code\{nil\} and whether it is a cons cell.  (That is what @code\{consp\}\
does; it checks whether its argument is a cons cell.)  If @code\{arg\}\
has a value that is not @code\{nil\} (and is not a cons cell), which\
will be the case if @code\{beginning-of-buffer\} is called with a\
numeric argument, then this true-or-false-test will return true and\
the then-part of the @code\{if\} expression will be evaluated.  On the\
other hand, if @code\{beginning-of-buffer\} is not called with an\
argument, the value of @code\{arg\} will be @code\{nil\} and the else-part\
of the @code\{if\} expression will be evaluated.  The else-part is\
simply @code\{point-min\}, and when this is the outcome, the whole\
@code\{goto-char\} expression is @code\{(goto-char (point-min))\}, which\
is how we saw the @code\{beginning-of-buffer\} function in its\
simplified form.\
\
@node beginning-of-buffer opt arg, beginning-of-buffer complete, Optional Arguments, beginning-of-buffer\
@subsection @code\{beginning-of-buffer\} with an Argument\
\
When @code\{beginning-of-buffer\} is called with an argument, an\
expression is evaluated which calculates what value to pass to\
@code\{goto-char\}.  This expression is rather complicated at first sight.\
It includes an inner @code\{if\} expression and much arithmetic.  It looks\
like this:\
\
@smallexample\
@group\
(if (> (buffer-size) 10000)\
    ;; @r\{Avoid overflow for large buffer sizes!\}\
                          (* (prefix-numeric-value arg)\
                             (/ size 10))\
  (/\
   (+ 10\
      (*\
       size (prefix-numeric-value arg))) 10)))\
@end group\
@end smallexample\
\
@menu\
* Disentangle beginning-of-buffer::\
* Large buffer case::\
* Small buffer case::\
@end menu\
\
@node Disentangle beginning-of-buffer, Large buffer case, beginning-of-buffer opt arg, beginning-of-buffer opt arg\
@ifnottex\
@unnumberedsubsubsec Disentangle @code\{beginning-of-buffer\}\
@end ifnottex\
\
Like other complex-looking expressions, the conditional expression\
within @code\{beginning-of-buffer\} can be disentangled by looking at it\
as parts of a template, in this case, the template for an if-then-else\
expression.  In skeletal form, the expression looks like this:\
\
@smallexample\
@group\
(if (@var\{buffer-is-large\}\
    @var\{divide-buffer-size-by-10-and-multiply-by-arg\}\
  @var\{else-use-alternate-calculation\}\
@end group\
@end smallexample\
\
The true-or-false-test of this inner @code\{if\} expression checks the\
size of the buffer.  The reason for this is that the old version 18\
Emacs used numbers that are no bigger than eight million or so and in\
the computation that followed, the programmer feared that Emacs might\
try to use over-large numbers if the buffer were large.  The term\
`overflow', mentioned in the comment, means numbers that are over\
large.  More recent versions of Emacs use larger numbers, but this\
code has not been touched, if only because people now look at buffers\
that are far, far larger than ever before.\
\
There are two cases:  if the buffer is large and if it is not.\
\
@node Large buffer case, Small buffer case, Disentangle beginning-of-buffer, beginning-of-buffer opt arg\
@comment  node-name,  next,  previous,  up\
@unnumberedsubsubsec What happens in a large buffer\
\
In @code\{beginning-of-buffer\}, the inner @code\{if\} expression tests\
whether the size of the buffer is greater than 10,000 characters.  To do\
this, it uses the @code\{>\} function and the computation of @code\{size\}\
that comes from the let expression.\
\
In the old days, the function @code\{buffer-size\} was used.  Not only\
was that function called several times, it gave the size of the whole\
buffer, not the accessible part.  The computation makes much more\
sense when it handles just the accessible part.  (@xref\{Narrowing &\
Widening, , Narrowing and Widening\}, for more information on focusing\
attention to an `accessible' part.)\
\
@need 800\
The line looks like this:\
\
@smallexample\
(if (> size 10000)\
@end smallexample\
\
@need 1200\
@noindent\
When the buffer is large, the then-part of the @code\{if\} expression is\
evaluated.  It reads like this (after formatting for easy reading):\
\
@smallexample\
@group\
(*\
  (prefix-numeric-value arg)\
  (/ size 10))\
@end group\
@end smallexample\
\
@noindent\
This expression is a multiplication, with two arguments to the function\
@code\{*\}.\
\
The first argument is @code\{(prefix-numeric-value arg)\}.  When\
@code\{"P"\} is used as the argument for @code\{interactive\}, the value\
passed to the function as its argument is passed a ``raw prefix\
argument'', and not a number.  (It is a number in a list.)  To perform\
the arithmetic, a conversion is necessary, and\
@code\{prefix-numeric-value\} does the job.\
\
@findex / @r\{(division)\}\
@cindex Division\
The second argument is @code\{(/ size 10)\}.  This expression divides\
the numeric value by ten --- the numeric value of the size of the\
accessible portion of the buffer.  This produces a number that tells\
how many characters make up one tenth of the buffer size.  (In Lisp,\
@code\{/\} is used for division, just as @code\{*\} is used for\
multiplication.)\
\
@need 1200\
In the multiplication expression as a whole, this amount is multiplied\
by the value of the prefix argument---the multiplication looks like this:\
\
@smallexample\
@group\
(* @var\{numeric-value-of-prefix-arg\}\
   @var\{number-of-characters-in-one-tenth-of-the-accessible-buffer\})\
@end group\
@end smallexample\
\
@noindent\
If, for example, the prefix argument is @samp\{7\}, the one-tenth value\
will be multiplied by 7 to give a position 70% of the way through.\
\
@need 1200\
The result of all this is that if the accessible portion of the buffer\
is large, the @code\{goto-char\} expression reads like this:\
\
@smallexample\
@group\
(goto-char (* (prefix-numeric-value arg)\
              (/ size 10)))\
@end group\
@end smallexample\
\
This puts the cursor where we want it.\
\
@node Small buffer case,  , Large buffer case, beginning-of-buffer opt arg\
@comment  node-name,  next,  previous,  up\
@unnumberedsubsubsec What happens in a small buffer\
\
If the buffer contains fewer than 10,000 characters, a slightly\
different computation is performed.  You might think this is not\
necessary, since the first computation could do the job.  However, in\
a small buffer, the first method may not put the cursor on exactly the\
desired line; the second method does a better job.\
\
@need 800\
The code looks like this:\
\
@c Keep this on one line.\
@smallexample\
(/ (+ 10 (* size (prefix-numeric-value arg))) 10))\
@end smallexample\
\
@need 1200\
@noindent\
This is code in which you figure out what happens by discovering how the\
functions are embedded in parentheses.  It is easier to read if you\
reformat it with each expression indented more deeply than its\
enclosing expression:\
\
@smallexample\
@group\
  (/\
   (+ 10\
      (*\
       size\
       (prefix-numeric-value arg)))\
   10))\
@end group\
@end smallexample\
\
@need 1200\
@noindent\
Looking at parentheses, we see that the innermost operation is\
@code\{(prefix-numeric-value arg)\}, which converts the raw argument to\
a number.  In the following expression, this number is multiplied by\
the size of the accessible portion of the buffer:\
\
@smallexample\
(* size (prefix-numeric-value arg))\
@end smallexample\
\
@noindent\
This multiplication creates a number that may be larger than the size of\
the buffer---seven times larger if the argument is 7, for example.  Ten\
is then added to this number and finally the large number is divided by\
ten to provide a value that is one character larger than the percentage\
position in the buffer.\
\
The number that results from all this is passed to @code\{goto-char\} and\
the cursor is moved to that point.\
\
@need 1500\
@node beginning-of-buffer complete,  , beginning-of-buffer opt arg, beginning-of-buffer\
@comment  node-name,  next,  previous,  up\
@subsection The Complete @code\{beginning-of-buffer\}\
\
@need 1000\
Here is the complete text of the @code\{beginning-of-buffer\} function:\
@sp 1\
\
@c In GNU Emacs 22\
@smallexample\
@group\
(defun beginning-of-buffer (&optional arg)\
  "Move point to the beginning of the buffer;\
leave mark at previous position.\
With \\\\[universal-argument] prefix,\
do not set mark at previous position.\
With numeric arg N,\
put point N/10 of the way from the beginning.\
\
If the buffer is narrowed,\
this command uses the beginning and size\
of the accessible part of the buffer.\
@end group\
\
@group\
Don't use this command in Lisp programs!\
\\(goto-char (point-min)) is faster\
and avoids clobbering the mark."\
  (interactive "P")\
  (or (consp arg)\
      (and transient-mark-mode mark-active)\
      (push-mark))\
@end group\
@group\
  (let ((size (- (point-max) (point-min))))\
    (goto-char (if (and arg (not (consp arg)))\
                   (+ (point-min)\
                      (if (> size 10000)\
                          ;; Avoid overflow for large buffer sizes!\
                          (* (prefix-numeric-value arg)\
                             (/ size 10))\
                        (/ (+ 10 (* size (prefix-numeric-value arg)))\
                           10)))\
                 (point-min))))\
  (if arg (forward-line 1)))\
@end group\
@end smallexample\
\
@ignore\
From before GNU Emacs 22\
@smallexample\
@group\
(defun beginning-of-buffer (&optional arg)\
  "Move point to the beginning of the buffer;\
leave mark at previous position.\
With arg N, put point N/10 of the way\
from the true beginning.\
@end group\
@group\
Don't use this in Lisp programs!\
\\(goto-char (point-min)) is faster\
and does not set the mark."\
  (interactive "P")\
  (push-mark)\
@end group\
@group\
  (goto-char\
   (if arg\
       (if (> (buffer-size) 10000)\
           ;; @r\{Avoid overflow for large buffer sizes!\}\
           (* (prefix-numeric-value arg)\
              (/ (buffer-size) 10))\
@end group\
@group\
         (/ (+ 10 (* (buffer-size)\
                     (prefix-numeric-value arg)))\
            10))\
     (point-min)))\
  (if arg (forward-line 1)))\
@end group\
@end smallexample\
@end ignore\
\
@noindent\
Except for two small points, the previous discussion shows how this\
function works.  The first point deals with a detail in the\
documentation string, and the second point concerns the last line of\
the function.\
\
@need 800\
In the documentation string, there is reference to an expression:\
\
@smallexample\
\\\\[universal-argument]\
@end smallexample\
\
@noindent\
A @samp\{\\\\\} is used before the first square bracket of this\
expression.  This @samp\{\\\\\} tells the Lisp interpreter to substitute\
whatever key is currently bound to the @samp\{[@dots\{\}]\}.  In the case\
of @code\{universal-argument\}, that is usually @kbd\{C-u\}, but it might\
be different.  (@xref\{Documentation Tips, , Tips for Documentation\
Strings, elisp, The GNU Emacs Lisp Reference Manual\}, for more\
information.)\
\
@need 1200\
Finally, the last line of the @code\{beginning-of-buffer\} command says\
to move point to the beginning of the next line if the command is\
invoked with an argument:\
\
@smallexample\
(if arg (forward-line 1)))\
@end smallexample\
\
@noindent\
This puts the cursor at the beginning of the first line after the\
appropriate tenths position in the buffer.  This is a flourish that\
means that the cursor is always located @emph\{at least\} the requested\
tenths of the way through the buffer, which is a nicety that is,\
perhaps, not necessary, but which, if it did not occur, would be sure\
to draw complaints.\
\
On the other hand, it also means that if you specify the command with\
a @kbd\{C-u\}, but without a number, that is to say, if the `raw prefix\
argument' is simply a cons cell, then the command puts you at the\
beginning of the second line @dots\{\}  I don't know whether this is\
intended or whether no one has dealt with the code to avoid this\
happening.\
\
@node Second Buffer Related Review, optional Exercise, beginning-of-buffer, More Complex\
@comment  node-name,  next,  previous,  up\
@section Review\
\
Here is a brief summary of some of the topics covered in this chapter.\
\
@table @code\
@item or\
Evaluate each argument in sequence, and return the value of the first\
argument that is not @code\{nil\}; if none return a value that is not\
@code\{nil\}, return @code\{nil\}.  In brief, return the first true value\
of the arguments; return a true value if one @emph\{or\} any of the\
others are true.\
\
@item and\
Evaluate each argument in sequence, and if any are @code\{nil\}, return\
@code\{nil\}; if none are @code\{nil\}, return the value of the last\
argument.  In brief, return a true value only if all the arguments are\
true; return a true value if one @emph\{and\} each of the others is\
true.\
\
@item &optional\
A keyword used to indicate that an argument to a function definition\
is optional; this means that the function can be evaluated without the\
argument, if desired.\
\
@item prefix-numeric-value\
Convert the `raw prefix argument' produced by @code\{(interactive\
"P")\} to a numeric value.\
\
@item forward-line\
Move point forward to the beginning of the next line, or if the argument\
is greater than one, forward that many lines.  If it can't move as far\
forward as it is supposed to, @code\{forward-line\} goes forward as far as\
it can and then returns a count of the number of additional lines it was\
supposed to move but couldn't.\
\
@item erase-buffer\
Delete the entire contents of the current buffer.\
\
@item bufferp\
Return @code\{t\} if its argument is a buffer; otherwise return @code\{nil\}.\
@end table\
\
@node optional Exercise,  , Second Buffer Related Review, More Complex\
@section @code\{optional\} Argument Exercise\
\
Write an interactive function with an optional argument that tests\
whether its argument, a number, is greater than or equal to, or else,\
less than the value of @code\{fill-column\}, and tells you which, in a\
message.  However, if you do not pass an argument to the function, use\
56 as a default value.}