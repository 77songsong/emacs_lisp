{\rtf1\ansi\ansicpg949\cocoartf1187\cocoasubrtf340
{\fonttbl\f0\fnil\fcharset129 AppleSDGothicNeo-Regular;}
{\colortbl;\red255\green255\blue255;}
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\fi360\sl288\slmult1\pardirnatural

\f0\fs28 \cf0 \
@node Words in a defun, Readying a Graph, Counting Words, Top\
@chapter Counting Words in a @code\{defun\}\
@cindex Counting words in a @code\{defun\}\
@cindex Word counting in a @code\{defun\}\
\
Our next project is to count the number of words in a function\
definition.  Clearly, this can be done using some variant of\
@code\{count-word-region\}.  @xref\{Counting Words, , Counting Words:\
Repetition and Regexps\}.  If we are just going to count the words in\
one definition, it is easy enough to mark the definition with the\
@kbd\{C-M-h\} (@code\{mark-defun\}) command, and then call\
@code\{count-word-region\}.\
\
However, I am more ambitious: I want to count the words and symbols in\
every definition in the Emacs sources and then print a graph that\
shows how many functions there are of each length: how many contain 40\
to 49 words or symbols, how many contain 50 to 59 words or symbols,\
and so on.  I have often been curious how long a typical function is,\
and this will tell.\
\
@menu\
* Divide and Conquer::\
* Words and Symbols::           What to count?\
* Syntax::                      What constitutes a word or symbol?\
* count-words-in-defun::        Very like @code\{count-words\}.\
* Several defuns::              Counting several defuns in a file.\
* Find a File::                 Do you want to look at a file?\
* lengths-list-file::           A list of the lengths of many definitions.\
* Several files::               Counting in definitions in different files.\
* Several files recursively::   Recursively counting in different files.\
* Prepare the data::            Prepare the data for display in a graph.\
@end menu\
\
@node Divide and Conquer, Words and Symbols, Words in a defun, Words in a defun\
@ifnottex\
@unnumberedsec Divide and Conquer\
@end ifnottex\
\
Described in one phrase, the histogram project is daunting; but\
divided into numerous small steps, each of which we can take one at a\
time, the project becomes less fearsome.  Let us consider what the\
steps must be:\
\
@itemize @bullet\
@item\
First, write a function to count the words in one definition.  This\
includes the problem of handling symbols as well as words.\
\
@item\
Second, write a function to list the numbers of words in each function\
in a file.  This function can use the @code\{count-words-in-defun\}\
function.\
\
@item\
Third, write a function to list the numbers of words in each function\
in each of several files.  This entails automatically finding the\
various files, switching to them, and counting the words in the\
definitions within them.\
\
@item\
Fourth, write a function to convert the list of numbers that we\
created in step three to a form that will be suitable for printing as\
a graph.\
\
@item\
Fifth, write a function to print the results as a graph.\
@end itemize\
\
This is quite a project!  But if we take each step slowly, it will not\
be difficult.\
\
@node Words and Symbols, Syntax, Divide and Conquer, Words in a defun\
@section What to Count?\
@cindex Words and symbols in defun\
\
When we first start thinking about how to count the words in a\
function definition, the first question is (or ought to be) what are\
we going to count?  When we speak of `words' with respect to a Lisp\
function definition, we are actually speaking, in large part, of\
`symbols'.  For example, the following @code\{multiply-by-seven\}\
function contains the five symbols @code\{defun\},\
@code\{multiply-by-seven\}, @code\{number\}, @code\{*\}, and @code\{7\}.  In\
addition, in the documentation string, it contains the four words\
@samp\{Multiply\}, @samp\{NUMBER\}, @samp\{by\}, and @samp\{seven\}.  The\
symbol @samp\{number\} is repeated, so the definition contains a total\
of ten words and symbols.\
\
@smallexample\
@group\
(defun multiply-by-seven (number)\
  "Multiply NUMBER by seven."\
  (* 7 number))\
@end group\
@end smallexample\
\
@noindent\
However, if we mark the @code\{multiply-by-seven\} definition with\
@kbd\{C-M-h\} (@code\{mark-defun\}), and then call\
@code\{count-words-region\} on it, we will find that\
@code\{count-words-region\} claims the definition has eleven words, not\
ten!  Something is wrong!\
\
The problem is twofold: @code\{count-words-region\} does not count the\
@samp\{*\} as a word, and it counts the single symbol,\
@code\{multiply-by-seven\}, as containing three words.  The hyphens are\
treated as if they were interword spaces rather than intraword\
connectors: @samp\{multiply-by-seven\} is counted as if it were written\
@samp\{multiply by seven\}.\
\
The cause of this confusion is the regular expression search within\
the @code\{count-words-region\} definition that moves point forward word\
by word.  In the canonical version of @code\{count-words-region\}, the\
regexp is:\
\
@smallexample\
"\\\\w+\\\\W*"\
@end smallexample\
\
@noindent\
This regular expression is a pattern defining one or more word\
constituent characters possibly followed by one or more characters\
that are not word constituents.  What is meant by `word constituent\
characters' brings us to the issue of syntax, which is worth a section\
of its own.\
\
@node Syntax, count-words-in-defun, Words and Symbols, Words in a defun\
@section What Constitutes a Word or Symbol?\
@cindex Syntax categories and tables\
\
Emacs treats different characters as belonging to different\
@dfn\{syntax categories\}.  For example, the regular expression,\
@samp\{\\\\w+\}, is a pattern specifying one or more @emph\{word\
constituent\} characters.  Word constituent characters are members of\
one syntax category.  Other syntax categories include the class of\
punctuation characters, such as the period and the comma, and the\
class of whitespace characters, such as the blank space and the tab\
character.  (For more information, see @ref\{Syntax, Syntax, The Syntax\
Table, emacs, The GNU Emacs Manual\}, and @ref\{Syntax Tables, , Syntax\
Tables, elisp, The GNU Emacs Lisp Reference Manual\}.)\
\
Syntax tables specify which characters belong to which categories.\
Usually, a hyphen is not specified as a `word constituent character'.\
Instead, it is specified as being in the `class of characters that are\
part of symbol names but not words.'  This means that the\
@code\{count-words-region\} function treats it in the same way it treats\
an interword white space, which is why @code\{count-words-region\}\
counts @samp\{multiply-by-seven\} as three words.\
\
There are two ways to cause Emacs to count @samp\{multiply-by-seven\} as\
one symbol: modify the syntax table or modify the regular expression.\
\
We could redefine a hyphen as a word constituent character by\
modifying the syntax table that Emacs keeps for each mode.  This\
action would serve our purpose, except that a hyphen is merely the\
most common character within symbols that is not typically a word\
constituent character; there are others, too.\
\
Alternatively, we can redefine the regular expression used in the\
@code\{count-words\} definition so as to include symbols.  This\
procedure has the merit of clarity, but the task is a little tricky.\
\
@need 1200\
The first part is simple enough: the pattern must match ``at least one\
character that is a word or symbol constituent''.  Thus:\
\
@smallexample\
"\\\\(\\\\w\\\\|\\\\s_\\\\)+"\
@end smallexample\
\
@noindent\
The @samp\{\\\\(\} is the first part of the grouping construct that\
includes the @samp\{\\\\w\} and the @samp\{\\\\s_\} as alternatives, separated\
by the @samp\{\\\\|\}.  The @samp\{\\\\w\} matches any word-constituent\
character and the @samp\{\\\\s_\} matches any character that is part of a\
symbol name but not a word-constituent character.  The @samp\{+\}\
following the group indicates that the word or symbol constituent\
characters must be matched at least once.\
\
However, the second part of the regexp is more difficult to design.\
What we want is to follow the first part with ``optionally one or more\
characters that are not constituents of a word or symbol''.  At first,\
I thought I could define this with the following:\
\
@smallexample\
"\\\\(\\\\W\\\\|\\\\S_\\\\)*"\
@end smallexample\
\
@noindent\
The upper case @samp\{W\} and @samp\{S\} match characters that are\
@emph\{not\} word or symbol constituents.  Unfortunately, this\
expression matches any character that is either not a word constituent\
or not a symbol constituent.  This matches any character!\
\
I then noticed that every word or symbol in my test region was\
followed by white space (blank space, tab, or newline).  So I tried\
placing a pattern to match one or more blank spaces after the pattern\
for one or more word or symbol constituents.  This failed, too.  Words\
and symbols are often separated by whitespace, but in actual code\
parentheses may follow symbols and punctuation may follow words.  So\
finally, I designed a pattern in which the word or symbol constituents\
are followed optionally by characters that are not white space and\
then followed optionally by white space.\
\
@need 800\
Here is the full regular expression:\
\
@smallexample\
"\\\\(\\\\w\\\\|\\\\s_\\\\)+[^ \\t\\n]*[ \\t\\n]*"\
@end smallexample\
\
@node count-words-in-defun, Several defuns, Syntax, Words in a defun\
@section The @code\{count-words-in-defun\} Function\
@cindex Counting words in a @code\{defun\}\
\
We have seen that there are several ways to write a\
@code\{count-word-region\} function.  To write a\
@code\{count-words-in-defun\}, we need merely adapt one of these\
versions.\
\
The version that uses a @code\{while\} loop is easy to understand, so I\
am going to adapt that.  Because @code\{count-words-in-defun\} will be\
part of a more complex program, it need not be interactive and it need\
not display a message but just return the count.  These considerations\
simplify the definition a little.\
\
On the other hand, @code\{count-words-in-defun\} will be used within a\
buffer that contains function definitions.  Consequently, it is\
reasonable to ask that the function determine whether it is called\
when point is within a function definition, and if it is, to return\
the count for that definition.  This adds complexity to the\
definition, but saves us from needing to pass arguments to the\
function.\
\
@need 1250\
These considerations lead us to prepare the following template:\
\
@smallexample\
@group\
(defun count-words-in-defun ()\
  "@var\{documentation\}@dots\{\}"\
  (@var\{set up\}@dots\{\}\
     (@var\{while loop\}@dots\{\})\
   @var\{return count\})\
@end group\
@end smallexample\
\
@noindent\
As usual, our job is to fill in the slots.\
\
First, the set up.\
\
We are presuming that this function will be called within a buffer\
containing function definitions.  Point will either be within a\
function definition or not.  For @code\{count-words-in-defun\} to work,\
point must move to the beginning of the definition, a counter must\
start at zero, and the counting loop must stop when point reaches the\
end of the definition.\
\
The @code\{beginning-of-defun\} function searches backwards for an\
opening delimiter such as a @samp\{(\} at the beginning of a line, and\
moves point to that position, or else to the limit of the search.  In\
practice, this means that @code\{beginning-of-defun\} moves point to the\
beginning of an enclosing or preceding function definition, or else to\
the beginning of the buffer.  We can use @code\{beginning-of-defun\} to\
place point where we wish to start.\
\
The @code\{while\} loop requires a counter to keep track of the words or\
symbols being counted.  A @code\{let\} expression can be used to create\
a local variable for this purpose, and bind it to an initial value of zero.\
\
The @code\{end-of-defun\} function works like @code\{beginning-of-defun\}\
except that it moves point to the end of the definition.\
@code\{end-of-defun\} can be used as part of an expression that\
determines the position of the end of the definition.\
\
The set up for @code\{count-words-in-defun\} takes shape rapidly: first\
we move point to the beginning of the definition, then we create a\
local variable to hold the count, and finally, we record the position\
of the end of the definition so the @code\{while\} loop will know when to stop\
looping.\
\
@need 1250\
The code looks like this:\
\
@smallexample\
@group\
(beginning-of-defun)\
(let ((count 0)\
      (end (save-excursion (end-of-defun) (point))))\
@end group\
@end smallexample\
\
@noindent\
The code is simple.  The only slight complication is likely to concern\
@code\{end\}: it is bound to the position of the end of the definition\
by a @code\{save-excursion\} expression that returns the value of point\
after @code\{end-of-defun\} temporarily moves it to the end of the\
definition.\
\
The second part of the @code\{count-words-in-defun\}, after the set up,\
is the @code\{while\} loop.\
\
The loop must contain an expression that jumps point forward word by\
word and symbol by symbol, and another expression that counts the\
jumps.  The true-or-false-test for the @code\{while\} loop should test\
true so long as point should jump forward, and false when point is at\
the end of the definition.  We have already redefined the regular\
expression for this (@pxref\{Syntax\}), so the loop is straightforward:\
\
@smallexample\
@group\
(while (and (< (point) end)\
            (re-search-forward\
             "\\\\(\\\\w\\\\|\\\\s_\\\\)+[^ \\t\\n]*[ \\t\\n]*" end t)\
  (setq count (1+ count)))\
@end group\
@end smallexample\
\
The third part of the function definition returns the count of words\
and symbols.  This part is the last expression within the body of the\
@code\{let\} expression, and can be, very simply, the local variable\
@code\{count\}, which when evaluated returns the count.\
\
@need 1250\
Put together, the @code\{count-words-in-defun\} definition looks like this:\
\
@findex count-words-in-defun\
@smallexample\
@group\
(defun count-words-in-defun ()\
  "Return the number of words and symbols in a defun."\
  (beginning-of-defun)\
  (let ((count 0)\
        (end (save-excursion (end-of-defun) (point))))\
@end group\
@group\
    (while\
        (and (< (point) end)\
             (re-search-forward\
              "\\\\(\\\\w\\\\|\\\\s_\\\\)+[^ \\t\\n]*[ \\t\\n]*"\
              end t))\
      (setq count (1+ count)))\
    count))\
@end group\
@end smallexample\
\
How to test this?  The function is not interactive, but it is easy to\
put a wrapper around the function to make it interactive; we can use\
almost the same code as for the recursive version of\
@code\{count-words-region\}:\
\
@smallexample\
@group\
;;; @r\{Interactive version.\}\
(defun count-words-defun ()\
  "Number of words and symbols in a function definition."\
  (interactive)\
  (message\
   "Counting words and symbols in function definition ... ")\
@end group\
@group\
  (let ((count (count-words-in-defun)))\
    (cond\
     ((zerop count)\
      (message\
       "The definition does NOT have any words or symbols."))\
@end group\
@group\
     ((= 1 count)\
      (message\
       "The definition has 1 word or symbol."))\
     (t\
      (message\
       "The definition has %d words or symbols." count)))))\
@end group\
@end smallexample\
\
@need 800\
@noindent\
Let's re-use @kbd\{C-c =\} as a convenient keybinding:\
\
@smallexample\
(global-set-key "\\C-c=" 'count-words-defun)\
@end smallexample\
\
Now we can try out @code\{count-words-defun\}: install both\
@code\{count-words-in-defun\} and @code\{count-words-defun\}, and set the\
keybinding, and then place the cursor within the following definition:\
\
@smallexample\
@group\
(defun multiply-by-seven (number)\
  "Multiply NUMBER by seven."\
  (* 7 number))\
     @result\{\} 10\
@end group\
@end smallexample\
\
@noindent\
Success!  The definition has 10 words and symbols.\
\
The next problem is to count the numbers of words and symbols in\
several definitions within a single file.\
\
@node Several defuns, Find a File, count-words-in-defun, Words in a defun\
@section Count Several @code\{defuns\} Within a File\
\
A file such as @file\{simple.el\} may have a hundred or more function\
definitions within it.  Our long term goal is to collect statistics on\
many files, but as a first step, our immediate goal is to collect\
statistics on one file.\
\
The information will be a series of numbers, each number being the\
length of a function definition.  We can store the numbers in a list.\
\
We know that we will want to incorporate the information regarding one\
file with information about many other files; this means that the\
function for counting definition lengths within one file need only\
return the list of lengths.  It need not and should not display any\
messages.\
\
The word count commands contain one expression to jump point forward\
word by word and another expression to count the jumps.  The function\
to return the lengths of definitions can be designed to work the same\
way, with one expression to jump point forward definition by\
definition and another expression to construct the lengths' list.\
\
This statement of the problem makes it elementary to write the\
function definition.  Clearly, we will start the count at the\
beginning of the file, so the first command will be @code\{(goto-char\
(point-min))\}.  Next, we start the @code\{while\} loop; and the\
true-or-false test of the loop can be a regular expression search for\
the next function definition---so long as the search succeeds, point\
is moved forward and then the body of the loop is evaluated.  The body\
needs an expression that constructs the lengths' list.  @code\{cons\},\
the list construction command, can be used to create the list.  That\
is almost all there is to it.\
\
@need 800\
Here is what this fragment of code looks like:\
\
@smallexample\
@group\
(goto-char (point-min))\
(while (re-search-forward "^(defun" nil t)\
  (setq lengths-list\
        (cons (count-words-in-defun) lengths-list)))\
@end group\
@end smallexample\
\
What we have left out is the mechanism for finding the file that\
contains the function definitions.\
\
In previous examples, we either used this, the Info file, or we\
switched back and forth to some other buffer, such as the\
@file\{*scratch*\} buffer.\
\
Finding a file is a new process that we have not yet discussed.\
\
@node Find a File, lengths-list-file, Several defuns, Words in a defun\
@comment  node-name,  next,  previous,  up\
@section Find a File\
@cindex Find a File\
\
To find a file in Emacs, you use the @kbd\{C-x C-f\} (@code\{find-file\})\
command.  This command is almost, but not quite right for the lengths\
problem.\
\
@need 1200\
Let's look at the source for @code\{find-file\}:\
\
@smallexample\
@group\
(defun find-file (filename)\
  "Edit file FILENAME.\
Switch to a buffer visiting file FILENAME,\
creating one if none already exists."\
  (interactive "FFind file: ")\
  (switch-to-buffer (find-file-noselect filename)))\
@end group\
@end smallexample\
\
@noindent\
(The most recent version of the @code\{find-file\} function definition\
permits you to specify optional wildcards to visit multiple files; that\
makes the definition more complex and we will not discuss it here,\
since it is not relevant.  You can see its source using either\
@kbd\{M-.\} (@code\{find-tag\}) or @kbd\{C-h f\} (@code\{describe-function\}).)\
\
@ignore\
In Emacs 22\
(defun find-file (filename &optional wildcards)\
  "Edit file FILENAME.\
Switch to a buffer visiting file FILENAME,\
creating one if none already exists.\
Interactively, the default if you just type RET is the current directory,\
but the visited file name is available through the minibuffer history:\
type M-n to pull it into the minibuffer.\
\
Interactively, or if WILDCARDS is non-nil in a call from Lisp,\
expand wildcards (if any) and visit multiple files.  You can\
suppress wildcard expansion by setting `find-file-wildcards' to nil.\
\
To visit a file without any kind of conversion and without\
automatically choosing a major mode, use \\\\[find-file-literally]."\
  (interactive (find-file-read-args "Find file: " nil))\
  (let ((value (find-file-noselect filename nil nil wildcards)))\
    (if (listp value)\
        (mapcar 'switch-to-buffer (nreverse value))\
      (switch-to-buffer value))))\
@end ignore\
\
The definition I am showing possesses short but complete documentation\
and an interactive specification that prompts you for a file name when\
you use the command interactively.  The body of the definition\
contains two functions, @code\{find-file-noselect\} and\
@code\{switch-to-buffer\}.\
\
According to its documentation as shown by @kbd\{C-h f\} (the\
@code\{describe-function\} command), the @code\{find-file-noselect\}\
function reads the named file into a buffer and returns the buffer.\
(Its most recent version includes an optional wildcards argument,\
too, as well as another to read a file literally and an other you\
suppress warning messages.  These optional arguments are irrelevant.)\
\
However, the @code\{find-file-noselect\} function does not select the\
buffer in which it puts the file.  Emacs does not switch its attention\
(or yours if you are using @code\{find-file-noselect\}) to the selected\
buffer.  That is what @code\{switch-to-buffer\} does: it switches the\
buffer to which Emacs attention is directed; and it switches the\
buffer displayed in the window to the new buffer.  We have discussed\
buffer switching elsewhere.  (@xref\{Switching Buffers\}.)\
\
In this histogram project, we do not need to display each file on the\
screen as the program determines the length of each definition within\
it.  Instead of employing @code\{switch-to-buffer\}, we can work with\
@code\{set-buffer\}, which redirects the attention of the computer\
program to a different buffer but does not redisplay it on the screen.\
So instead of calling on @code\{find-file\} to do the job, we must write\
our own expression.\
\
The task is easy: use @code\{find-file-noselect\} and @code\{set-buffer\}.\
\
@node lengths-list-file, Several files, Find a File, Words in a defun\
@section @code\{lengths-list-file\} in Detail\
\
The core of the @code\{lengths-list-file\} function is a @code\{while\}\
loop containing a function to move point forward `defun by defun' and\
a function to count the number of words and symbols in each defun.\
This core must be surrounded by functions that do various other tasks,\
including finding the file, and ensuring that point starts out at the\
beginning of the file.  The function definition looks like this:\
@findex lengths-list-file\
\
@smallexample\
@group\
(defun lengths-list-file (filename)\
  "Return list of definitions' lengths within FILE.\
The returned list is a list of numbers.\
Each number is the number of words or\
symbols in one function definition."\
@end group\
@group\
  (message "Working on `%s' ... " filename)\
  (save-excursion\
    (let ((buffer (find-file-noselect filename))\
          (lengths-list))\
      (set-buffer buffer)\
      (setq buffer-read-only t)\
      (widen)\
      (goto-char (point-min))\
      (while (re-search-forward "^(defun" nil t)\
        (setq lengths-list\
              (cons (count-words-in-defun) lengths-list)))\
      (kill-buffer buffer)\
      lengths-list)))\
@end group\
@end smallexample\
\
@noindent\
The function is passed one argument, the name of the file on which it\
will work.  It has four lines of documentation, but no interactive\
specification.  Since people worry that a computer is broken if they\
don't see anything going on, the first line of the body is a\
message.\
\
The next line contains a @code\{save-excursion\} that returns Emacs'\
attention to the current buffer when the function completes.  This is\
useful in case you embed this function in another function that\
presumes point is restored to the original buffer.\
\
In the varlist of the @code\{let\} expression, Emacs finds the file and\
binds the local variable @code\{buffer\} to the buffer containing the\
file.  At the same time, Emacs creates @code\{lengths-list\} as a local\
variable.\
\
Next, Emacs switches its attention to the buffer.\
\
In the following line, Emacs makes the buffer read-only.  Ideally,\
this line is not necessary.  None of the functions for counting words\
and symbols in a function definition should change the buffer.\
Besides, the buffer is not going to be saved, even if it were changed.\
This line is entirely the consequence of great, perhaps excessive,\
caution.  The reason for the caution is that this function and those\
it calls work on the sources for Emacs and it is inconvenient if they\
are inadvertently modified.  It goes without saying that I did not\
realize a need for this line until an experiment went awry and started\
to modify my Emacs source files @dots\{\}\
\
Next comes a call to widen the buffer if it is narrowed.  This\
function is usually not needed---Emacs creates a fresh buffer if none\
already exists; but if a buffer visiting the file already exists Emacs\
returns that one.  In this case, the buffer may be narrowed and must\
be widened.  If we wanted to be fully `user-friendly', we would\
arrange to save the restriction and the location of point, but we\
won't.\
\
The @code\{(goto-char (point-min))\} expression moves point to the\
beginning of the buffer.\
\
Then comes a @code\{while\} loop in which the `work' of the function is\
carried out.  In the loop, Emacs determines the length of each\
definition and constructs a lengths' list containing the information.\
\
Emacs kills the buffer after working through it.  This is to save\
space inside of Emacs.  My version of GNU Emacs 19 contained over 300\
source files of interest; GNU Emacs 22 contains over a thousand source\
files.  Another function will apply @code\{lengths-list-file\} to each\
of the files.\
\
Finally, the last expression within the @code\{let\} expression is the\
@code\{lengths-list\} variable; its value is returned as the value of\
the whole function.\
\
You can try this function by installing it in the usual fashion.  Then\
place your cursor after the following expression and type @kbd\{C-x\
C-e\} (@code\{eval-last-sexp\}).\
\
@c !!! 22.1.1 lisp sources location here\
@smallexample\
(lengths-list-file\
 "/usr/local/share/emacs/22.1.1/lisp/emacs-lisp/debug.el")\
@end smallexample\
\
@noindent\
(You may need to change the pathname of the file; the one here is for\
GNU Emacs version 22.1.1.  To change the expression, copy it to\
the @file\{*scratch*\} buffer and edit it.\
\
@need 1200\
@noindent\
(Also, to see the full length of the list, rather than a truncated\
version, you may have to evaluate the following:\
\
@smallexample\
(custom-set-variables '(eval-expression-print-length nil))\
@end smallexample\
\
@noindent\
(@xref\{defcustom, , Specifying Variables using @code\{defcustom\}\}.\
Then evaluate the @code\{lengths-list-file\} expression.)\
\
@need 1200\
The lengths' list for @file\{debug.el\} takes less than a second to\
produce and looks like this in GNU Emacs 22:\
\
@smallexample\
(83 113 105 144 289 22 30 97 48 89 25 52 52 88 28 29 77 49 43 290 232 587)\
@end smallexample\
\
@need 1500\
(Using my old machine, the version 19 lengths' list for @file\{debug.el\}\
took seven seconds to produce and looked like this:\
\
@smallexample\
(75 41 80 62 20 45 44 68 45 12 34 235)\
@end smallexample\
\
(The newer version of @file\{debug.el\} contains more defuns than the\
earlier one; and my new machine is much faster than the old one.)\
\
Note that the length of the last definition in the file is first in\
the list.\
\
@node Several files, Several files recursively, lengths-list-file, Words in a defun\
@section Count Words in @code\{defuns\} in Different Files\
\
In the previous section, we created a function that returns a list of\
the lengths of each definition in a file.  Now, we want to define a\
function to return a master list of the lengths of the definitions in\
a list of files.\
\
Working on each of a list of files is a repetitious act, so we can use\
either a @code\{while\} loop or recursion.\
\
@menu\
* lengths-list-many-files::     Return a list of the lengths of defuns.\
* append::                      Attach one list to another.\
@end menu\
\
@node lengths-list-many-files, append, Several files, Several files\
@ifnottex\
@unnumberedsubsec Determine the lengths of @code\{defuns\}\
@end ifnottex\
\
The design using a @code\{while\} loop is routine.  The argument passed\
the function is a list of files.  As we saw earlier (@pxref\{Loop\
Example\}), you can write a @code\{while\} loop so that the body of the\
loop is evaluated if such a list contains elements, but to exit the\
loop if the list is empty.  For this design to work, the body of the\
loop must contain an expression that shortens the list each time the\
body is evaluated, so that eventually the list is empty.  The usual\
technique is to set the value of the list to the value of the @sc\{cdr\}\
of the list each time the body is evaluated.\
\
@need 800\
The template looks like this:\
\
@smallexample\
@group\
(while @var\{test-whether-list-is-empty\}\
  @var\{body\}@dots\{\}\
  @var\{set-list-to-cdr-of-list\})\
@end group\
@end smallexample\
\
Also, we remember that a @code\{while\} loop returns @code\{nil\} (the\
result of evaluating the true-or-false-test), not the result of any\
evaluation within its body.  (The evaluations within the body of the\
loop are done for their side effects.)  However, the expression that\
sets the lengths' list is part of the body---and that is the value\
that we want returned by the function as a whole.  To do this, we\
enclose the @code\{while\} loop within a @code\{let\} expression, and\
arrange that the last element of the @code\{let\} expression contains\
the value of the lengths' list.  (@xref\{Incrementing Example, , Loop\
Example with an Incrementing Counter\}.)\
\
@findex lengths-list-many-files\
@need 1250\
These considerations lead us directly to the function itself:\
\
@smallexample\
@group\
;;; @r\{Use @code\{while\} loop.\}\
(defun lengths-list-many-files (list-of-files)\
  "Return list of lengths of defuns in LIST-OF-FILES."\
@end group\
@group\
  (let (lengths-list)\
\
;;; @r\{true-or-false-test\}\
    (while list-of-files\
      (setq lengths-list\
            (append\
             lengths-list\
\
;;; @r\{Generate a lengths' list.\}\
             (lengths-list-file\
              (expand-file-name (car list-of-files)))))\
@end group\
\
@group\
;;; @r\{Make files' list shorter.\}\
      (setq list-of-files (cdr list-of-files)))\
\
;;; @r\{Return final value of lengths' list.\}\
    lengths-list))\
@end group\
@end smallexample\
\
@code\{expand-file-name\} is a built-in function that converts a file\
name to the absolute, long, path name form.  The function employs the\
name of the directory in which the function is called.\
\
@c !!! 22.1.1 lisp sources location here\
@need 1500\
Thus, if @code\{expand-file-name\} is called on @code\{debug.el\} when\
Emacs is visiting the\
@file\{/usr/local/share/emacs/22.1.1/lisp/emacs-lisp/\} directory,\
\
@smallexample\
debug.el\
@end smallexample\
\
@need 800\
@noindent\
becomes\
\
@c !!! 22.1.1 lisp sources location here\
@smallexample\
/usr/local/share/emacs/22.1.1/lisp/emacs-lisp/debug.el\
@end smallexample\
\
The only other new element of this function definition is the as yet\
unstudied function @code\{append\}, which merits a short section for\
itself.\
\
@node append,  , lengths-list-many-files, Several files\
@subsection The @code\{append\} Function\
\
@need 800\
The @code\{append\} function attaches one list to another.  Thus,\
\
@smallexample\
(append '(1 2 3 4) '(5 6 7 8))\
@end smallexample\
\
@need 800\
@noindent\
produces the list\
\
@smallexample\
(1 2 3 4 5 6 7 8)\
@end smallexample\
\
This is exactly how we want to attach two lengths' lists produced by\
@code\{lengths-list-file\} to each other.  The results contrast with\
@code\{cons\},\
\
@smallexample\
(cons '(1 2 3 4) '(5 6 7 8))\
@end smallexample\
\
@need 1250\
@noindent\
which constructs a new list in which the first argument to @code\{cons\}\
becomes the first element of the new list:\
\
@smallexample\
((1 2 3 4) 5 6 7 8)\
@end smallexample\
\
@node Several files recursively, Prepare the data, Several files, Words in a defun\
@section Recursively Count Words in Different Files\
\
Besides a @code\{while\} loop, you can work on each of a list of files\
with recursion.  A recursive version of @code\{lengths-list-many-files\}\
is short and simple.\
\
The recursive function has the usual parts: the `do-again-test', the\
`next-step-expression', and the recursive call.  The `do-again-test'\
determines whether the function should call itself again, which it\
will do if the @code\{list-of-files\} contains any remaining elements;\
the `next-step-expression' resets the @code\{list-of-files\} to the\
@sc\{cdr\} of itself, so eventually the list will be empty; and the\
recursive call calls itself on the shorter list.  The complete\
function is shorter than this description!\
@findex recursive-lengths-list-many-files\
\
@smallexample\
@group\
(defun recursive-lengths-list-many-files (list-of-files)\
  "Return list of lengths of each defun in LIST-OF-FILES."\
  (if list-of-files                     ; @r\{do-again-test\}\
      (append\
       (lengths-list-file\
        (expand-file-name (car list-of-files)))\
       (recursive-lengths-list-many-files\
        (cdr list-of-files)))))\
@end group\
@end smallexample\
\
@noindent\
In a sentence, the function returns the lengths' list for the first of\
the @code\{list-of-files\} appended to the result of calling itself on\
the rest of the @code\{list-of-files\}.\
\
Here is a test of @code\{recursive-lengths-list-many-files\}, along with\
the results of running @code\{lengths-list-file\} on each of the files\
individually.\
\
Install @code\{recursive-lengths-list-many-files\} and\
@code\{lengths-list-file\}, if necessary, and then evaluate the\
following expressions.  You may need to change the files' pathnames;\
those here work when this Info file and the Emacs sources are located\
in their customary places.  To change the expressions, copy them to\
the @file\{*scratch*\} buffer, edit them, and then evaluate them.\
\
The results are shown after the @samp\{@result\{\}\}.  (These results are\
for files from Emacs version 22.1.1; files from other versions of\
Emacs may produce different results.)\
\
@c !!! 22.1.1 lisp sources location here\
@smallexample\
@group\
(cd "/usr/local/share/emacs/22.1.1/")\
\
(lengths-list-file "./lisp/macros.el")\
     @result\{\} (283 263 480 90)\
@end group\
\
@group\
(lengths-list-file "./lisp/mail/mailalias.el")\
     @result\{\} (38 32 29 95 178 180 321 218 324)\
@end group\
\
@group\
(lengths-list-file "./lisp/makesum.el")\
     @result\{\} (85 181)\
@end group\
\
@group\
  (recursive-lengths-list-many-files\
   '("./lisp/macros.el"\
     "./lisp/mail/mailalias.el"\
     "./lisp/makesum.el"))\
       @result\{\} (283 263 480 90 38 32 29 95 178 180 321 218 324 85 181)\
@end group\
@end smallexample\
\
The @code\{recursive-lengths-list-many-files\} function produces the\
output we want.\
\
The next step is to prepare the data in the list for display in a graph.\
\
@node Prepare the data,  , Several files recursively, Words in a defun\
@section Prepare the Data for Display in a Graph\
\
The @code\{recursive-lengths-list-many-files\} function returns a list\
of numbers.  Each number records the length of a function definition.\
What we need to do now is transform this data into a list of numbers\
suitable for generating a graph.  The new list will tell how many\
functions definitions contain less than 10 words and\
symbols, how many contain between 10 and 19 words and symbols, how\
many contain between 20 and 29 words and symbols, and so on.\
\
In brief, we need to go through the lengths' list produced by the\
@code\{recursive-lengths-list-many-files\} function and count the number\
of defuns within each range of lengths, and produce a list of those\
numbers.\
\
@menu\
* Data for Display in Detail::\
* Sorting::                     Sorting lists.\
* Files List::                  Making a list of files.\
* Counting function definitions::\
@end menu\
\
@node Data for Display in Detail, Sorting, Prepare the data, Prepare the data\
@ifnottex\
@unnumberedsubsec The Data for Display in Detail\
@end ifnottex\
\
Based on what we have done before, we can readily foresee that it\
should not be too hard to write a function that `@sc\{cdr\}s' down the\
lengths' list, looks at each element, determines which length range it\
is in, and increments a counter for that range.\
\
However, before beginning to write such a function, we should consider\
the advantages of sorting the lengths' list first, so the numbers are\
ordered from smallest to largest.  First, sorting will make it easier\
to count the numbers in each range, since two adjacent numbers will\
either be in the same length range or in adjacent ranges.  Second, by\
inspecting a sorted list, we can discover the highest and lowest\
number, and thereby determine the largest and smallest length range\
that we will need.\
\
@node Sorting, Files List, Data for Display in Detail, Prepare the data\
@subsection Sorting Lists\
@findex sort\
\
Emacs contains a function to sort lists, called (as you might guess)\
@code\{sort\}.  The @code\{sort\} function takes two arguments, the list\
to be sorted, and a predicate that determines whether the first of\
two list elements is ``less'' than the second.\
\
As we saw earlier (@pxref\{Wrong Type of Argument, , Using the Wrong\
Type Object as an Argument\}), a predicate is a function that\
determines whether some property is true or false.  The @code\{sort\}\
function will reorder a list according to whatever property the\
predicate uses; this means that @code\{sort\} can be used to sort\
non-numeric lists by non-numeric criteria---it can, for example,\
alphabetize a list.\
\
@need 1250\
The @code\{<\} function is used when sorting a numeric list.  For example,\
\
@smallexample\
(sort '(4 8 21 17 33 7 21 7) '<)\
@end smallexample\
\
@need 800\
@noindent\
produces this:\
\
@smallexample\
(4 7 7 8 17 21 21 33)\
@end smallexample\
\
@noindent\
(Note that in this example, both the arguments are quoted so that the\
symbols are not evaluated before being passed to @code\{sort\} as\
arguments.)\
\
Sorting the list returned by the\
@code\{recursive-lengths-list-many-files\} function is straightforward;\
it uses the @code\{<\} function:\
\
@ignore\
2006 Oct 29\
In GNU Emacs 22,  eval\
(progn\
  (cd "/usr/local/share/emacs/22.0.50/")\
  (sort\
   (recursive-lengths-list-many-files\
    '("./lisp/macros.el"\
      "./lisp/mail/mailalias.el"\
      "./lisp/makesum.el"))\
   '<))\
\
@end ignore\
\
@smallexample\
@group\
(sort\
 (recursive-lengths-list-many-files\
  '("./lisp/macros.el"\
    "./lisp/mailalias.el"\
    "./lisp/makesum.el"))\
 '<)\
@end group\
@end smallexample\
\
@need 800\
@noindent\
which produces:\
\
@smallexample\
(29 32 38 85 90 95 178 180 181 218 263 283 321 324 480)\
@end smallexample\
\
@noindent\
(Note that in this example, the first argument to @code\{sort\} is not\
quoted, since the expression must be evaluated so as to produce the\
list that is passed to @code\{sort\}.)\
\
@node Files List, Counting function definitions, Sorting, Prepare the data\
@subsection Making a List of Files\
\
The @code\{recursive-lengths-list-many-files\} function requires a list\
of files as its argument.  For our test examples, we constructed such\
a list by hand; but the Emacs Lisp source directory is too large for\
us to do for that.  Instead, we will write a function to do the job\
for us.  In this function, we will use both a @code\{while\} loop and a\
recursive call.\
\
@findex directory-files\
We did not have to write a function like this for older versions of\
GNU Emacs, since they placed all the @samp\{.el\} files in one\
directory.  Instead, we were able to use the @code\{directory-files\}\
function, which lists the names of files that match a specified\
pattern within a single directory.\
\
However, recent versions of Emacs place Emacs Lisp files in\
sub-directories of the top level @file\{lisp\} directory.  This\
re-arrangement eases navigation.  For example, all the mail related\
files are in a @file\{lisp\} sub-directory called @file\{mail\}.  But at\
the same time, this arrangement forces us to create a file listing\
function that descends into the sub-directories.\
\
@findex files-in-below-directory\
We can create this function, called @code\{files-in-below-directory\},\
using familiar functions such as @code\{car\}, @code\{nthcdr\}, and\
@code\{substring\} in conjunction with an existing function called\
@code\{directory-files-and-attributes\}.  This latter function not only\
lists all the filenames in a directory, including the names\
of sub-directories, but also their attributes.\
\
To restate our goal: to create a function that will enable us\
to feed filenames to @code\{recursive-lengths-list-many-files\}\
as a list that looks like this (but with more elements):\
\
@smallexample\
@group\
("./lisp/macros.el"\
 "./lisp/mail/rmail.el"\
 "./lisp/makesum.el")\
@end group\
@end smallexample\
\
The @code\{directory-files-and-attributes\} function returns a list of\
lists.  Each of the lists within the main list consists of 13\
elements.  The first element is a string that contains the name of the\
file -- which, in GNU/Linux, may be a `directory file', that is to\
say, a file with the special attributes of a directory.  The second\
element of the list is @code\{t\} for a directory, a string\
for symbolic link (the string is the name linked to), or @code\{nil\}.\
\
For example, the first @samp\{.el\} file in the @file\{lisp/\} directory\
is @file\{abbrev.el\}.  Its name is\
@file\{/usr/local/share/emacs/22.1.1/lisp/abbrev.el\} and it is not a\
directory or a symbolic link.\
\
@need 1000\
This is how @code\{directory-files-and-attributes\} lists that file and\
its attributes:\
\
@smallexample\
@group\
("abbrev.el"\
nil\
1\
1000\
100\
@end group\
@group\
(17733 259)\
(17491 28834)\
(17596 62124)\
13157\
"-rw-rw-r--"\
@end group\
@group\
nil\
2971624\
773)\
@end group\
@end smallexample\
\
@need 1200\
On the other hand, @file\{mail/\} is a directory within the @file\{lisp/\}\
directory.  The beginning of its listing looks like this:\
\
@smallexample\
@group\
("mail"\
t\
@dots\{\}\
)\
@end group\
@end smallexample\
\
(To learn about the different attributes, look at the documentation of\
@code\{file-attributes\}.  Bear in mind that the @code\{file-attributes\}\
function does not list the filename, so its first element is\
@code\{directory-files-and-attributes\}'s second element.)\
\
We will want our new function, @code\{files-in-below-directory\}, to\
list the @samp\{.el\} files in the directory it is told to check, and in\
any directories below that directory.\
\
This gives us a hint on how to construct\
@code\{files-in-below-directory\}:  within a directory, the function\
should add @samp\{.el\} filenames to a list; and if, within a directory,\
the function comes upon a sub-directory, it should go into that\
sub-directory and repeat its actions.\
\
However, we should note that every directory contains a name that\
refers to itself, called @file\{.\}, (``dot'') and a name that refers to\
its parent directory, called @file\{..\} (``double dot'').  (In\
@file\{/\}, the root directory, @file\{..\} refers to itself, since\
@file\{/\} has no parent.)  Clearly, we do not want our\
@code\{files-in-below-directory\} function to enter those directories,\
since they always lead us, directly or indirectly, to the current\
directory.\
\
Consequently, our @code\{files-in-below-directory\} function must do\
several tasks:\
\
@itemize @bullet\
@item\
Check to see whether it is looking at a filename that ends in\
@samp\{.el\}; and if so, add its name to a list.\
\
@item\
Check to see whether it is looking at a filename that is the name of a\
directory; and if so,\
\
@itemize @minus\
@item\
Check to see whether it is looking at @file\{.\}  or @file\{..\}; and if\
so skip it.\
\
@item\
Or else, go into that directory and repeat the process.\
@end itemize\
@end itemize\
\
Let's write a function definition to do these tasks.  We will use a\
@code\{while\} loop to move from one filename to another within a\
directory, checking what needs to be done; and we will use a recursive\
call to repeat the actions on each sub-directory.  The recursive\
pattern is `accumulate'\
(@pxref\{Accumulate, , Recursive Pattern: @emph\{accumulate\}\}),\
using @code\{append\} as the combiner.\
\
@ignore\
(directory-files "/usr/local/src/emacs/lisp/" t "\\\\.el$")\
(shell-command "find /usr/local/src/emacs/lisp/ -name '*.el'")\
\
(directory-files "/usr/local/share/emacs/22.1.1/lisp/" t "\\\\.el$")\
(shell-command "find /usr/local/share/emacs/22.1.1/lisp/ -name '*.el'")\
@end ignore\
\
@c  /usr/local/share/emacs/22.1.1/lisp/\
\
@need 800\
Here is the function:\
\
@smallexample\
@group\
(defun files-in-below-directory (directory)\
  "List the .el files in DIRECTORY and in its sub-directories."\
  ;; Although the function will be used non-interactively,\
  ;; it will be easier to test if we make it interactive.\
  ;; The directory will have a name such as\
  ;;  "/usr/local/share/emacs/22.1.1/lisp/"\
  (interactive "DDirectory name: ")\
@end group\
@group\
  (let (el-files-list\
        (current-directory-list\
         (directory-files-and-attributes directory t)))\
    ;; while we are in the current directory\
    (while current-directory-list\
@end group\
@group\
      (cond\
       ;; check to see whether filename ends in `.el'\
       ;; and if so, append its name to a list.\
       ((equal ".el" (substring (car (car current-directory-list)) -3))\
        (setq el-files-list\
              (cons (car (car current-directory-list)) el-files-list)))\
@end group\
@group\
       ;; check whether filename is that of a directory\
       ((eq t (car (cdr (car current-directory-list))))\
        ;; decide whether to skip or recurse\
        (if\
            (equal "."\
                   (substring (car (car current-directory-list)) -1))\
            ;; then do nothing since filename is that of\
            ;;   current directory or parent, "." or ".."\
            ()\
@end group\
@group\
          ;; else descend into the directory and repeat the process\
          (setq el-files-list\
                (append\
                 (files-in-below-directory\
                  (car (car current-directory-list)))\
                 el-files-list)))))\
      ;; move to the next filename in the list; this also\
      ;; shortens the list so the while loop eventually comes to an end\
      (setq current-directory-list (cdr current-directory-list)))\
    ;; return the filenames\
    el-files-list))\
@end group\
@end smallexample\
\
@c (files-in-below-directory "/usr/local/src/emacs/lisp/")\
@c (files-in-below-directory "/usr/local/share/emacs/22.1.1/lisp/")\
\
The @code\{files-in-below-directory\} @code\{directory-files\} function\
takes one argument, the name of a directory.\
\
@need 1250\
Thus, on my system,\
\
@c (length (files-in-below-directory "/usr/local/src/emacs/lisp/"))\
\
@c !!! 22.1.1 lisp sources location here\
@smallexample\
@group\
(length\
 (files-in-below-directory "/usr/local/share/emacs/22.1.1/lisp/"))\
@end group\
@end smallexample\
\
@noindent\
tells me that in and below my Lisp sources directory are 1031\
@samp\{.el\} files.\
\
@code\{files-in-below-directory\} returns a list in reverse alphabetical\
order.  An expression to sort the list in alphabetical order looks\
like this:\
\
@smallexample\
@group\
(sort\
 (files-in-below-directory "/usr/local/share/emacs/22.1.1/lisp/")\
 'string-lessp)\
@end group\
@end smallexample\
\
@ignore\
(defun test ()\
  "Test how long it takes to find lengths of all sorted elisp defuns."\
  (insert "\\n" (current-time-string) "\\n")\
  (sit-for 0)\
  (sort\
   (recursive-lengths-list-many-files\
    (files-in-below-directory "/usr/local/src/emacs/lisp/"))\
   '<)\
  (insert (format "%s" (current-time-string))))\
@end ignore\
\
@node Counting function definitions,  , Files List, Prepare the data\
@subsection Counting function definitions\
\
Our immediate goal is to generate a list that tells us how many\
function definitions contain fewer than 10 words and symbols, how many\
contain between 10 and 19 words and symbols, how many contain between\
20 and 29 words and symbols, and so on.\
\
With a sorted list of numbers, this is easy: count how many elements\
of the list are smaller than 10, then, after moving past the numbers\
just counted, count how many are smaller than 20, then, after moving\
past the numbers just counted, count how many are smaller than 30, and\
so on.  Each of the numbers, 10, 20, 30, 40, and the like, is one\
larger than the top of that range.  We can call the list of such\
numbers the @code\{top-of-ranges\} list.\
\
@need 1200\
If we wished, we could generate this list automatically, but it is\
simpler to write a list manually.  Here it is:\
@vindex top-of-ranges\
\
@smallexample\
@group\
(defvar top-of-ranges\
 '(10  20  30  40  50\
   60  70  80  90 100\
  110 120 130 140 150\
  160 170 180 190 200\
  210 220 230 240 250\
  260 270 280 290 300)\
 "List specifying ranges for `defuns-per-range'.")\
@end group\
@end smallexample\
\
To change the ranges, we edit this list.\
\
Next, we need to write the function that creates the list of the\
number of definitions within each range.  Clearly, this function must\
take the @code\{sorted-lengths\} and the @code\{top-of-ranges\} lists\
as arguments.\
\
The @code\{defuns-per-range\} function must do two things again and\
again: it must count the number of definitions within a range\
specified by the current top-of-range value; and it must shift to the\
next higher value in the @code\{top-of-ranges\} list after counting the\
number of definitions in the current range.  Since each of these\
actions is repetitive, we can use @code\{while\} loops for the job.\
One loop counts the number of definitions in the range defined by the\
current top-of-range value, and the other loop selects each of the\
top-of-range values in turn.\
\
Several entries of the @code\{sorted-lengths\} list are counted for each\
range; this means that the loop for the @code\{sorted-lengths\} list\
will be inside the loop for the @code\{top-of-ranges\} list, like a\
small gear inside a big gear.\
\
The inner loop counts the number of definitions within the range.  It\
is a simple counting loop of the type we have seen before.\
(@xref\{Incrementing Loop, , A loop with an incrementing counter\}.)\
The true-or-false test of the loop tests whether the value from the\
@code\{sorted-lengths\} list is smaller than the current value of the\
top of the range.  If it is, the function increments the counter and\
tests the next value from the @code\{sorted-lengths\} list.\
\
@need 1250\
The inner loop looks like this:\
\
@smallexample\
@group\
(while @var\{length-element-smaller-than-top-of-range\}\
  (setq number-within-range (1+ number-within-range))\
  (setq sorted-lengths (cdr sorted-lengths)))\
@end group\
@end smallexample\
\
The outer loop must start with the lowest value of the\
@code\{top-of-ranges\} list, and then be set to each of the succeeding\
higher values in turn.  This can be done with a loop like this:\
\
@smallexample\
@group\
(while top-of-ranges\
  @var\{body-of-loop\}@dots\{\}\
  (setq top-of-ranges (cdr top-of-ranges)))\
@end group\
@end smallexample\
\
@need 1200\
Put together, the two loops look like this:\
\
@smallexample\
@group\
(while top-of-ranges\
\
  ;; @r\{Count the number of elements within the current range.\}\
  (while @var\{length-element-smaller-than-top-of-range\}\
    (setq number-within-range (1+ number-within-range))\
    (setq sorted-lengths (cdr sorted-lengths)))\
\
  ;; @r\{Move to next range.\}\
  (setq top-of-ranges (cdr top-of-ranges)))\
@end group\
@end smallexample\
\
In addition, in each circuit of the outer loop, Emacs should record\
the number of definitions within that range (the value of\
@code\{number-within-range\}) in a list.  We can use @code\{cons\} for\
this purpose.  (@xref\{cons, , @code\{cons\}\}.)\
\
The @code\{cons\} function works fine, except that the list it\
constructs will contain the number of definitions for the highest\
range at its beginning and the number of definitions for the lowest\
range at its end.  This is because @code\{cons\} attaches new elements\
of the list to the beginning of the list, and since the two loops are\
working their way through the lengths' list from the lower end first,\
the @code\{defuns-per-range-list\} will end up largest number first.\
But we will want to print our graph with smallest values first and the\
larger later.  The solution is to reverse the order of the\
@code\{defuns-per-range-list\}.  We can do this using the\
@code\{nreverse\} function, which reverses the order of a list.\
@findex nreverse\
\
@need 800\
For example,\
\
@smallexample\
(nreverse '(1 2 3 4))\
@end smallexample\
\
@need 800\
@noindent\
produces:\
\
@smallexample\
(4 3 2 1)\
@end smallexample\
\
Note that the @code\{nreverse\} function is ``destructive''---that is,\
it changes the list to which it is applied; this contrasts with the\
@code\{car\} and @code\{cdr\} functions, which are non-destructive.  In\
this case, we do not want the original @code\{defuns-per-range-list\},\
so it does not matter that it is destroyed.  (The @code\{reverse\}\
function provides a reversed copy of a list, leaving the original list\
as is.)\
@findex reverse\
\
@need 1250\
Put all together, the @code\{defuns-per-range\} looks like this:\
\
@smallexample\
@group\
(defun defuns-per-range (sorted-lengths top-of-ranges)\
  "SORTED-LENGTHS defuns in each TOP-OF-RANGES range."\
  (let ((top-of-range (car top-of-ranges))\
        (number-within-range 0)\
        defuns-per-range-list)\
@end group\
\
@group\
    ;; @r\{Outer loop.\}\
    (while top-of-ranges\
@end group\
\
@group\
      ;; @r\{Inner loop.\}\
      (while (and\
              ;; @r\{Need number for numeric test.\}\
              (car sorted-lengths)\
              (< (car sorted-lengths) top-of-range))\
@end group\
\
@group\
        ;; @r\{Count number of definitions within current range.\}\
        (setq number-within-range (1+ number-within-range))\
        (setq sorted-lengths (cdr sorted-lengths)))\
\
      ;; @r\{Exit inner loop but remain within outer loop.\}\
@end group\
\
@group\
      (setq defuns-per-range-list\
            (cons number-within-range defuns-per-range-list))\
      (setq number-within-range 0)      ; @r\{Reset count to zero.\}\
@end group\
\
@group\
      ;; @r\{Move to next range.\}\
      (setq top-of-ranges (cdr top-of-ranges))\
      ;; @r\{Specify next top of range value.\}\
      (setq top-of-range (car top-of-ranges)))\
@end group\
\
@group\
    ;; @r\{Exit outer loop and count the number of defuns larger than\}\
    ;; @r\{  the largest top-of-range value.\}\
    (setq defuns-per-range-list\
          (cons\
           (length sorted-lengths)\
           defuns-per-range-list))\
@end group\
\
@group\
    ;; @r\{Return a list of the number of definitions within each range,\}\
    ;; @r\{  smallest to largest.\}\
    (nreverse defuns-per-range-list)))\
@end group\
@end smallexample\
\
@need 1200\
@noindent\
The function is straightforward except for one subtle feature.  The\
true-or-false test of the inner loop looks like this:\
\
@smallexample\
@group\
(and (car sorted-lengths)\
     (< (car sorted-lengths) top-of-range))\
@end group\
@end smallexample\
\
@need 800\
@noindent\
instead of like this:\
\
@smallexample\
(< (car sorted-lengths) top-of-range)\
@end smallexample\
\
The purpose of the test is to determine whether the first item in the\
@code\{sorted-lengths\} list is less than the value of the top of the\
range.\
\
The simple version of the test works fine unless the\
@code\{sorted-lengths\} list has a @code\{nil\} value.  In that case, the\
@code\{(car sorted-lengths)\} expression function returns\
@code\{nil\}.  The @code\{<\} function cannot compare a number to\
@code\{nil\}, which is an empty list, so Emacs signals an error and\
stops the function from attempting to continue to execute.\
\
The @code\{sorted-lengths\} list always becomes @code\{nil\} when the\
counter reaches the end of the list.  This means that any attempt to\
use the @code\{defuns-per-range\} function with the simple version of\
the test will fail.\
\
We solve the problem by using the @code\{(car sorted-lengths)\}\
expression in conjunction with the @code\{and\} expression.  The\
@code\{(car sorted-lengths)\} expression returns a non-@code\{nil\}\
value so long as the list has at least one number within it, but\
returns @code\{nil\} if the list is empty.  The @code\{and\} expression\
first evaluates the @code\{(car sorted-lengths)\} expression, and\
if it is @code\{nil\}, returns false @emph\{without\} evaluating the\
@code\{<\} expression.  But if the @code\{(car sorted-lengths)\}\
expression returns a non-@code\{nil\} value, the @code\{and\} expression\
evaluates the @code\{<\} expression, and returns that value as the value\
of the @code\{and\} expression.\
\
@c colon in printed section title causes problem in Info cross reference\
This way, we avoid an error.\
@iftex\
@noindent\
(For information about @code\{and\}, see\
@ref\{kill-new function, , The @code\{kill-new\} function\}.)\
@end iftex\
@ifinfo\
@noindent\
(@xref\{kill-new function, , The @code\{kill-new\} function\}, for\
information about @code\{and\}.)\
@end ifinfo\
\
Here is a short test of the @code\{defuns-per-range\} function.  First,\
evaluate the expression that binds (a shortened)\
@code\{top-of-ranges\} list to the list of values, then evaluate the\
expression for binding the @code\{sorted-lengths\} list, and then\
evaluate the @code\{defuns-per-range\} function.\
\
@smallexample\
@group\
;; @r\{(Shorter list than we will use later.)\}\
(setq top-of-ranges\
 '(110 120 130 140 150\
   160 170 180 190 200))\
\
(setq sorted-lengths\
      '(85 86 110 116 122 129 154 176 179 200 265 300 300))\
\
(defuns-per-range sorted-lengths top-of-ranges)\
@end group\
@end smallexample\
\
@need 800\
@noindent\
The list returned looks like this:\
\
@smallexample\
(2 2 2 0 0 1 0 2 0 0 4)\
@end smallexample\
\
@noindent\
Indeed, there are two elements of the @code\{sorted-lengths\} list\
smaller than 110, two elements between 110 and 119, two elements\
between 120 and 129, and so on.  There are four elements with a value\
of 200 or larger.}