{\rtf1\ansi\ansicpg949\cocoartf1187\cocoasubrtf340
{\fonttbl\f0\fnil\fcharset129 AppleSDGothicNeo-Regular;}
{\colortbl;\red255\green255\blue255;}
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\fi360\sl288\slmult1\pardirnatural

\f0\fs28 \cf0 \
@node Debugging, Conclusion, Emacs Initialization, Top\
@chapter Debugging\
@cindex debugging\
\
GNU Emacs has two debuggers, @code\{debug\} and @code\{edebug\}.  The\
first is built into the internals of Emacs and is always with you;\
the second requires that you instrument a function before you can use it.\
\
Both debuggers are described extensively in @ref\{Debugging, ,\
Debugging Lisp Programs, elisp, The GNU Emacs Lisp Reference Manual\}.\
In this chapter, I will walk through a short example of each.\
\
@menu\
* debug::                       How to use the built-in debugger.\
* debug-on-entry::              Start debugging when you call a function.\
* debug-on-quit::               Start debugging when you quit with @kbd\{C-g\}.\
* edebug::                      How to use Edebug, a source level debugger.\
* Debugging Exercises::\
@end menu\
\
@node debug, debug-on-entry, Debugging, Debugging\
@section @code\{debug\}\
@findex debug\
\
Suppose you have written a function definition that is intended to\
return the sum of the numbers 1 through a given number.  (This is the\
@code\{triangle\} function discussed earlier.  @xref\{Decrementing\
Example, , Example with Decrementing Counter\}, for a discussion.)\
@c xref\{Decrementing Loop,, Loop with a Decrementing Counter\}, for a discussion.)\
\
However, your function definition has a bug.  You have mistyped\
@samp\{1=\} for @samp\{1-\}.  Here is the broken definition:\
\
@findex triangle-bugged\
@smallexample\
@group\
(defun triangle-bugged (number)\
  "Return sum of numbers 1 through NUMBER inclusive."\
  (let ((total 0))\
    (while (> number 0)\
      (setq total (+ total number))\
      (setq number (1= number)))      ; @r\{Error here.\}\
    total))\
@end group\
@end smallexample\
\
If you are reading this in Info, you can evaluate this definition in\
the normal fashion.  You will see @code\{triangle-bugged\} appear in the\
echo area.\
\
@need 1250\
Now evaluate the @code\{triangle-bugged\} function with an\
argument of 4:\
\
@smallexample\
(triangle-bugged 4)\
@end smallexample\
\
@noindent\
In a recent GNU Emacs, you will create and enter a @file\{*Backtrace*\}\
buffer that says:\
\
@noindent\
@smallexample\
@group\
---------- Buffer: *Backtrace* ----------\
Debugger entered--Lisp error: (void-function 1=)\
  (1= number)\
  (setq number (1= number))\
  (while (> number 0) (setq total (+ total number))\
        (setq number (1= number)))\
  (let ((total 0)) (while (> number 0) (setq total ...)\
    (setq number ...)) total)\
  triangle-bugged(4)\
@end group\
@group\
  eval((triangle-bugged 4))\
  eval-last-sexp-1(nil)\
  eval-last-sexp(nil)\
  call-interactively(eval-last-sexp)\
---------- Buffer: *Backtrace* ----------\
@end group\
@end smallexample\
\
@noindent\
(I have reformatted this example slightly; the debugger does not fold\
long lines.  As usual, you can quit the debugger by typing @kbd\{q\} in\
the @file\{*Backtrace*\} buffer.)\
\
In practice, for a bug as simple as this, the `Lisp error' line will\
tell you what you need to know to correct the definition.  The\
function @code\{1=\} is `void'.\
\
@ignore\
@need 800\
In GNU Emacs 20 and before, you will see:\
\
@smallexample\
Symbol's function definition is void:@: 1=\
@end smallexample\
\
@noindent\
which has the same meaning as the @file\{*Backtrace*\} buffer line in\
version 21.\
@end ignore\
\
However, suppose you are not quite certain what is going on?\
You can read the complete backtrace.\
\
In this case, you need to run a recent GNU Emacs, which automatically\
starts the debugger that puts you in the @file\{*Backtrace*\} buffer; or\
else, you need to start the debugger manually as described below.\
\
Read the @file\{*Backtrace*\} buffer from the bottom up; it tells you\
what Emacs did that led to the error.  Emacs made an interactive call\
to @kbd\{C-x C-e\} (@code\{eval-last-sexp\}), which led to the evaluation\
of the @code\{triangle-bugged\} expression.  Each line above tells you\
what the Lisp interpreter evaluated next.\
\
@need 1250\
The third line from the top of the buffer is\
\
@smallexample\
(setq number (1= number))\
@end smallexample\
\
@noindent\
Emacs tried to evaluate this expression; in order to do so, it tried\
to evaluate the inner expression shown on the second line from the\
top:\
\
@smallexample\
(1= number)\
@end smallexample\
\
@need 1250\
@noindent\
This is where the error occurred; as the top line says:\
\
@smallexample\
Debugger entered--Lisp error: (void-function 1=)\
@end smallexample\
\
@noindent\
You can correct the mistake, re-evaluate the function definition, and\
then run your test again.\
\
@node debug-on-entry, debug-on-quit, debug, Debugging\
@section @code\{debug-on-entry\}\
@findex debug-on-entry\
\
A recent GNU Emacs starts the debugger automatically when your\
function has an error.\
\
@ignore\
GNU Emacs version 20 and before did not; it simply\
presented you with an error message.  You had to start the debugger\
manually.\
@end ignore\
\
Incidentally, you can start the debugger manually for all versions of\
Emacs; the advantage is that the debugger runs even if you do not have\
a bug in your code.  Sometimes your code will be free of bugs!\
\
You can enter the debugger when you call the function by calling\
@code\{debug-on-entry\}.\
\
@need 1250\
@noindent\
Type:\
\
@smallexample\
M-x debug-on-entry RET triangle-bugged RET\
@end smallexample\
\
@need 1250\
@noindent\
Now, evaluate the following:\
\
@smallexample\
(triangle-bugged 5)\
@end smallexample\
\
@noindent\
All versions of Emacs will create a @file\{*Backtrace*\} buffer and tell\
you that it is beginning to evaluate the @code\{triangle-bugged\}\
function:\
\
@smallexample\
@group\
---------- Buffer: *Backtrace* ----------\
Debugger entered--entering a function:\
* triangle-bugged(5)\
  eval((triangle-bugged 5))\
@end group\
@group\
  eval-last-sexp-1(nil)\
  eval-last-sexp(nil)\
  call-interactively(eval-last-sexp)\
---------- Buffer: *Backtrace* ----------\
@end group\
@end smallexample\
\
In the @file\{*Backtrace*\} buffer, type @kbd\{d\}.  Emacs will evaluate\
the first expression in @code\{triangle-bugged\}; the buffer will look\
like this:\
\
@smallexample\
@group\
---------- Buffer: *Backtrace* ----------\
Debugger entered--beginning evaluation of function call form:\
* (let ((total 0)) (while (> number 0) (setq total ...)\
        (setq number ...)) total)\
* triangle-bugged(5)\
  eval((triangle-bugged 5))\
@end group\
@group\
  eval-last-sexp-1(nil)\
  eval-last-sexp(nil)\
  call-interactively(eval-last-sexp)\
---------- Buffer: *Backtrace* ----------\
@end group\
@end smallexample\
\
@noindent\
Now, type @kbd\{d\} again, eight times, slowly.  Each time you type\
@kbd\{d\}, Emacs will evaluate another expression in the function\
definition.\
\
@need 1750\
Eventually, the buffer will look like this:\
\
@smallexample\
@group\
---------- Buffer: *Backtrace* ----------\
Debugger entered--beginning evaluation of function call form:\
* (setq number (1= number))\
* (while (> number 0) (setq total (+ total number))\
        (setq number (1= number)))\
@group\
@end group\
* (let ((total 0)) (while (> number 0) (setq total ...)\
        (setq number ...)) total)\
* triangle-bugged(5)\
  eval((triangle-bugged 5))\
@group\
@end group\
  eval-last-sexp-1(nil)\
  eval-last-sexp(nil)\
  call-interactively(eval-last-sexp)\
---------- Buffer: *Backtrace* ----------\
@end group\
@end smallexample\
\
@need 1500\
@noindent\
Finally, after you type @kbd\{d\} two more times, Emacs will reach the\
error, and the top two lines of the @file\{*Backtrace*\} buffer will look\
like this:\
\
@smallexample\
@group\
---------- Buffer: *Backtrace* ----------\
Debugger entered--Lisp error: (void-function 1=)\
* (1= number)\
@dots\{\}\
---------- Buffer: *Backtrace* ----------\
@end group\
@end smallexample\
\
By typing @kbd\{d\}, you were able to step through the function.\
\
You can quit a @file\{*Backtrace*\} buffer by typing @kbd\{q\} in it; this\
quits the trace, but does not cancel @code\{debug-on-entry\}.\
\
@findex cancel-debug-on-entry\
To cancel the effect of @code\{debug-on-entry\}, call\
@code\{cancel-debug-on-entry\} and the name of the function, like this:\
\
@smallexample\
M-x cancel-debug-on-entry RET triangle-bugged RET\
@end smallexample\
\
@noindent\
(If you are reading this in Info, cancel @code\{debug-on-entry\} now.)\
\
@node debug-on-quit, edebug, debug-on-entry, Debugging\
@section @code\{debug-on-quit\} and @code\{(debug)\}\
\
In addition to setting @code\{debug-on-error\} or calling @code\{debug-on-entry\},\
there are two other ways to start @code\{debug\}.\
\
@findex debug-on-quit\
You can start @code\{debug\} whenever you type @kbd\{C-g\}\
(@code\{keyboard-quit\}) by setting the variable @code\{debug-on-quit\} to\
@code\{t\}.  This is useful for debugging infinite loops.\
\
@need 1500\
@cindex @code\{(debug)\} in code\
Or, you can insert a line that says @code\{(debug)\} into your code\
where you want the debugger to start, like this:\
\
@smallexample\
@group\
(defun triangle-bugged (number)\
  "Return sum of numbers 1 through NUMBER inclusive."\
  (let ((total 0))\
    (while (> number 0)\
      (setq total (+ total number))\
      (debug)                         ; @r\{Start debugger.\}\
      (setq number (1= number)))      ; @r\{Error here.\}\
    total))\
@end group\
@end smallexample\
\
The @code\{debug\} function is described in detail in @ref\{Debugger, ,\
The Lisp Debugger, elisp, The GNU Emacs Lisp Reference Manual\}.\
\
@node edebug, Debugging Exercises, debug-on-quit, Debugging\
@section The @code\{edebug\} Source Level Debugger\
@cindex Source level debugger\
@findex edebug\
\
Edebug is a source level debugger.  Edebug normally displays the\
source of the code you are debugging, with an arrow at the left that\
shows which line you are currently executing.\
\
You can walk through the execution of a function, line by line, or run\
quickly until reaching a @dfn\{breakpoint\} where execution stops.\
\
Edebug is described in @ref\{edebug, , Edebug, elisp, The GNU Emacs\
Lisp Reference Manual\}.\
\
@need 1250\
Here is a bugged function definition for @code\{triangle-recursively\}.\
@xref\{Recursive triangle function, , Recursion in place of a counter\},\
for a review of it.\
\
@smallexample\
@group\
(defun triangle-recursively-bugged (number)\
  "Return sum of numbers 1 through NUMBER inclusive.\
Uses recursion."\
  (if (= number 1)\
      1\
    (+ number\
       (triangle-recursively-bugged\
        (1= number)))))               ; @r\{Error here.\}\
@end group\
@end smallexample\
\
@noindent\
Normally, you would install this definition by positioning your cursor\
after the function's closing parenthesis and typing @kbd\{C-x C-e\}\
(@code\{eval-last-sexp\}) or else by positioning your cursor within the\
definition and typing @kbd\{C-M-x\} (@code\{eval-defun\}).  (By default,\
the @code\{eval-defun\} command works only in Emacs Lisp mode or in Lisp\
Interaction mode.)\
\
@need 1500\
However, to prepare this function definition for Edebug, you must\
first @dfn\{instrument\} the code using a different command.  You can do\
this by positioning your cursor within or just after the definition\
and typing\
\
@smallexample\
M-x edebug-defun RET\
@end smallexample\
\
@noindent\
This will cause Emacs to load Edebug automatically if it is not\
already loaded, and properly instrument the function.\
\
After instrumenting the function, place your cursor after the\
following expression and type @kbd\{C-x C-e\} (@code\{eval-last-sexp\}):\
\
@smallexample\
(triangle-recursively-bugged 3)\
@end smallexample\
\
@noindent\
You will be jumped back to the source for\
@code\{triangle-recursively-bugged\} and the cursor positioned at the\
beginning of the @code\{if\} line of the function.  Also, you will see\
an arrowhead at the left hand side of that line.  The arrowhead marks\
the line where the function is executing.  (In the following examples,\
we show the arrowhead with @samp\{=>\}; in a windowing system, you may\
see the arrowhead as a solid triangle in the window `fringe'.)\
\
@smallexample\
=>@point\{\}(if (= number 1)\
@end smallexample\
\
@noindent\
@iftex\
In the example, the location of point is displayed with a star,\
@samp\{@point\{\}\} (in Info, it is displayed as @samp\{-!-\}).\
@end iftex\
@ifnottex\
In the example, the location of point is displayed as @samp\{@point\{\}\}\
(in a printed book, it is displayed with a five pointed star).\
@end ifnottex\
\
If you now press @key\{SPC\}, point will move to the next expression to\
be executed; the line will look like this:\
\
@smallexample\
=>(if @point\{\}(= number 1)\
@end smallexample\
\
@noindent\
As you continue to press @key\{SPC\}, point will move from expression to\
expression.  At the same time, whenever an expression returns a value,\
that value will be displayed in the echo area.  For example, after you\
move point past @code\{number\}, you will see the following:\
\
@smallexample\
Result: 3 (#o3, #x3, ?\\C-c)\
@end smallexample\
\
@noindent\
This means the value of @code\{number\} is 3, which is octal three,\
hexadecimal three, and @sc\{ascii\} `control-c' (the third letter of the\
alphabet, in case you need to know this information).\
\
You can continue moving through the code until you reach the line with\
the error.  Before evaluation, that line looks like this:\
\
@smallexample\
=>        @point\{\}(1= number)))))               ; @r\{Error here.\}\
@end smallexample\
\
@need 1250\
@noindent\
When you press @key\{SPC\} once again, you will produce an error message\
that says:\
\
@smallexample\
Symbol's function definition is void:@: 1=\
@end smallexample\
\
@noindent\
This is the bug.\
\
Press @kbd\{q\} to quit Edebug.\
\
To remove instrumentation from a function definition, simply\
re-evaluate it with a command that does not instrument it.\
For example, you could place your cursor after the definition's\
closing parenthesis and type @kbd\{C-x C-e\}.\
\
Edebug does a great deal more than walk with you through a function.\
You can set it so it races through on its own, stopping only at an\
error or at specified stopping points; you can cause it to display the\
changing values of various expressions; you can find out how many\
times a function is called, and more.\
\
Edebug is described in @ref\{edebug, , Edebug, elisp, The GNU Emacs\
Lisp Reference Manual\}.\
\
@need 1500\
@node Debugging Exercises,  , edebug, Debugging\
@section Debugging Exercises\
\
@itemize @bullet\
@item\
Install the @code\{count-words-region\} function and then cause it to\
enter the built-in debugger when you call it.  Run the command on a\
region containing two words.  You will need to press @kbd\{d\} a\
remarkable number of times.  On your system, is a `hook' called after\
the command finishes?  (For information on hooks, see @ref\{Command\
Overview, , Command Loop Overview, elisp, The GNU Emacs Lisp Reference\
Manual\}.)\
\
@item\
Copy @code\{count-words-region\} into the @file\{*scratch*\} buffer,\
instrument the function for Edebug, and walk through its execution.\
The function does not need to have a bug, although you can introduce\
one if you wish.  If the function lacks a bug, the walk-through\
completes without problems.\
\
@item\
While running Edebug, type @kbd\{?\} to see a list of all the Edebug commands.\
(The @code\{global-edebug-prefix\} is usually @kbd\{C-x X\}, i.e.@:\
@kbd\{@key\{CTRL\}-x\} followed by an upper case @kbd\{X\}; use this prefix\
for commands made outside of the Edebug debugging buffer.)\
\
@item\
In the Edebug debugging buffer, use the @kbd\{p\}\
(@code\{edebug-bounce-point\}) command to see where in the region the\
@code\{count-words-region\} is working.\
\
@item\
Move point to some spot further down the function and then type the\
@kbd\{h\} (@code\{edebug-goto-here\}) command to jump to that location.\
\
@item\
Use the @kbd\{t\} (@code\{edebug-trace-mode\}) command to cause Edebug to\
walk through the function on its own; use an upper case @kbd\{T\} for\
@code\{edebug-Trace-fast-mode\}.\
\
@item\
Set a breakpoint, then run Edebug in Trace mode until it reaches the\
stopping point.\
@end itemize}