{\rtf1\ansi\ansicpg949\cocoartf1187\cocoasubrtf340
{\fonttbl\f0\fnil\fcharset129 AppleSDGothicNeo-Regular;}
{\colortbl;\red255\green255\blue255;}
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\fi360\sl288\slmult1\pardirnatural

\f0\fs28 \cf0 \
@node Yanking, Loops & Recursion, List Implementation, Top\
@comment  node-name,  next,  previous,  up\
@chapter Yanking Text Back\
@findex yank\
@cindex Text retrieval\
@cindex Retrieving text\
@cindex Pasting text\
\
Whenever you cut text out of a buffer with a `kill' command in GNU Emacs,\
you can bring it back with a `yank' command.  The text that is cut out of\
the buffer is put in the kill ring and the yank commands insert the\
appropriate contents of the kill ring back into a buffer (not necessarily\
the original buffer).\
\
A simple @kbd\{C-y\} (@code\{yank\}) command inserts the first item from\
the kill ring into the current buffer.  If the @kbd\{C-y\} command is\
followed immediately by @kbd\{M-y\}, the first element is replaced by\
the second element.  Successive @kbd\{M-y\} commands replace the second\
element with the third, fourth, or fifth element, and so on.  When the\
last element in the kill ring is reached, it is replaced by the first\
element and the cycle is repeated.  (Thus the kill ring is called a\
`ring' rather than just a `list'.  However, the actual data structure\
that holds the text is a list.\
@xref\{Kill Ring, , Handling the Kill Ring\}, for the details of how the\
list is handled as a ring.)\
\
@menu\
* Kill Ring Overview::\
* kill-ring-yank-pointer::      The kill ring is a list.\
* yank nthcdr Exercises::       The @code\{kill-ring-yank-pointer\} variable.\
@end menu\
\
@node Kill Ring Overview, kill-ring-yank-pointer, Yanking, Yanking\
@comment  node-name,  next,  previous,  up\
@section Kill Ring Overview\
@cindex Kill ring overview\
\
The kill ring is a list of textual strings.  This is what it looks like:\
\
@smallexample\
("some text" "a different piece of text" "yet more text")\
@end smallexample\
\
If this were the contents of my kill ring and I pressed @kbd\{C-y\}, the\
string of characters saying @samp\{some text\} would be inserted in this\
buffer where my cursor is located.\
\
The @code\{yank\} command is also used for duplicating text by copying it.\
The copied text is not cut from the buffer, but a copy of it is put on the\
kill ring and is inserted by yanking it back.\
\
Three functions are used for bringing text back from the kill ring:\
@code\{yank\}, which is usually bound to @kbd\{C-y\}; @code\{yank-pop\},\
which is usually bound to @kbd\{M-y\}; and @code\{rotate-yank-pointer\},\
which is used by the two other functions.\
\
These functions refer to the kill ring through a variable called the\
@code\{kill-ring-yank-pointer\}.  Indeed, the insertion code for both the\
@code\{yank\} and @code\{yank-pop\} functions is:\
\
@smallexample\
(insert (car kill-ring-yank-pointer))\
@end smallexample\
\
@noindent\
(Well, no more.  In GNU Emacs 22, the function has been replaced by\
@code\{insert-for-yank\} which calls @code\{insert-for-yank-1\}\
repetitively for each @code\{yank-handler\} segment.  In turn,\
@code\{insert-for-yank-1\} strips text properties from the inserted text\
according to @code\{yank-excluded-properties\}.  Otherwise, it is just\
like @code\{insert\}.  We will stick with plain @code\{insert\} since it\
is easier to understand.)\
\
To begin to understand how @code\{yank\} and @code\{yank-pop\} work, it is\
first necessary to look at the @code\{kill-ring-yank-pointer\} variable.\
\
@node kill-ring-yank-pointer, yank nthcdr Exercises, Kill Ring Overview, Yanking\
@comment  node-name,  next,  previous,  up\
@section The @code\{kill-ring-yank-pointer\} Variable\
\
@code\{kill-ring-yank-pointer\} is a variable, just as @code\{kill-ring\} is\
a variable.  It points to something by being bound to the value of what\
it points to, like any other Lisp variable.\
\
@need 1000\
Thus, if the value of the kill ring is:\
\
@smallexample\
("some text" "a different piece of text" "yet more text")\
@end smallexample\
\
@need 1250\
@noindent\
and the @code\{kill-ring-yank-pointer\} points to the second clause, the\
value of @code\{kill-ring-yank-pointer\} is:\
\
@smallexample\
("a different piece of text" "yet more text")\
@end smallexample\
\
As explained in the previous chapter (@pxref\{List Implementation\}), the\
computer does not keep two different copies of the text being pointed to\
by both the @code\{kill-ring\} and the @code\{kill-ring-yank-pointer\}.  The\
words ``a different piece of text'' and ``yet more text'' are not\
duplicated.  Instead, the two Lisp variables point to the same pieces of\
text.  Here is a diagram:\
\
@c cons-cell-diagram #5\
@ifnottex\
@smallexample\
@group\
kill-ring     kill-ring-yank-pointer\
    |               |\
    |      ___ ___  |     ___ ___      ___ ___\
     ---> |   |   |  --> |   |   |    |   |   |\
          |___|___|----> |___|___|--> |___|___|--> nil\
            |              |            |\
            |              |            |\
            |              |             --> "yet more text"\
            |              |\
            |               --> "a different piece of text"\
            |\
             --> "some text"\
@end group\
@end smallexample\
@sp 1\
@end ifnottex\
@ifset print-postscript-figures\
@sp 1\
@tex\
@center @image\{cons-5\}\
%%%% old method of including an image\
% \\input /usr/local/lib/tex/inputs/psfig.tex\
% \\centerline\{\\psfig\{figure=/usr/local/lib/emacs/man/cons-5.eps\}\}\
% \\catcode`\\@=0 %\
@end tex\
@sp 1\
@end ifset\
@ifclear print-postscript-figures\
@iftex\
@smallexample\
@group\
kill-ring     kill-ring-yank-pointer\
    |               |\
    |      ___ ___  |     ___ ___      ___ ___\
     ---> |   |   |  --> |   |   |    |   |   |\
          |___|___|----> |___|___|--> |___|___|--> nil\
            |              |            |\
            |              |            |\
            |              |             --> "yet more text"\
            |              |\
            |               --> "a different piece of text\
            |\
             --> "some text"\
@end group\
@end smallexample\
@sp 1\
@end iftex\
@end ifclear\
\
Both the variable @code\{kill-ring\} and the variable\
@code\{kill-ring-yank-pointer\} are pointers.  But the kill ring itself is\
usually described as if it were actually what it is composed of.  The\
@code\{kill-ring\} is spoken of as if it were the list rather than that it\
points to the list.  Conversely, the @code\{kill-ring-yank-pointer\} is\
spoken of as pointing to a list.\
\
These two ways of talking about the same thing sound confusing at first but\
make sense on reflection.  The kill ring is generally thought of as the\
complete structure of data that holds the information of what has recently\
been cut out of the Emacs buffers.  The @code\{kill-ring-yank-pointer\}\
on the other hand, serves to indicate---that is, to `point to'---that part\
of the kill ring of which the first element (the @sc\{car\}) will be\
inserted.\
\
@ignore\
In GNU Emacs 22, the @code\{kill-new\} function calls\
\
@code\{(setq kill-ring-yank-pointer kill-ring)\}\
\
(defun rotate-yank-pointer (arg)\
  "Rotate the yanking point in the kill ring.\
With argument, rotate that many kills forward (or backward, if negative)."\
  (interactive "p")\
  (current-kill arg))\
\
(defun current-kill (n &optional do-not-move)\
  "Rotate the yanking point by N places, and then return that kill.\
If N is zero, `interprogram-paste-function' is set, and calling it\
returns a string, then that string is added to the front of the\
kill ring and returned as the latest kill.\
If optional arg DO-NOT-MOVE is non-nil, then don't actually move the\
yanking point; just return the Nth kill forward."\
  (let ((interprogram-paste (and (= n 0)\
                                 interprogram-paste-function\
                                 (funcall interprogram-paste-function))))\
    (if interprogram-paste\
        (progn\
          ;; Disable the interprogram cut function when we add the new\
          ;; text to the kill ring, so Emacs doesn't try to own the\
          ;; selection, with identical text.\
          (let ((interprogram-cut-function nil))\
            (kill-new interprogram-paste))\
          interprogram-paste)\
      (or kill-ring (error "Kill ring is empty"))\
      (let ((ARGth-kill-element\
             (nthcdr (mod (- n (length kill-ring-yank-pointer))\
                          (length kill-ring))\
                     kill-ring)))\
        (or do-not-move\
            (setq kill-ring-yank-pointer ARGth-kill-element))\
        (car ARGth-kill-element)))))\
\
@end ignore\
\
@need 1500\
@node yank nthcdr Exercises,  , kill-ring-yank-pointer, Yanking\
@section Exercises with @code\{yank\} and @code\{nthcdr\}\
\
@itemize @bullet\
@item\
Using @kbd\{C-h v\} (@code\{describe-variable\}), look at the value of\
your kill ring.  Add several items to your kill ring; look at its\
value again.  Using @kbd\{M-y\} (@code\{yank-pop)\}, move all the way\
around the kill ring.  How many items were in your kill ring?  Find\
the value of @code\{kill-ring-max\}.  Was your kill ring full, or could\
you have kept more blocks of text within it?\
\
@item\
Using @code\{nthcdr\} and @code\{car\}, construct a series of expressions\
to return the first, second, third, and fourth elements of a list.\
@end itemize}