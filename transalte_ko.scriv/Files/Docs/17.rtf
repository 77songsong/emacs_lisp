{\rtf1\ansi\ansicpg949\cocoartf1187\cocoasubrtf340
{\fonttbl\f0\fnil\fcharset129 AppleSDGothicNeo-Regular;}
{\colortbl;\red255\green255\blue255;}
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\fi360\sl288\slmult1\pardirnatural

\f0\fs28 \cf0 \
@node Regexp Search, Counting Words, Loops & Recursion, Top\
@comment  node-name,  next,  previous,  up\
@chapter Regular Expression Searches\
@cindex Searches, illustrating\
@cindex Regular expression searches\
@cindex Patterns, searching for\
@cindex Motion by sentence and paragraph\
@cindex Sentences, movement by\
@cindex Paragraphs, movement by\
\
Regular expression searches are used extensively in GNU Emacs.  The\
two functions, @code\{forward-sentence\} and @code\{forward-paragraph\},\
illustrate these searches well.  They use regular expressions to find\
where to move point.  The phrase `regular expression' is often written\
as `regexp'.\
\
Regular expression searches are described in @ref\{Regexp Search, ,\
Regular Expression Search, emacs, The GNU Emacs Manual\}, as well as in\
@ref\{Regular Expressions, , , elisp, The GNU Emacs Lisp Reference\
Manual\}.  In writing this chapter, I am presuming that you have at\
least a mild acquaintance with them.  The major point to remember is\
that regular expressions permit you to search for patterns as well as\
for literal strings of characters.  For example, the code in\
@code\{forward-sentence\} searches for the pattern of possible\
characters that could mark the end of a sentence, and moves point to\
that spot.\
\
Before looking at the code for the @code\{forward-sentence\} function, it\
is worth considering what the pattern that marks the end of a sentence\
must be.  The pattern is discussed in the next section; following that\
is a description of the regular expression search function,\
@code\{re-search-forward\}.  The @code\{forward-sentence\} function\
is described in the section following.  Finally, the\
@code\{forward-paragraph\} function is described in the last section of\
this chapter.  @code\{forward-paragraph\} is a complex function that\
introduces several new features.\
\
@menu\
* sentence-end::                The regular expression for @code\{sentence-end\}.\
* re-search-forward::           Very similar to @code\{search-forward\}.\
* forward-sentence::            A straightforward example of regexp search.\
* forward-paragraph::           A somewhat complex example.\
* etags::                       How to create your own @file\{TAGS\} table.\
* Regexp Review::\
* re-search Exercises::\
@end menu\
\
@node sentence-end, re-search-forward, Regexp Search, Regexp Search\
@comment  node-name,  next,  previous,  up\
@section The Regular Expression for @code\{sentence-end\}\
@findex sentence-end\
\
The symbol @code\{sentence-end\} is bound to the pattern that marks the\
end of a sentence.  What should this regular expression be?\
\
Clearly, a sentence may be ended by a period, a question mark, or an\
exclamation mark.  Indeed, in English, only clauses that end with one\
of those three characters should be considered the end of a sentence.\
This means that the pattern should include the character set:\
\
@smallexample\
[.?!]\
@end smallexample\
\
However, we do not want @code\{forward-sentence\} merely to jump to a\
period, a question mark, or an exclamation mark, because such a character\
might be used in the middle of a sentence.  A period, for example, is\
used after abbreviations.  So other information is needed.\
\
According to convention, you type two spaces after every sentence, but\
only one space after a period, a question mark, or an exclamation mark in\
the body of a sentence.  So a period, a question mark, or an exclamation\
mark followed by two spaces is a good indicator of an end of sentence.\
However, in a file, the two spaces may instead be a tab or the end of a\
line.  This means that the regular expression should include these three\
items as alternatives.\
\
@need 800\
This group of alternatives will look like this:\
\
@smallexample\
@group\
\\\\($\\\\| \\\\|  \\\\)\
       ^   ^^\
      TAB  SPC\
@end group\
@end smallexample\
\
@noindent\
Here, @samp\{$\} indicates the end of the line, and I have pointed out\
where the tab and two spaces are inserted in the expression.  Both are\
inserted by putting the actual characters into the expression.\
\
Two backslashes, @samp\{\\\\\}, are required before the parentheses and\
vertical bars: the first backslash quotes the following backslash in\
Emacs; and the second indicates that the following character, the\
parenthesis or the vertical bar, is special.\
\
@need 1000\
Also, a sentence may be followed by one or more carriage returns, like\
this:\
\
@smallexample\
@group\
[\
]*\
@end group\
@end smallexample\
\
@noindent\
Like tabs and spaces, a carriage return is inserted into a regular\
expression by inserting it literally.  The asterisk indicates that the\
@key\{RET\} is repeated zero or more times.\
\
But a sentence end does not consist only of a period, a question mark or\
an exclamation mark followed by appropriate space: a closing quotation\
mark or a closing brace of some kind may precede the space.  Indeed more\
than one such mark or brace may precede the space.  These require a\
expression that looks like this:\
\
@smallexample\
[]\\"')@\}]*\
@end smallexample\
\
In this expression, the first @samp\{]\} is the first character in the\
expression; the second character is @samp\{"\}, which is preceded by a\
@samp\{\\\} to tell Emacs the @samp\{"\} is @emph\{not\} special.  The last\
three characters are @samp\{'\}, @samp\{)\}, and @samp\{@\}\}.\
\
All this suggests what the regular expression pattern for matching the\
end of a sentence should be; and, indeed, if we evaluate\
@code\{sentence-end\} we find that it returns the following value:\
\
@smallexample\
@group\
sentence-end\
     @result\{\} "[.?!][]\\"')@\}]*\\\\($\\\\|     \\\\|  \\\\)[\
]*"\
@end group\
@end smallexample\
\
@noindent\
(Well, not in GNU Emacs 22; that is because of an effort to make the\
process simpler and to handle more glyphs and languages.  When the\
value of @code\{sentence-end\} is @code\{nil\}, then use the value defined\
by the function @code\{sentence-end\}.  (Here is a use of the difference\
between a value and a function in Emacs Lisp.)  The function returns a\
value constructed from the variables @code\{sentence-end-base\},\
@code\{sentence-end-double-space\}, @code\{sentence-end-without-period\},\
and @code\{sentence-end-without-space\}.  The critical variable is\
@code\{sentence-end-base\}; its global value is similar to the one\
described above but it also contains two additional quotation marks.\
These have differing degrees of curliness.  The\
@code\{sentence-end-without-period\} variable, when true, tells Emacs\
that a sentence may end without a period, such as text in Thai.)\
\
@ignore\
@noindent\
(Note that here the @key\{TAB\}, two spaces, and  @key\{RET\} are shown\
literally in the pattern.)\
\
This regular expression can be deciphered as follows:\
\
@table @code\
@item [.?!]\
The first part of the pattern is the three characters, a period, a question\
mark and an exclamation mark, within square brackets.  The pattern must\
begin with one or other of these characters.\
\
@item []\\"')@\}]*\
The second part of the pattern is the group of closing braces and\
quotation marks, which can appear zero or more times.  These may follow\
the period, question mark or exclamation mark.  In a regular expression,\
the backslash, @samp\{\\\}, followed by the double quotation mark,\
@samp\{"\}, indicates the class of string-quote characters.  Usually, the\
double quotation mark is the only character in this class.  The\
asterisk, @samp\{*\}, indicates that the items in the previous group (the\
group surrounded by square brackets, @samp\{[]\}) may be repeated zero or\
more times.\
\
@item \\\\($\\\\|   \\\\|  \\\\)\
The third part of the pattern is one or other of: either the end of a\
line, or two blank spaces, or a tab.  The double back-slashes are used\
to prevent Emacs from reading the parentheses and vertical bars as part\
of the search pattern; the parentheses are used to mark the group and\
the vertical bars are used to indicated that the patterns to either side\
of them are alternatives.  The dollar sign is used to indicate the end\
of a line and both the two spaces and the tab are each inserted as is to\
indicate what they are.\
\
@item [@key\{RET\}]*\
Finally, the last part of the pattern indicates that the end of the line\
or the whitespace following the period, question mark or exclamation\
mark may, but need not, be followed by one or more carriage returns.  In\
the pattern, the carriage return is inserted as an actual carriage\
return between square brackets but here it is shown as @key\{RET\}.\
@end table\
@end ignore\
\
@node re-search-forward, forward-sentence, sentence-end, Regexp Search\
@comment  node-name,  next,  previous,  up\
@section The @code\{re-search-forward\} Function\
@findex re-search-forward\
\
The @code\{re-search-forward\} function is very like the\
@code\{search-forward\} function.  (@xref\{search-forward, , The\
@code\{search-forward\} Function\}.)\
\
@code\{re-search-forward\} searches for a regular expression.  If the\
search is successful, it leaves point immediately after the last\
character in the target.  If the search is backwards, it leaves point\
just before the first character in the target.  You may tell\
@code\{re-search-forward\} to return @code\{t\} for true.  (Moving point\
is therefore a `side effect'.)\
\
Like @code\{search-forward\}, the @code\{re-search-forward\} function takes\
four arguments:\
\
@enumerate\
@item\
The first argument is the regular expression that the function searches\
for.  The regular expression will be a string between quotations marks.\
\
@item\
The optional second argument limits how far the function will search; it is a\
bound, which is specified as a position in the buffer.\
\
@item\
The optional third argument specifies how the function responds to\
failure: @code\{nil\} as the third argument causes the function to\
signal an error (and print a message) when the search fails; any other\
value causes it to return @code\{nil\} if the search fails and @code\{t\}\
if the search succeeds.\
\
@item\
The optional fourth argument is the repeat count.  A negative repeat\
count causes @code\{re-search-forward\} to search backwards.\
@end enumerate\
\
@need 800\
The template for @code\{re-search-forward\} looks like this:\
\
@smallexample\
@group\
(re-search-forward "@var\{regular-expression\}"\
                @var\{limit-of-search\}\
                @var\{what-to-do-if-search-fails\}\
                @var\{repeat-count\})\
@end group\
@end smallexample\
\
The second, third, and fourth arguments are optional.  However, if you\
want to pass a value to either or both of the last two arguments, you\
must also pass a value to all the preceding arguments.  Otherwise, the\
Lisp interpreter will mistake which argument you are passing the value\
to.\
\
@need 1200\
In the @code\{forward-sentence\} function, the regular expression will be\
the value of the variable @code\{sentence-end\}.  In simple form, that is:\
\
@smallexample\
@group\
"[.?!][]\\"')@\}]*\\\\($\\\\|  \\\\|  \\\\)[\
]*"\
@end group\
@end smallexample\
\
@noindent\
The limit of the search will be the end of the paragraph (since a\
sentence cannot go beyond a paragraph).  If the search fails, the\
function will return @code\{nil\}; and the repeat count will be provided\
by the argument to the @code\{forward-sentence\} function.\
\
@node forward-sentence, forward-paragraph, re-search-forward, Regexp Search\
@comment  node-name,  next,  previous,  up\
@section @code\{forward-sentence\}\
@findex forward-sentence\
\
The command to move the cursor forward a sentence is a straightforward\
illustration of how to use regular expression searches in Emacs Lisp.\
Indeed, the function looks longer and more complicated than it is; this\
is because the function is designed to go backwards as well as forwards;\
and, optionally, over more than one sentence.  The function is usually\
bound to the key command @kbd\{M-e\}.\
\
@menu\
* Complete forward-sentence::\
* fwd-sentence while loops::    Two @code\{while\} loops.\
* fwd-sentence re-search::      A regular expression search.\
@end menu\
\
@node Complete forward-sentence, fwd-sentence while loops, forward-sentence, forward-sentence\
@ifnottex\
@unnumberedsubsec Complete @code\{forward-sentence\} function definition\
@end ifnottex\
\
@need 1250\
Here is the code for @code\{forward-sentence\}:\
\
@c in GNU Emacs 22\
@smallexample\
@group\
(defun forward-sentence (&optional arg)\
  "Move forward to next `sentence-end'.  With argument, repeat.\
With negative argument, move backward repeatedly to `sentence-beginning'.\
\
The variable `sentence-end' is a regular expression that matches ends of\
sentences.  Also, every paragraph boundary terminates sentences as well."\
@end group\
@group\
  (interactive "p")\
  (or arg (setq arg 1))\
  (let ((opoint (point))\
        (sentence-end (sentence-end)))\
    (while (< arg 0)\
      (let ((pos (point))\
            (par-beg (save-excursion (start-of-paragraph-text) (point))))\
       (if (and (re-search-backward sentence-end par-beg t)\
                (or (< (match-end 0) pos)\
                    (re-search-backward sentence-end par-beg t)))\
           (goto-char (match-end 0))\
         (goto-char par-beg)))\
      (setq arg (1+ arg)))\
@end group\
@group\
    (while (> arg 0)\
      (let ((par-end (save-excursion (end-of-paragraph-text) (point))))\
       (if (re-search-forward sentence-end par-end t)\
           (skip-chars-backward " \\t\\n")\
         (goto-char par-end)))\
      (setq arg (1- arg)))\
    (constrain-to-field nil opoint t)))\
@end group\
@end smallexample\
\
@ignore\
GNU Emacs 21\
@smallexample\
@group\
(defun forward-sentence (&optional arg)\
  "Move forward to next sentence-end.  With argument, repeat.\
With negative argument, move backward repeatedly to sentence-beginning.\
Sentence ends are identified by the value of sentence-end\
treated as a regular expression.  Also, every paragraph boundary\
terminates sentences as well."\
@end group\
@group\
  (interactive "p")\
  (or arg (setq arg 1))\
  (while (< arg 0)\
    (let ((par-beg\
           (save-excursion (start-of-paragraph-text) (point))))\
      (if (re-search-backward\
           (concat sentence-end "[^ \\t\\n]") par-beg t)\
          (goto-char (1- (match-end 0)))\
        (goto-char par-beg)))\
    (setq arg (1+ arg)))\
  (while (> arg 0)\
    (let ((par-end\
           (save-excursion (end-of-paragraph-text) (point))))\
      (if (re-search-forward sentence-end par-end t)\
          (skip-chars-backward " \\t\\n")\
        (goto-char par-end)))\
    (setq arg (1- arg))))\
@end group\
@end smallexample\
@end ignore\
\
The function looks long at first sight and it is best to look at its\
skeleton first, and then its muscle.  The way to see the skeleton is to\
look at the expressions that start in the left-most columns:\
\
@smallexample\
@group\
(defun forward-sentence (&optional arg)\
  "@var\{documentation\}@dots\{\}"\
  (interactive "p")\
  (or arg (setq arg 1))\
  (let ((opoint (point)) (sentence-end (sentence-end)))\
    (while (< arg 0)\
      (let ((pos (point))\
            (par-beg (save-excursion (start-of-paragraph-text) (point))))\
       @var\{rest-of-body-of-while-loop-when-going-backwards\}\
    (while (> arg 0)\
      (let ((par-end (save-excursion (end-of-paragraph-text) (point))))\
       @var\{rest-of-body-of-while-loop-when-going-forwards\}\
    @var\{handle-forms-and-equivalent\}\
@end group\
@end smallexample\
\
This looks much simpler!  The function definition consists of\
documentation, an @code\{interactive\} expression, an @code\{or\}\
expression, a @code\{let\} expression, and @code\{while\} loops.\
\
Let's look at each of these parts in turn.\
\
We note that the documentation is thorough and understandable.\
\
The function has an @code\{interactive "p"\} declaration.  This means\
that the processed prefix argument, if any, is passed to the\
function as its argument.  (This will be a number.)  If the function\
is not passed an argument (it is optional) then the argument\
@code\{arg\} will be bound to 1.\
\
When @code\{forward-sentence\} is called non-interactively without an\
argument, @code\{arg\} is bound to @code\{nil\}.  The @code\{or\} expression\
handles this.  What it does is either leave the value of @code\{arg\} as\
it is, but only if @code\{arg\} is bound to a value; or it sets the\
value of @code\{arg\} to 1, in the case when @code\{arg\} is bound to\
@code\{nil\}.\
\
Next is a @code\{let\}.  That specifies the values of two local\
variables, @code\{point\} and @code\{sentence-end\}.  The local value of\
point, from before the search, is used in the\
@code\{constrain-to-field\} function which handles forms and\
equivalents.  The @code\{sentence-end\} variable is set by the\
@code\{sentence-end\} function.\
\
@node fwd-sentence while loops, fwd-sentence re-search, Complete forward-sentence, forward-sentence\
@unnumberedsubsec The @code\{while\} loops\
\
Two @code\{while\} loops follow.  The first @code\{while\} has a\
true-or-false-test that tests true if the prefix argument for\
@code\{forward-sentence\} is a negative number.  This is for going\
backwards.  The body of this loop is similar to the body of the second\
@code\{while\} clause, but it is not exactly the same.  We will skip\
this @code\{while\} loop and concentrate on the second @code\{while\}\
loop.\
\
@need 1500\
The second @code\{while\} loop is for moving point forward.  Its skeleton\
looks like this:\
\
@smallexample\
@group\
(while (> arg 0)            ; @r\{true-or-false-test\}\
  (let @var\{varlist\}\
    (if (@var\{true-or-false-test\})\
        @var\{then-part\}\
      @var\{else-part\}\
  (setq arg (1- arg))))     ; @code\{while\} @r\{loop decrementer\}\
@end group\
@end smallexample\
\
The @code\{while\} loop is of the decrementing kind.\
(@xref\{Decrementing Loop, , A Loop with a Decrementing Counter\}.)  It\
has a true-or-false-test that tests true so long as the counter (in\
this case, the variable @code\{arg\}) is greater than zero; and it has a\
decrementer that subtracts 1 from the value of the counter every time\
the loop repeats.\
\
If no prefix argument is given to @code\{forward-sentence\}, which is\
the most common way the command is used, this @code\{while\} loop will\
run once, since the value of @code\{arg\} will be 1.\
\
The body of the @code\{while\} loop consists of a @code\{let\} expression,\
which creates and binds a local variable, and has, as its body, an\
@code\{if\} expression.\
\
@need 1250\
The body of the @code\{while\} loop looks like this:\
\
@smallexample\
@group\
(let ((par-end\
       (save-excursion (end-of-paragraph-text) (point))))\
  (if (re-search-forward sentence-end par-end t)\
      (skip-chars-backward " \\t\\n")\
    (goto-char par-end)))\
@end group\
@end smallexample\
\
The @code\{let\} expression creates and binds the local variable\
@code\{par-end\}.  As we shall see, this local variable is designed to\
provide a bound or limit to the regular expression search.  If the\
search fails to find a proper sentence ending in the paragraph, it will\
stop on reaching the end of the paragraph.\
\
But first, let us examine how @code\{par-end\} is bound to the value of\
the end of the paragraph.  What happens is that the @code\{let\} sets the\
value of @code\{par-end\} to the value returned when the Lisp interpreter\
evaluates the expression\
\
@smallexample\
@group\
(save-excursion (end-of-paragraph-text) (point))\
@end group\
@end smallexample\
\
@noindent\
In this expression, @code\{(end-of-paragraph-text)\} moves point to the\
end of the paragraph, @code\{(point)\} returns the value of point, and then\
@code\{save-excursion\} restores point to its original position.  Thus,\
the @code\{let\} binds @code\{par-end\} to the value returned by the\
@code\{save-excursion\} expression, which is the position of the end of\
the paragraph.  (The @code\{end-of-paragraph-text\} function uses\
@code\{forward-paragraph\}, which we will discuss shortly.)\
\
@need 1200\
Emacs next evaluates the body of the @code\{let\}, which is an @code\{if\}\
expression that looks like this:\
\
@smallexample\
@group\
(if (re-search-forward sentence-end par-end t) ; @r\{if-part\}\
    (skip-chars-backward " \\t\\n")              ; @r\{then-part\}\
  (goto-char par-end)))                        ; @r\{else-part\}\
@end group\
@end smallexample\
\
The @code\{if\} tests whether its first argument is true and if so,\
evaluates its then-part; otherwise, the Emacs Lisp interpreter\
evaluates the else-part.  The true-or-false-test of the @code\{if\}\
expression is the regular expression search.\
\
It may seem odd to have what looks like the `real work' of\
the @code\{forward-sentence\} function buried here, but this is a common\
way this kind of operation is carried out in Lisp.\
\
@node fwd-sentence re-search,  , fwd-sentence while loops, forward-sentence\
@unnumberedsubsec The regular expression search\
\
The @code\{re-search-forward\} function searches for the end of the\
sentence, that is, for the pattern defined by the @code\{sentence-end\}\
regular expression.  If the pattern is found---if the end of the sentence is\
found---then the @code\{re-search-forward\} function does two things:\
\
@enumerate\
@item\
The @code\{re-search-forward\} function carries out a side effect, which\
is to move point to the end of the occurrence found.\
\
@item\
The @code\{re-search-forward\} function returns a value of true.  This is\
the value received by the @code\{if\}, and means that the search was\
successful.\
@end enumerate\
\
@noindent\
The side effect, the movement of point, is completed before the\
@code\{if\} function is handed the value returned by the successful\
conclusion of the search.\
\
When the @code\{if\} function receives the value of true from a successful\
call to @code\{re-search-forward\}, the @code\{if\} evaluates the then-part,\
which is the expression @code\{(skip-chars-backward " \\t\\n")\}.  This\
expression moves backwards over any blank spaces, tabs or carriage\
returns until a printed character is found and then leaves point after\
the character.  Since point has already been moved to the end of the\
pattern that marks the end of the sentence, this action leaves point\
right after the closing printed character of the sentence, which is\
usually a period.\
\
On the other hand, if the @code\{re-search-forward\} function fails to\
find a pattern marking the end of the sentence, the function returns\
false.  The false then causes the @code\{if\} to evaluate its third\
argument, which is @code\{(goto-char par-end)\}:  it moves point to the\
end of the paragraph.\
\
(And if the text is in a form or equivalent, and point may not move\
fully, then the @code\{constrain-to-field\} function comes into play.)\
\
Regular expression searches are exceptionally useful and the pattern\
illustrated by @code\{re-search-forward\}, in which the search is the\
test of an @code\{if\} expression, is handy.  You will see or write code\
incorporating this pattern often.\
\
@node forward-paragraph, etags, forward-sentence, Regexp Search\
@comment  node-name,  next,  previous,  up\
@section @code\{forward-paragraph\}: a Goldmine of Functions\
@findex forward-paragraph\
\
@ignore\
@c in GNU Emacs 22\
(defun forward-paragraph (&optional arg)\
  "Move forward to end of paragraph.\
With argument ARG, do it ARG times;\
a negative argument ARG = -N means move backward N paragraphs.\
\
A line which `paragraph-start' matches either separates paragraphs\
\\(if `paragraph-separate' matches it also) or is the first line of a paragraph.\
A paragraph end is the beginning of a line which is not part of the paragraph\
to which the end of the previous line belongs, or the end of the buffer.\
Returns the count of paragraphs left to move."\
  (interactive "p")\
  (or arg (setq arg 1))\
  (let* ((opoint (point))\
         (fill-prefix-regexp\
          (and fill-prefix (not (equal fill-prefix ""))\
               (not paragraph-ignore-fill-prefix)\
               (regexp-quote fill-prefix)))\
         ;; Remove ^ from paragraph-start and paragraph-sep if they are there.\
         ;; These regexps shouldn't be anchored, because we look for them\
         ;; starting at the left-margin.  This allows paragraph commands to\
         ;; work normally with indented text.\
         ;; This hack will not find problem cases like "whatever\\\\|^something".\
         (parstart (if (and (not (equal "" paragraph-start))\
                            (equal ?^ (aref paragraph-start 0)))\
                       (substring paragraph-start 1)\
                     paragraph-start))\
         (parsep (if (and (not (equal "" paragraph-separate))\
                          (equal ?^ (aref paragraph-separate 0)))\
                     (substring paragraph-separate 1)\
                   paragraph-separate))\
         (parsep\
          (if fill-prefix-regexp\
              (concat parsep "\\\\|"\
                      fill-prefix-regexp "[ \\t]*$")\
            parsep))\
         ;; This is used for searching.\
         (sp-parstart (concat "^[ \\t]*\\\\(?:" parstart "\\\\|" parsep "\\\\)"))\
         start found-start)\
    (while (and (< arg 0) (not (bobp)))\
      (if (and (not (looking-at parsep))\
               (re-search-backward "^\\n" (max (1- (point)) (point-min)) t)\
               (looking-at parsep))\
          (setq arg (1+ arg))\
        (setq start (point))\
        ;; Move back over paragraph-separating lines.\
        (forward-char -1) (beginning-of-line)\
        (while (and (not (bobp))\
                    (progn (move-to-left-margin)\
                           (looking-at parsep)))\
          (forward-line -1))\
        (if (bobp)\
            nil\
          (setq arg (1+ arg))\
          ;; Go to end of the previous (non-separating) line.\
          (end-of-line)\
          ;; Search back for line that starts or separates paragraphs.\
          (if (if fill-prefix-regexp\
                  ;; There is a fill prefix; it overrides parstart.\
                  (let (multiple-lines)\
                    (while (and (progn (beginning-of-line) (not (bobp)))\
                                (progn (move-to-left-margin)\
                                       (not (looking-at parsep)))\
                                (looking-at fill-prefix-regexp))\
                      (unless (= (point) start)\
                        (setq multiple-lines t))\
                      (forward-line -1))\
                    (move-to-left-margin)\
                    ;; This deleted code caused a long hanging-indent line\
                    ;; not to be filled together with the following lines.\
                    ;; ;; Don't move back over a line before the paragraph\
                    ;; ;; which doesn't start with fill-prefix\
                    ;; ;; unless that is the only line we've moved over.\
                    ;; (and (not (looking-at fill-prefix-regexp))\
                    ;;      multiple-lines\
                    ;;      (forward-line 1))\
                    (not (bobp)))\
                (while (and (re-search-backward sp-parstart nil 1)\
                            (setq found-start t)\
                            ;; Found a candidate, but need to check if it is a\
                            ;; REAL parstart.\
                            (progn (setq start (point))\
                                   (move-to-left-margin)\
                                   (not (looking-at parsep)))\
                            (not (and (looking-at parstart)\
                                      (or (not use-hard-newlines)\
                                          (bobp)\
                                          (get-text-property\
                                           (1- start) 'hard)))))\
                  (setq found-start nil)\
                  (goto-char start))\
                found-start)\
              ;; Found one.\
              (progn\
                ;; Move forward over paragraph separators.\
                ;; We know this cannot reach the place we started\
                ;; because we know we moved back over a non-separator.\
                (while (and (not (eobp))\
                            (progn (move-to-left-margin)\
                                   (looking-at parsep)))\
                  (forward-line 1))\
                ;; If line before paragraph is just margin, back up to there.\
                (end-of-line 0)\
                (if (> (current-column) (current-left-margin))\
                    (forward-char 1)\
                  (skip-chars-backward " \\t")\
                  (if (not (bolp))\
                      (forward-line 1))))\
            ;; No starter or separator line => use buffer beg.\
            (goto-char (point-min))))))\
\
    (while (and (> arg 0) (not (eobp)))\
      ;; Move forward over separator lines...\
      (while (and (not (eobp))\
                  (progn (move-to-left-margin) (not (eobp)))\
                  (looking-at parsep))\
        (forward-line 1))\
      (unless (eobp) (setq arg (1- arg)))\
      ;; ... and one more line.\
      (forward-line 1)\
      (if fill-prefix-regexp\
          ;; There is a fill prefix; it overrides parstart.\
          (while (and (not (eobp))\
                      (progn (move-to-left-margin) (not (eobp)))\
                      (not (looking-at parsep))\
                      (looking-at fill-prefix-regexp))\
            (forward-line 1))\
        (while (and (re-search-forward sp-parstart nil 1)\
                    (progn (setq start (match-beginning 0))\
                           (goto-char start)\
                           (not (eobp)))\
                    (progn (move-to-left-margin)\
                           (not (looking-at parsep)))\
                    (or (not (looking-at parstart))\
                        (and use-hard-newlines\
                             (not (get-text-property (1- start) 'hard)))))\
          (forward-char 1))\
        (if (< (point) (point-max))\
            (goto-char start))))\
    (constrain-to-field nil opoint t)\
    ;; Return the number of steps that could not be done.\
    arg))\
@end ignore\
\
The @code\{forward-paragraph\} function moves point forward to the end\
of the paragraph.  It is usually bound to @kbd\{M-@\}\} and makes use of a\
number of functions that are important in themselves, including\
@code\{let*\}, @code\{match-beginning\}, and @code\{looking-at\}.\
\
The function definition for @code\{forward-paragraph\} is considerably\
longer than the function definition for @code\{forward-sentence\}\
because it works with a paragraph, each line of which may begin with a\
fill prefix.\
\
A fill prefix consists of a string of characters that are repeated at\
the beginning of each line.  For example, in Lisp code, it is a\
convention to start each line of a paragraph-long comment with\
@samp\{;;; \}.  In Text mode, four blank spaces make up another common\
fill prefix, creating an indented paragraph.  (@xref\{Fill Prefix, , ,\
emacs, The GNU Emacs Manual\}, for more information about fill\
prefixes.)\
\
The existence of a fill prefix means that in addition to being able to\
find the end of a paragraph whose lines begin on the left-most\
column, the @code\{forward-paragraph\} function must be able to find the\
end of a paragraph when all or many of the lines in the buffer begin\
with the fill prefix.\
\
Moreover, it is sometimes practical to ignore a fill prefix that\
exists, especially when blank lines separate paragraphs.\
This is an added complication.\
\
@menu\
* forward-paragraph in brief::  Key parts of the function definition.\
* fwd-para let::                The @code\{let*\} expression.\
* fwd-para while::              The forward motion @code\{while\} loop.\
@end menu\
\
@node forward-paragraph in brief, fwd-para let, forward-paragraph, forward-paragraph\
@ifnottex\
@unnumberedsubsec Shortened @code\{forward-paragraph\} function definition\
@end ifnottex\
\
Rather than print all of the @code\{forward-paragraph\} function, we\
will only print parts of it.  Read without preparation, the function\
can be daunting!\
\
@need 800\
In outline, the function looks like this:\
\
@smallexample\
@group\
(defun forward-paragraph (&optional arg)\
  "@var\{documentation\}@dots\{\}"\
  (interactive "p")\
  (or arg (setq arg 1))\
  (let*\
      @var\{varlist\}\
    (while (and (< arg 0) (not (bobp)))     ; @r\{backward-moving-code\}\
      @dots\{\}\
    (while (and (> arg 0) (not (eobp)))     ; @r\{forward-moving-code\}\
      @dots\{\}\
@end group\
@end smallexample\
\
The first parts of the function are routine: the function's argument\
list consists of one optional argument.  Documentation follows.\
\
The lower case @samp\{p\} in the @code\{interactive\} declaration means\
that the processed prefix argument, if any, is passed to the function.\
This will be a number, and is the repeat count of how many paragraphs\
point will move.  The @code\{or\} expression in the next line handles\
the common case when no argument is passed to the function, which occurs\
if the function is called from other code rather than interactively.\
This case was described earlier.  (@xref\{forward-sentence, The\
@code\{forward-sentence\} function\}.)  Now we reach the end of the\
familiar part of this function.\
\
@node fwd-para let, fwd-para while, forward-paragraph in brief, forward-paragraph\
@unnumberedsubsec The @code\{let*\} expression\
\
The next line of the @code\{forward-paragraph\} function begins a\
@code\{let*\} expression.  This is a different than @code\{let\}.  The\
symbol is @code\{let*\} not @code\{let\}.\
\
The @code\{let*\} special form is like @code\{let\} except that Emacs sets\
each variable in sequence, one after another, and variables in the\
latter part of the varlist can make use of the values to which Emacs\
set variables in the earlier part of the varlist.\
\
@ignore\
( refappend save-excursion, , code save-excursion in code append-to-buffer .)\
@end ignore\
\
(@ref\{append save-excursion, , @code\{save-excursion\} in @code\{append-to-buffer\}\}.)\
\
In the @code\{let*\} expression in this function, Emacs binds a total of\
seven variables:  @code\{opoint\}, @code\{fill-prefix-regexp\},\
@code\{parstart\}, @code\{parsep\}, @code\{sp-parstart\}, @code\{start\}, and\
@code\{found-start\}.\
\
The variable @code\{parsep\} appears twice, first, to remove instances\
of @samp\{^\}, and second, to handle fill prefixes.\
\
The variable @code\{opoint\} is just the value of @code\{point\}.  As you\
can guess, it is used in a @code\{constrain-to-field\} expression, just\
as in @code\{forward-sentence\}.\
\
The variable @code\{fill-prefix-regexp\} is set to the value returned by\
evaluating the following list:\
\
@smallexample\
@group\
(and fill-prefix\
     (not (equal fill-prefix ""))\
     (not paragraph-ignore-fill-prefix)\
     (regexp-quote fill-prefix))\
@end group\
@end smallexample\
\
@noindent\
This is an expression whose first element is the @code\{and\} special form.\
\
As we learned earlier (@pxref\{kill-new function, , The @code\{kill-new\}\
function\}), the @code\{and\} special form evaluates each of its\
arguments until one of the arguments returns a value of @code\{nil\}, in\
which case the @code\{and\} expression returns @code\{nil\}; however, if\
none of the arguments returns a value of @code\{nil\}, the value\
resulting from evaluating the last argument is returned.  (Since such\
a value is not @code\{nil\}, it is considered true in Lisp.)  In other\
words, an @code\{and\} expression returns a true value only if all its\
arguments are true.\
@findex and\
\
In this case, the variable @code\{fill-prefix-regexp\} is bound to a\
non-@code\{nil\} value only if the following four expressions produce a\
true (i.e., a non-@code\{nil\}) value when they are evaluated; otherwise,\
@code\{fill-prefix-regexp\} is bound to @code\{nil\}.\
\
@table @code\
@item fill-prefix\
When this variable is evaluated, the value of the fill prefix, if any,\
is returned.  If there is no fill prefix, this variable returns\
@code\{nil\}.\
\
@item (not (equal fill-prefix "")\
This expression checks whether an existing fill prefix is an empty\
string, that is, a string with no characters in it.  An empty string is\
not a useful fill prefix.\
\
@item (not paragraph-ignore-fill-prefix)\
This expression returns @code\{nil\} if the variable\
@code\{paragraph-ignore-fill-prefix\} has been turned on by being set to a\
true value such as @code\{t\}.\
\
@item (regexp-quote fill-prefix)\
This is the last argument to the @code\{and\} special form.  If all the\
arguments to the @code\{and\} are true, the value resulting from\
evaluating this expression will be returned by the @code\{and\} expression\
and bound to the variable @code\{fill-prefix-regexp\},\
@end table\
\
@findex regexp-quote\
@noindent\
The result of evaluating this @code\{and\} expression successfully is that\
@code\{fill-prefix-regexp\} will be bound to the value of\
@code\{fill-prefix\} as modified by the @code\{regexp-quote\} function.\
What @code\{regexp-quote\} does is read a string and return a regular\
expression that will exactly match the string and match nothing else.\
This means that @code\{fill-prefix-regexp\} will be set to a value that\
will exactly match the fill prefix if the fill prefix exists.\
Otherwise, the variable will be set to @code\{nil\}.\
\
The next two local variables in the @code\{let*\} expression are\
designed to remove instances of @samp\{^\} from @code\{parstart\} and\
@code\{parsep\}, the local variables which indicate the paragraph start\
and the paragraph separator.  The next expression sets @code\{parsep\}\
again.  That is to handle fill prefixes.\
\
This is the setting that requires the definition call @code\{let*\}\
rather than @code\{let\}.  The true-or-false-test for the @code\{if\}\
depends on whether the variable @code\{fill-prefix-regexp\} evaluates to\
@code\{nil\} or some other value.\
\
If @code\{fill-prefix-regexp\} does not have a value, Emacs evaluates\
the else-part of the @code\{if\} expression and binds @code\{parsep\} to\
its local value.  (@code\{parsep\} is a regular expression that matches\
what separates paragraphs.)\
\
But if @code\{fill-prefix-regexp\} does have a value, Emacs evaluates\
the then-part of the @code\{if\} expression and binds @code\{parsep\} to a\
regular expression that includes the @code\{fill-prefix-regexp\} as part\
of the pattern.\
\
Specifically, @code\{parsep\} is set to the original value of the\
paragraph separate regular expression concatenated with an alternative\
expression that consists of the @code\{fill-prefix-regexp\} followed by\
optional whitespace to the end of the line.  The whitespace is defined\
by @w\{@code\{"[ \\t]*$"\}\}.)  The @samp\{\\\\|\} defines this portion of the\
regexp as an alternative to @code\{parsep\}.\
\
According to a comment in the code, the next local variable,\
@code\{sp-parstart\}, is used for searching, and then the final two,\
@code\{start\} and @code\{found-start\}, are set to @code\{nil\}.\
\
Now we get into the body of the @code\{let*\}.  The first part of the body\
of the @code\{let*\} deals with the case when the function is given a\
negative argument and is therefore moving backwards.  We will skip this\
section.\
\
@node fwd-para while,  , fwd-para let, forward-paragraph\
@unnumberedsubsec The forward motion @code\{while\} loop\
\
The second part of the body of the @code\{let*\} deals with forward\
motion.  It is a @code\{while\} loop that repeats itself so long as the\
value of @code\{arg\} is greater than zero.  In the most common use of\
the function, the value of the argument is 1, so the body of the\
@code\{while\} loop is evaluated exactly once, and the cursor moves\
forward one paragraph.\
\
@ignore\
(while (and (> arg 0) (not (eobp)))\
\
  ;; Move forward over separator lines...\
  (while (and (not (eobp))\
              (progn (move-to-left-margin) (not (eobp)))\
              (looking-at parsep))\
    (forward-line 1))\
  (unless (eobp) (setq arg (1- arg)))\
  ;; ... and one more line.\
  (forward-line 1)\
\
  (if fill-prefix-regexp\
      ;; There is a fill prefix; it overrides parstart.\
      (while (and (not (eobp))\
                  (progn (move-to-left-margin) (not (eobp)))\
                  (not (looking-at parsep))\
                  (looking-at fill-prefix-regexp))\
        (forward-line 1))\
\
    (while (and (re-search-forward sp-parstart nil 1)\
                (progn (setq start (match-beginning 0))\
                       (goto-char start)\
                       (not (eobp)))\
                (progn (move-to-left-margin)\
                       (not (looking-at parsep)))\
                (or (not (looking-at parstart))\
                    (and use-hard-newlines\
                         (not (get-text-property (1- start) 'hard)))))\
      (forward-char 1))\
\
    (if (< (point) (point-max))\
        (goto-char start))))\
@end ignore\
\
This part handles three situations: when point is between paragraphs,\
when there is a fill prefix and when there is no fill prefix.\
\
@need 800\
The @code\{while\} loop looks like this:\
\
@smallexample\
@group\
;; @r\{going forwards and not at the end of the buffer\}\
(while (and (> arg 0) (not (eobp)))\
\
  ;; @r\{between paragraphs\}\
  ;; Move forward over separator lines...\
  (while (and (not (eobp))\
              (progn (move-to-left-margin) (not (eobp)))\
              (looking-at parsep))\
    (forward-line 1))\
  ;;  @r\{This decrements the loop\}\
  (unless (eobp) (setq arg (1- arg)))\
  ;; ... and one more line.\
  (forward-line 1)\
@end group\
\
@group\
  (if fill-prefix-regexp\
      ;; There is a fill prefix; it overrides parstart;\
      ;; we go forward line by line\
      (while (and (not (eobp))\
                  (progn (move-to-left-margin) (not (eobp)))\
                  (not (looking-at parsep))\
                  (looking-at fill-prefix-regexp))\
        (forward-line 1))\
@end group\
\
@group\
    ;; There is no fill prefix;\
    ;; we go forward character by character\
    (while (and (re-search-forward sp-parstart nil 1)\
                (progn (setq start (match-beginning 0))\
                       (goto-char start)\
                       (not (eobp)))\
                (progn (move-to-left-margin)\
                       (not (looking-at parsep)))\
                (or (not (looking-at parstart))\
                    (and use-hard-newlines\
                         (not (get-text-property (1- start) 'hard)))))\
      (forward-char 1))\
@end group\
\
@group\
    ;; and if there is no fill prefix and if we are not at the end,\
    ;;     go to whatever was found in the regular expression search\
    ;;     for sp-parstart\
    (if (< (point) (point-max))\
        (goto-char start))))\
@end group\
@end smallexample\
\
@findex eobp\
We can see that this is a decrementing counter @code\{while\} loop,\
using the expression @code\{(setq arg (1- arg))\} as the decrementer.\
That expression is not far from the @code\{while\}, but is hidden in\
another Lisp macro, an @code\{unless\} macro.  Unless we are at the end\
of the buffer --- that is what the @code\{eobp\} function determines; it\
is an abbreviation of @samp\{End Of Buffer P\} --- we decrease the value\
of @code\{arg\} by one.\
\
(If we are at the end of the buffer, we cannot go forward any more and\
the next loop of the @code\{while\} expression will test false since the\
test is an @code\{and\} with @code\{(not (eobp))\}.  The @code\{not\}\
function means exactly as you expect; it is another name for\
@code\{null\}, a function that returns true when its argument is false.)\
\
Interestingly, the loop count is not decremented until we leave the\
space between paragraphs, unless we come to the end of buffer or stop\
seeing the local value of the paragraph separator.\
\
That second @code\{while\} also has a @code\{(move-to-left-margin)\}\
expression.  The function is self-explanatory.  It is inside a\
@code\{progn\} expression and not the last element of its body, so it is\
only invoked for its side effect, which is to move point to the left\
margin of the current line.\
\
@findex looking-at\
The @code\{looking-at\} function is also self-explanatory; it returns\
true if the text after point matches the regular expression given as\
its argument.\
\
The rest of the body of the loop looks difficult at first, but makes\
sense as you come to understand it.\
\
@need 800\
First consider what happens if there is a fill prefix:\
\
@smallexample\
@group\
  (if fill-prefix-regexp\
      ;; There is a fill prefix; it overrides parstart;\
      ;; we go forward line by line\
      (while (and (not (eobp))\
                  (progn (move-to-left-margin) (not (eobp)))\
                  (not (looking-at parsep))\
                  (looking-at fill-prefix-regexp))\
        (forward-line 1))\
@end group\
@end smallexample\
\
@noindent\
This expression moves point forward line by line so long\
as four conditions are true:\
\
@enumerate\
@item\
Point is not at the end of the buffer.\
\
@item\
We can move to the left margin of the text and are\
not at the end of the buffer.\
\
@item\
The text following point does not separate paragraphs.\
\
@item\
The pattern following point is the fill prefix regular expression.\
@end enumerate\
\
The last condition may be puzzling, until you remember that point was\
moved to the beginning of the line early in the @code\{forward-paragraph\}\
function.  This means that if the text has a fill prefix, the\
@code\{looking-at\} function will see it.\
\
@need 1250\
Consider what happens when there is no fill prefix.\
\
@smallexample\
@group\
    (while (and (re-search-forward sp-parstart nil 1)\
                (progn (setq start (match-beginning 0))\
                       (goto-char start)\
                       (not (eobp)))\
                (progn (move-to-left-margin)\
                       (not (looking-at parsep)))\
                (or (not (looking-at parstart))\
                    (and use-hard-newlines\
                         (not (get-text-property (1- start) 'hard)))))\
      (forward-char 1))\
@end group\
@end smallexample\
\
@noindent\
This @code\{while\} loop has us searching forward for\
@code\{sp-parstart\}, which is the combination of possible whitespace\
with a the local value of the start of a paragraph or of a paragraph\
separator.  (The latter two are within an expression starting\
@code\{\\(?:\} so that they are not referenced by the\
@code\{match-beginning\} function.)\
\
@need 800\
The two expressions,\
\
@smallexample\
@group\
(setq start (match-beginning 0))\
(goto-char start)\
@end group\
@end smallexample\
\
@noindent\
mean go to the start of the text matched by the regular expression\
search.\
\
The @code\{(match-beginning 0)\} expression is new.  It returns a number\
specifying the location of the start of the text that was matched by\
the last search.\
\
The @code\{match-beginning\} function is used here because of a\
characteristic of a forward search: a successful forward search,\
regardless of whether it is a plain search or a regular expression\
search, moves point to the end of the text that is found.  In this\
case, a successful search moves point to the end of the pattern for\
@code\{sp-parstart\}.\
\
However, we want to put point at the end of the current paragraph, not\
somewhere else.  Indeed, since the search possibly includes the\
paragraph separator, point may end up at the beginning of the next one\
unless we use an expression that includes @code\{match-beginning\}.\
\
@findex match-beginning\
When given an argument of 0, @code\{match-beginning\} returns the\
position that is the start of the text matched by the most recent\
search.  In this case, the most recent search looks for\
@code\{sp-parstart\}.  The @code\{(match-beginning 0)\} expression returns\
the beginning position of that pattern, rather than the end position\
of that pattern.\
\
(Incidentally, when passed a positive number as an argument, the\
@code\{match-beginning\} function returns the location of point at that\
parenthesized expression in the last search unless that parenthesized\
expression begins with @code\{\\(?:\}.  I don't know why @code\{\\(?:\}\
appears here since the argument is 0.)\
\
@need 1250\
The last expression when there is no fill prefix is\
\
@smallexample\
@group\
(if (< (point) (point-max))\
    (goto-char start))))\
@end group\
@end smallexample\
\
@noindent\
This says that if there is no fill prefix and if we are not at the\
end, point should move to the beginning of whatever was found by the\
regular expression search for @code\{sp-parstart\}.\
\
The full definition for the @code\{forward-paragraph\} function not only\
includes code for going forwards, but also code for going backwards.\
\
If you are reading this inside of GNU Emacs and you want to see the\
whole function, you can type @kbd\{C-h f\} (@code\{describe-function\})\
and the name of the function.  This gives you the function\
documentation and the name of the library containing the function's\
source.  Place point over the name of the library and press the RET\
key; you will be taken directly to the source.  (Be sure to install\
your sources!  Without them, you are like a person who tries to drive\
a car with his eyes shut!)\
\
@node etags, Regexp Review, forward-paragraph, Regexp Search\
@section Create Your Own @file\{TAGS\} File\
@findex etags\
@cindex @file\{TAGS\} file, create own\
\
Besides @kbd\{C-h f\} (@code\{describe-function\}), another way to see the\
source of a function is to type @kbd\{M-.\} (@code\{find-tag\}) and the\
name of the function when prompted for it.  This is a good habit to\
get into.  The @kbd\{M-.\} (@code\{find-tag\}) command takes you directly\
to the source for a function, variable, or node.  The function depends\
on tags tables to tell it where to go.\
\
If the @code\{find-tag\} function first asks you for the name of a\
@file\{TAGS\} table, give it the name of a @file\{TAGS\} file such as\
@file\{/usr/local/src/emacs/src/TAGS\}.  (The exact path to your\
@file\{TAGS\} file depends on how your copy of Emacs was installed.  I\
just told you the location that provides both my C and my Emacs Lisp\
sources.)\
\
You can also create your own @file\{TAGS\} file for directories that\
lack one.\
\
You often need to build and install tags tables yourself.  They are\
not built automatically.  A tags table is called a @file\{TAGS\} file;\
the name is in upper case letters.\
\
You can create a @file\{TAGS\} file by calling the @code\{etags\} program\
that comes as a part of the Emacs distribution.  Usually, @code\{etags\}\
is compiled and installed when Emacs is built.  (@code\{etags\} is not\
an Emacs Lisp function or a part of Emacs; it is a C program.)\
\
@need 1250\
To create a @file\{TAGS\} file, first switch to the directory in which\
you want to create the file.  In Emacs you can do this with the\
@kbd\{M-x cd\} command, or by visiting a file in the directory, or by\
listing the directory with @kbd\{C-x d\} (@code\{dired\}).  Then run the\
compile command, with @w\{@code\{etags *.el\}\} as the command to execute\
\
@smallexample\
M-x compile RET etags *.el RET\
@end smallexample\
\
@noindent\
to create a @file\{TAGS\} file for Emacs Lisp.\
\
For example, if you have a large number of files in your\
@file\{~/emacs\} directory, as I do---I have 137 @file\{.el\} files in it,\
of which I load 12---you can create a @file\{TAGS\} file for the Emacs\
Lisp files in that directory.\
\
@need 1250\
The @code\{etags\} program takes all the usual shell `wildcards'.  For\
example, if you have two directories for which you want a single\
@file\{TAGS\} file, type @w\{@code\{etags *.el ../elisp/*.el\}\}, where\
@file\{../elisp/\} is the second directory:\
\
@smallexample\
M-x compile RET etags *.el ../elisp/*.el RET\
@end smallexample\
\
@need 1250\
Type\
\
@smallexample\
M-x compile RET etags --help RET\
@end smallexample\
\
@noindent\
to see a list of the options accepted by @code\{etags\} as well as a\
list of supported languages.\
\
The @code\{etags\} program handles more than 20 languages, including\
Emacs Lisp, Common Lisp, Scheme, C, C++, Ada, Fortran, HTML, Java,\
LaTeX, Pascal, Perl, Postscript, Python, TeX, Texinfo, makefiles, and\
most assemblers.  The program has no switches for specifying the\
language; it recognizes the language in an input file according to its\
file name and contents.\
\
@file\{etags\} is very helpful when you are writing code yourself and\
want to refer back to functions you have already written.  Just run\
@code\{etags\} again at intervals as you write new functions, so they\
become part of the @file\{TAGS\} file.\
\
If you think an appropriate @file\{TAGS\} file already exists for what\
you want, but do not know where it is, you can use the @code\{locate\}\
program to attempt to find it.\
\
Type @w\{@kbd\{M-x locate @key\{RET\} TAGS @key\{RET\}\}\} and Emacs will list\
for you the full path names of all your @file\{TAGS\} files.  On my\
system, this command lists 34 @file\{TAGS\} files.  On the other hand, a\
`plain vanilla' system I recently installed did not contain any\
@file\{TAGS\} files.\
\
If the tags table you want has been created, you can use the @code\{M-x\
visit-tags-table\} command to specify it.  Otherwise, you will need to\
create the tag table yourself and then use @code\{M-x\
visit-tags-table\}.\
\
@subsubheading Building Tags in the Emacs sources\
@cindex Building Tags in the Emacs sources\
@cindex Tags in the Emacs sources\
@findex make tags\
\
The GNU Emacs sources come with a @file\{Makefile\} that contains a\
sophisticated @code\{etags\} command that creates, collects, and merges\
tags tables from all over the Emacs sources and puts the information\
into one @file\{TAGS\} file in the @file\{src/\} directory. (The\
@file\{src/\} directory is below the top level of your Emacs directory.)\
\
@need 1250\
To build this @file\{TAGS\} file, go to the top level of your Emacs\
source directory and run the compile command @code\{make tags\}:\
\
@smallexample\
M-x compile RET make tags RET\
@end smallexample\
\
@noindent\
(The @code\{make tags\} command works well with the GNU Emacs sources,\
as well as with some other source packages.)\
\
For more information, see @ref\{Tags, , Tag Tables, emacs, The GNU Emacs\
Manual\}.\
\
@node Regexp Review, re-search Exercises, etags, Regexp Search\
@comment  node-name,  next,  previous,  up\
@section Review\
\
Here is a brief summary of some recently introduced functions.\
\
@table @code\
@item while\
Repeatedly evaluate the body of the expression so long as the first\
element of the body tests true.  Then return @code\{nil\}.  (The\
expression is evaluated only for its side effects.)\
\
@need 1250\
For example:\
\
@smallexample\
@group\
(let ((foo 2))\
  (while (> foo 0)\
    (insert (format "foo is %d.\\n" foo))\
    (setq foo (1- foo))))\
\
     @result\{\}      foo is 2.\
             foo is 1.\
             nil\
@end group\
@end smallexample\
\
@noindent\
(The @code\{insert\} function inserts its arguments at point; the\
@code\{format\} function returns a string formatted from its arguments\
the way @code\{message\} formats its arguments; @code\{\\n\} produces a new\
line.)\
\
@item re-search-forward\
Search for a pattern, and if the pattern is found, move point to rest\
just after it.\
\
@noindent\
Takes four arguments, like @code\{search-forward\}:\
\
@enumerate\
@item\
A regular expression that specifies the pattern to search for.\
(Remember to put quotation marks around this argument!)\
\
@item\
Optionally, the limit of the search.\
\
@item\
Optionally, what to do if the search fails, return @code\{nil\} or an\
error message.\
\
@item\
Optionally, how many times to repeat the search; if negative, the\
search goes backwards.\
@end enumerate\
\
@item let*\
Bind some variables locally to particular values,\
and then evaluate the remaining arguments, returning the value of the\
last one.  While binding the local variables, use the local values of\
variables bound earlier, if any.\
\
@need 1250\
For example:\
\
@smallexample\
@group\
(let* ((foo 7)\
      (bar (* 3 foo)))\
  (message "`bar' is %d." bar))\
     @result\{\} `bar' is 21.\
@end group\
@end smallexample\
\
@item match-beginning\
Return the position of the start of the text found by the last regular\
expression search.\
\
@item looking-at\
Return @code\{t\} for true if the text after point matches the argument,\
which should be a regular expression.\
\
@item eobp\
Return @code\{t\} for true if point is at the end of the accessible part\
of a buffer.  The end of the accessible part is the end of the buffer\
if the buffer is not narrowed; it is the end of the narrowed part if\
the buffer is narrowed.\
@end table\
\
@need 1500\
@node re-search Exercises,  , Regexp Review, Regexp Search\
@section Exercises with @code\{re-search-forward\}\
\
@itemize @bullet\
@item\
Write a function to search for a regular expression that matches two\
or more blank lines in sequence.\
\
@item\
Write a function to search for duplicated words, such as `the the'.\
@xref\{Regexps, , Syntax of Regular Expressions, emacs, The GNU Emacs\
Manual\}, for information on how to write a regexp (a regular\
expression) to match a string that is composed of two identical\
halves.  You can devise several regexps; some are better than others.\
The function I use is described in an appendix, along with several\
regexps.  @xref\{the-the, , @code\{the-the\} Duplicated Words Function\}.\
@end itemize}