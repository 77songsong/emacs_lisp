{\rtf1\ansi\ansicpg949\cocoartf1187\cocoasubrtf340
{\fonttbl\f0\fnil\fcharset129 AppleSDGothicNeo-Regular;}
{\colortbl;\red255\green255\blue255;}
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\fi360\sl288\slmult1\pardirnatural

\f0\fs28 \cf0 \
@node Buffer Walk Through, More Complex, Writing Defuns, Top\
@comment  node-name,  next,  previous,  up\
@chapter A Few Buffer--Related Functions\
\
In this chapter we study in detail several of the functions used in GNU\
Emacs.  This is called a ``walk-through''.  These functions are used as\
examples of Lisp code, but are not imaginary examples; with the\
exception of the first, simplified function definition, these functions\
show the actual code used in GNU Emacs.  You can learn a great deal from\
these definitions.  The functions described here are all related to\
buffers.  Later, we will study other functions.\
\
@menu\
* Finding More::                How to find more information.\
* simplified-beginning-of-buffer::  Shows @code\{goto-char\},\
                                @code\{point-min\}, and @code\{push-mark\}.\
* mark-whole-buffer::           Almost the same as @code\{beginning-of-buffer\}.\
* append-to-buffer::            Uses @code\{save-excursion\} and\
                                @code\{insert-buffer-substring\}.\
* Buffer Related Review::       Review.\
* Buffer Exercises::\
@end menu\
\
@node Finding More, simplified-beginning-of-buffer, Buffer Walk Through, Buffer Walk Through\
@section Finding More Information\
\
@findex describe-function, @r\{introduced\}\
@cindex Find function documentation\
In this walk-through, I will describe each new function as we come to\
it, sometimes in detail and sometimes briefly.  If you are interested,\
you can get the full documentation of any Emacs Lisp function at any\
time by typing @kbd\{C-h f\} and then the name of the function (and then\
@key\{RET\}).  Similarly, you can get the full documentation for a\
variable by typing @kbd\{C-h v\} and then the name of the variable (and\
then @key\{RET\}).\
\
@cindex Find source of function\
@c In version 22, tells location both of C and of Emacs Lisp\
Also, @code\{describe-function\} will tell you the location of the\
function definition.\
\
Put point into the name of the file that contains the function and\
press the @key\{RET\} key.  In this case, @key\{RET\} means\
@code\{push-button\} rather than `return' or `enter'.  Emacs will take\
you directly to the function definition.\
\
@ignore\
Not In version 22\
\
If you move point over the file name and press\
the @key\{RET\} key, which in this case means @code\{help-follow\} rather\
than `return' or `enter', Emacs will take you directly to the function\
definition.\
@end ignore\
\
More generally, if you want to see a function in its original source\
file, you can use the @code\{find-tag\} function to jump to it.\
@code\{find-tag\} works with a wide variety of languages, not just\
Lisp, and C, and it works with non-programming text as well.  For\
example, @code\{find-tag\} will jump to the various nodes in the\
Texinfo source file of this document.\
The @code\{find-tag\} function depends on `tags tables' that record\
the locations of the functions, variables, and other items to which\
@code\{find-tag\} jumps.\
\
To use the @code\{find-tag\} command, type @kbd\{M-.\}  (i.e., press the\
period key while holding down the @key\{META\} key, or else type the\
@key\{ESC\} key and then type the period key), and then, at the prompt,\
type in the name of the function whose source code you want to see,\
such as @code\{mark-whole-buffer\}, and then type @key\{RET\}.  Emacs will\
switch buffers and display the source code for the function on your\
screen.  To switch back to your current buffer, type @kbd\{C-x b\
@key\{RET\}\}.  (On some keyboards, the @key\{META\} key is labelled\
@key\{ALT\}.)\
\
@c !!! 22.1.1 tags table location in this paragraph\
@cindex TAGS table, specifying\
@findex find-tag\
Depending on how the initial default values of your copy of Emacs are\
set, you may also need to specify the location of your `tags table',\
which is a file called @file\{TAGS\}.  For example, if you are\
interested in Emacs sources, the tags table you will most likely want,\
if it has already been created for you, will be in a subdirectory of\
the @file\{/usr/local/share/emacs/\} directory; thus you would use the\
@code\{M-x visit-tags-table\} command and specify a pathname such as\
@file\{/usr/local/share/emacs/22.1.1/lisp/TAGS\}.  If the tags table\
has not already been created, you will have to create it yourself.  It\
will be in a file such as @file\{/usr/local/src/emacs/src/TAGS\}.\
\
@need 1250\
To create a @file\{TAGS\} file in a specific directory, switch to that\
directory in Emacs using @kbd\{M-x cd\} command, or list the directory\
with @kbd\{C-x d\} (@code\{dired\}).  Then run the compile command, with\
@w\{@code\{etags *.el\}\} as the command to execute:\
\
@smallexample\
M-x compile RET etags *.el RET\
@end smallexample\
\
For more information, see @ref\{etags, , Create Your Own @file\{TAGS\} File\}.\
\
After you become more familiar with Emacs Lisp, you will find that you will\
frequently use @code\{find-tag\} to navigate your way around source code;\
and you will create your own @file\{TAGS\} tables.\
\
@cindex Library, as term for `file'\
Incidentally, the files that contain Lisp code are conventionally\
called @dfn\{libraries\}.  The metaphor is derived from that of a\
specialized library, such as a law library or an engineering library,\
rather than a general library.  Each library, or file, contains\
functions that relate to a particular topic or activity, such as\
@file\{abbrev.el\} for handling abbreviations and other typing\
shortcuts, and @file\{help.el\} for on-line help.  (Sometimes several\
libraries provide code for a single activity, as the various\
@file\{rmail@dots\{\}\} files provide code for reading electronic mail.)\
In @cite\{The GNU Emacs Manual\}, you will see sentences such as ``The\
@kbd\{C-h p\} command lets you search the standard Emacs Lisp libraries\
by topic keywords.''\
\
@node simplified-beginning-of-buffer, mark-whole-buffer, Finding More, Buffer Walk Through\
@comment  node-name,  next,  previous,  up\
@section A Simplified @code\{beginning-of-buffer\} Definition\
@findex simplified-beginning-of-buffer\
\
The @code\{beginning-of-buffer\} command is a good function to start with\
since you are likely to be familiar with it and it is easy to\
understand.  Used as an interactive command, @code\{beginning-of-buffer\}\
moves the cursor to the beginning of the buffer, leaving the mark at the\
previous position.  It is generally bound to @kbd\{M-<\}.\
\
In this section, we will discuss a shortened version of the function\
that shows how it is most frequently used.  This shortened function\
works as written, but it does not contain the code for a complex option.\
In another section, we will describe the entire function.\
(@xref\{beginning-of-buffer, , Complete Definition of\
@code\{beginning-of-buffer\}\}.)\
\
Before looking at the code, let's consider what the function\
definition has to contain: it must include an expression that makes\
the function interactive so it can be called by typing @kbd\{M-x\
beginning-of-buffer\} or by typing a keychord such as @kbd\{M-<\}; it\
must include code to leave a mark at the original position in the\
buffer; and it must include code to move the cursor to the beginning\
of the buffer.\
\
@need 1250\
Here is the complete text of the shortened version of the function:\
\
@smallexample\
@group\
(defun simplified-beginning-of-buffer ()\
  "Move point to the beginning of the buffer;\
leave mark at previous position."\
  (interactive)\
  (push-mark)\
  (goto-char (point-min)))\
@end group\
@end smallexample\
\
Like all function definitions, this definition has five parts following\
the special form @code\{defun\}:\
\
@enumerate\
@item\
The name: in this example, @code\{simplified-beginning-of-buffer\}.\
\
@item\
A list of the arguments: in this example, an empty list, @code\{()\},\
\
@item\
The documentation string.\
\
@item\
The interactive expression.\
\
@item\
The body.\
@end enumerate\
\
@noindent\
In this function definition, the argument list is empty; this means that\
this function does not require any arguments.  (When we look at the\
definition for the complete function, we will see that it may be passed\
an optional argument.)\
\
The interactive expression tells Emacs that the function is intended to\
be used interactively.  In this example, @code\{interactive\} does not have\
an argument because @code\{simplified-beginning-of-buffer\} does not\
require one.\
\
@need 800\
The body of the function consists of the two lines:\
\
@smallexample\
@group\
(push-mark)\
(goto-char (point-min))\
@end group\
@end smallexample\
\
The first of these lines is the expression, @code\{(push-mark)\}.  When\
this expression is evaluated by the Lisp interpreter, it sets a mark at\
the current position of the cursor, wherever that may be.  The position\
of this mark is saved in the mark ring.\
\
The next line is @code\{(goto-char (point-min))\}.  This expression\
jumps the cursor to the minimum point in the buffer, that is, to the\
beginning of the buffer (or to the beginning of the accessible portion\
of the buffer if it is narrowed.  @xref\{Narrowing & Widening, ,\
Narrowing and Widening\}.)\
\
The @code\{push-mark\} command sets a mark at the place where the cursor\
was located before it was moved to the beginning of the buffer by the\
@code\{(goto-char (point-min))\} expression.  Consequently, you can, if\
you wish, go back to where you were originally by typing @kbd\{C-x C-x\}.\
\
That is all there is to the function definition!\
\
@findex describe-function\
When you are reading code such as this and come upon an unfamiliar\
function, such as @code\{goto-char\}, you can find out what it does by\
using the @code\{describe-function\} command.  To use this command, type\
@kbd\{C-h f\} and then type in the name of the function and press\
@key\{RET\}.  The @code\{describe-function\} command will print the\
function's documentation string in a @file\{*Help*\} window.  For\
example, the documentation for @code\{goto-char\} is:\
\
@smallexample\
@group\
Set point to POSITION, a number or marker.\
Beginning of buffer is position (point-min), end is (point-max).\
@end group\
@end smallexample\
\
@noindent\
The function's one argument is the desired position.\
\
@noindent\
(The prompt for @code\{describe-function\} will offer you the symbol\
under or preceding the cursor, so you can save typing by positioning\
the cursor right over or after the function and then typing @kbd\{C-h f\
@key\{RET\}\}.)\
\
The @code\{end-of-buffer\} function definition is written in the same way as\
the @code\{beginning-of-buffer\} definition except that the body of the\
function contains the expression @code\{(goto-char (point-max))\} in place\
of @code\{(goto-char (point-min))\}.\
\
@node mark-whole-buffer, append-to-buffer, simplified-beginning-of-buffer, Buffer Walk Through\
@comment  node-name,  next,  previous,  up\
@section The Definition of @code\{mark-whole-buffer\}\
@findex mark-whole-buffer\
\
The @code\{mark-whole-buffer\} function is no harder to understand than the\
@code\{simplified-beginning-of-buffer\} function.  In this case, however,\
we will look at the complete function, not a shortened version.\
\
The @code\{mark-whole-buffer\} function is not as commonly used as the\
@code\{beginning-of-buffer\} function, but is useful nonetheless: it\
marks a whole buffer as a region by putting point at the beginning and\
a mark at the end of the buffer.  It is generally bound to @kbd\{C-x\
h\}.\
\
@menu\
* mark-whole-buffer overview::\
* Body of mark-whole-buffer::   Only three lines of code.\
@end menu\
\
@node mark-whole-buffer overview, Body of mark-whole-buffer, mark-whole-buffer, mark-whole-buffer\
@ifnottex\
@unnumberedsubsec An overview of @code\{mark-whole-buffer\}\
@end ifnottex\
\
@need 1250\
In GNU Emacs 22, the code for the complete function looks like this:\
\
@smallexample\
@group\
(defun mark-whole-buffer ()\
  "Put point at beginning and mark at end of buffer.\
You probably should not use this function in Lisp programs;\
it is usually a mistake for a Lisp function to use any subroutine\
that uses or sets the mark."\
  (interactive)\
  (push-mark (point))\
  (push-mark (point-max) nil t)\
  (goto-char (point-min)))\
@end group\
@end smallexample\
\
@need 1250\
Like all other functions, the @code\{mark-whole-buffer\} function fits\
into the template for a function definition.  The template looks like\
this:\
\
@smallexample\
@group\
(defun @var\{name-of-function\} (@var\{argument-list\})\
  "@var\{documentation\}@dots\{\}"\
  (@var\{interactive-expression\}@dots\{\})\
  @var\{body\}@dots\{\})\
@end group\
@end smallexample\
\
Here is how the function works: the name of the function is\
@code\{mark-whole-buffer\}; it is followed by an empty argument list,\
@samp\{()\}, which means that the function does not require arguments.\
The documentation comes next.\
\
The next line is an @code\{(interactive)\} expression that tells Emacs\
that the function will be used interactively.  These details are similar\
to the @code\{simplified-beginning-of-buffer\} function described in the\
previous section.\
\
@need 1250\
@node Body of mark-whole-buffer,  , mark-whole-buffer overview, mark-whole-buffer\
@comment  node-name,  next,  previous,  up\
@subsection Body of @code\{mark-whole-buffer\}\
\
The body of the @code\{mark-whole-buffer\} function consists of three\
lines of code:\
\
@c GNU Emacs 22\
@smallexample\
@group\
(push-mark (point))\
(push-mark (point-max) nil t)\
(goto-char (point-min))\
@end group\
@end smallexample\
\
The first of these lines is the expression, @code\{(push-mark (point))\}.\
\
This line does exactly the same job as the first line of the body of\
the @code\{simplified-beginning-of-buffer\} function, which is written\
@code\{(push-mark)\}.  In both cases, the Lisp interpreter sets a mark\
at the current position of the cursor.\
\
I don't know why the expression in @code\{mark-whole-buffer\} is written\
@code\{(push-mark (point))\} and the expression in\
@code\{beginning-of-buffer\} is written @code\{(push-mark)\}.  Perhaps\
whoever wrote the code did not know that the arguments for\
@code\{push-mark\} are optional and that if @code\{push-mark\} is not\
passed an argument, the function automatically sets mark at the\
location of point by default.  Or perhaps the expression was written\
so as to parallel the structure of the next line.  In any case, the\
line causes Emacs to determine the position of point and set a mark\
there.\
\
In earlier versions of GNU Emacs, the next line of\
@code\{mark-whole-buffer\} was @code\{(push-mark (point-max))\}.  This\
expression sets a mark at the point in the buffer that has the highest\
number.  This will be the end of the buffer (or, if the buffer is\
narrowed, the end of the accessible portion of the buffer.\
@xref\{Narrowing & Widening, , Narrowing and Widening\}, for more about\
narrowing.)  After this mark has been set, the previous mark, the one\
set at point, is no longer set, but Emacs remembers its position, just\
as all other recent marks are always remembered.  This means that you\
can, if you wish, go back to that position by typing @kbd\{C-u\
C-@key\{SPC\}\} twice.\
\
@need 1250\
In GNU Emacs 22, the @code\{(point-max)\} is slightly more complicated.\
The line reads\
\
@smallexample\
(push-mark (point-max) nil t)\
@end smallexample\
\
@noindent\
The expression works nearly the same as before.  It sets a mark at the\
highest numbered place in the buffer that it can.  However, in this\
version, @code\{push-mark\} has two additional arguments.  The second\
argument to @code\{push-mark\} is @code\{nil\}.  This tells the function\
it @emph\{should\} display a message that says `Mark set' when it pushes\
the mark.  The third argument is @code\{t\}.  This tells\
@code\{push-mark\} to activate the mark when Transient Mark mode is\
turned on.  Transient Mark mode highlights the currently active\
region.  It is often turned off.\
\
Finally, the last line of the function is @code\{(goto-char\
(point-min)))\}.  This is written exactly the same way as it is written\
in @code\{beginning-of-buffer\}.  The expression moves the cursor to\
the minimum point in the buffer, that is, to the beginning of the buffer\
(or to the beginning of the accessible portion of the buffer).  As a\
result of this, point is placed at the beginning of the buffer and mark\
is set at the end of the buffer.  The whole buffer is, therefore, the\
region.\
\
@node append-to-buffer, Buffer Related Review, mark-whole-buffer, Buffer Walk Through\
@comment  node-name,  next,  previous,  up\
@section The Definition of @code\{append-to-buffer\}\
@findex append-to-buffer\
\
The @code\{append-to-buffer\} command is more complex than the\
@code\{mark-whole-buffer\} command.  What it does is copy the region\
(that is, the part of the buffer between point and mark) from the\
current buffer to a specified buffer.\
\
@menu\
* append-to-buffer overview::\
* append interactive::          A two part interactive expression.\
* append-to-buffer body::       Incorporates a @code\{let\} expression.\
* append save-excursion::       How the @code\{save-excursion\} works.\
@end menu\
\
@node append-to-buffer overview, append interactive, append-to-buffer, append-to-buffer\
@ifnottex\
@unnumberedsubsec An Overview of @code\{append-to-buffer\}\
@end ifnottex\
\
@findex insert-buffer-substring\
The @code\{append-to-buffer\} command uses the\
@code\{insert-buffer-substring\} function to copy the region.\
@code\{insert-buffer-substring\} is described by its name: it takes a\
string of characters from part of a buffer, a ``substring'', and\
inserts them into another buffer.\
\
Most of @code\{append-to-buffer\} is\
concerned with setting up the conditions for\
@code\{insert-buffer-substring\} to work: the code must specify both the\
buffer to which the text will go, the window it comes from and goes\
to, and the region that will be copied.\
\
@need 1250\
Here is the complete text of the function:\
\
@smallexample\
@group\
(defun append-to-buffer (buffer start end)\
  "Append to specified buffer the text of the region.\
It is inserted into that buffer before its point.\
@end group\
\
@group\
When calling from a program, give three arguments:\
BUFFER (or buffer name), START and END.\
START and END specify the portion of the current buffer to be copied."\
  (interactive\
   (list (read-buffer "Append to buffer: " (other-buffer\
                                            (current-buffer) t))\
         (region-beginning) (region-end)))\
@end group\
@group\
  (let ((oldbuf (current-buffer)))\
    (save-excursion\
      (let* ((append-to (get-buffer-create buffer))\
             (windows (get-buffer-window-list append-to t t))\
             point)\
        (set-buffer append-to)\
        (setq point (point))\
        (barf-if-buffer-read-only)\
        (insert-buffer-substring oldbuf start end)\
        (dolist (window windows)\
          (when (= (window-point window) point)\
            (set-window-point window (point))))))))\
@end group\
@end smallexample\
\
The function can be understood by looking at it as a series of\
filled-in templates.\
\
The outermost template is for the function definition.  In this\
function, it looks like this (with several slots filled in):\
\
@smallexample\
@group\
(defun append-to-buffer (buffer start end)\
  "@var\{documentation\}@dots\{\}"\
  (interactive @dots\{\})\
  @var\{body\}@dots\{\})\
@end group\
@end smallexample\
\
The first line of the function includes its name and three arguments.\
The arguments are the @code\{buffer\} to which the text will be copied, and\
the @code\{start\} and @code\{end\} of the region in the current buffer that\
will be copied.\
\
The next part of the function is the documentation, which is clear and\
complete.  As is conventional, the three arguments are written in\
upper case so you will notice them easily.  Even better, they are\
described in the same order as in the argument list.\
\
Note that the documentation distinguishes between a buffer and its\
name.  (The function can handle either.)\
\
@node append interactive, append-to-buffer body, append-to-buffer overview, append-to-buffer\
@comment  node-name,  next,  previous,  up\
@subsection The @code\{append-to-buffer\} Interactive Expression\
\
Since the @code\{append-to-buffer\} function will be used interactively,\
the function must have an @code\{interactive\} expression.  (For a\
review of @code\{interactive\}, see @ref\{Interactive, , Making a\
Function Interactive\}.)  The expression reads as follows:\
\
@smallexample\
@group\
(interactive\
 (list (read-buffer\
        "Append to buffer: "\
        (other-buffer (current-buffer) t))\
       (region-beginning)\
       (region-end)))\
@end group\
@end smallexample\
\
@noindent\
This expression is not one with letters standing for parts, as\
described earlier.  Instead, it starts a list with these parts:\
\
The first part of the list is an expression to read the name of a\
buffer and return it as a string.  That is @code\{read-buffer\}.  The\
function requires a prompt as its first argument, @samp\{"Append to\
buffer: "\}.  Its second argument tells the command what value to\
provide if you don't specify anything.\
\
In this case that second argument is an expression containing the\
function @code\{other-buffer\}, an exception, and a @samp\{t\}, standing\
for true.\
\
The first argument to @code\{other-buffer\}, the exception, is yet\
another function, @code\{current-buffer\}.  That is not going to be\
returned.  The second argument is the symbol for true, @code\{t\}. that\
tells @code\{other-buffer\} that it may show visible buffers (except in\
this case, it will not show the current buffer, which makes sense).\
\
@need 1250\
The expression looks like this:\
\
@smallexample\
(other-buffer (current-buffer) t)\
@end smallexample\
\
The second and third arguments to the @code\{list\} expression are\
@code\{(region-beginning)\} and @code\{(region-end)\}.  These two\
functions specify the beginning and end of the text to be appended.\
\
@need 1250\
Originally, the command used the letters @samp\{B\} and @samp\{r\}.\
The whole @code\{interactive\} expression looked like this:\
\
@smallexample\
(interactive "BAppend to buffer:@: \\nr")\
@end smallexample\
\
@noindent\
But when that was done, the default value of the buffer switched to\
was invisible.  That was not wanted.\
\
(The prompt was separated from the second argument with a newline,\
@samp\{\\n\}.  It was followed by an @samp\{r\} that told Emacs to bind the\
two arguments that follow the symbol @code\{buffer\} in the function's\
argument list (that is, @code\{start\} and @code\{end\}) to the values of\
point and mark.  That argument worked fine.)\
\
@node append-to-buffer body, append save-excursion, append interactive, append-to-buffer\
@comment  node-name,  next,  previous,  up\
@subsection The Body of @code\{append-to-buffer\}\
\
@ignore\
in GNU Emacs 22   in    /usr/local/src/emacs/lisp/simple.el\
\
(defun append-to-buffer (buffer start end)\
  "Append to specified buffer the text of the region.\
It is inserted into that buffer before its point.\
\
When calling from a program, give three arguments:\
BUFFER (or buffer name), START and END.\
START and END specify the portion of the current buffer to be copied."\
  (interactive\
   (list (read-buffer "Append to buffer: " (other-buffer (current-buffer) t))\
         (region-beginning) (region-end)))\
  (let ((oldbuf (current-buffer)))\
    (save-excursion\
      (let* ((append-to (get-buffer-create buffer))\
             (windows (get-buffer-window-list append-to t t))\
             point)\
        (set-buffer append-to)\
        (setq point (point))\
        (barf-if-buffer-read-only)\
        (insert-buffer-substring oldbuf start end)\
        (dolist (window windows)\
          (when (= (window-point window) point)\
            (set-window-point window (point))))))))\
@end ignore\
\
The body of the @code\{append-to-buffer\} function begins with @code\{let\}.\
\
As we have seen before (@pxref\{let, , @code\{let\}\}), the purpose of a\
@code\{let\} expression is to create and give initial values to one or\
more variables that will only be used within the body of the\
@code\{let\}.  This means that such a variable will not be confused with\
any variable of the same name outside the @code\{let\} expression.\
\
We can see how the @code\{let\} expression fits into the function as a\
whole by showing a template for @code\{append-to-buffer\} with the\
@code\{let\} expression in outline:\
\
@smallexample\
@group\
(defun append-to-buffer (buffer start end)\
  "@var\{documentation\}@dots\{\}"\
  (interactive @dots\{\})\
  (let ((@var\{variable\} @var\{value\}))\
        @var\{body\}@dots\{\})\
@end group\
@end smallexample\
\
The @code\{let\} expression has three elements:\
\
@enumerate\
@item\
The symbol @code\{let\};\
\
@item\
A varlist containing, in this case, a single two-element list,\
@code\{(@var\{variable\} @var\{value\})\};\
\
@item\
The body of the @code\{let\} expression.\
@end enumerate\
\
@need 800\
In the @code\{append-to-buffer\} function, the varlist looks like this:\
\
@smallexample\
(oldbuf (current-buffer))\
@end smallexample\
\
@noindent\
In this part of the @code\{let\} expression, the one variable,\
@code\{oldbuf\}, is bound to the value returned by the\
@code\{(current-buffer)\} expression.  The variable, @code\{oldbuf\}, is\
used to keep track of the buffer in which you are working and from\
which you will copy.\
\
The element or elements of a varlist are surrounded by a set of\
parentheses so the Lisp interpreter can distinguish the varlist from\
the body of the @code\{let\}.  As a consequence, the two-element list\
within the varlist is surrounded by a circumscribing set of parentheses.\
The line looks like this:\
\
@smallexample\
@group\
(let ((oldbuf (current-buffer)))\
  @dots\{\} )\
@end group\
@end smallexample\
\
@noindent\
The two parentheses before @code\{oldbuf\} might surprise you if you did\
not realize that the first parenthesis before @code\{oldbuf\} marks the\
boundary of the varlist and the second parenthesis marks the beginning\
of the two-element list, @code\{(oldbuf (current-buffer))\}.\
\
@node append save-excursion,  , append-to-buffer body, append-to-buffer\
@comment  node-name,  next,  previous,  up\
@subsection @code\{save-excursion\} in @code\{append-to-buffer\}\
\
The body of the @code\{let\} expression in @code\{append-to-buffer\}\
consists of a @code\{save-excursion\} expression.\
\
The @code\{save-excursion\} function saves the locations of point and\
mark, and restores them to those positions after the expressions in the\
body of the @code\{save-excursion\} complete execution.  In addition,\
@code\{save-excursion\} keeps track of the original buffer, and\
restores it.  This is how @code\{save-excursion\} is used in\
@code\{append-to-buffer\}.\
\
@need 1500\
@cindex Indentation for formatting\
@cindex Formatting convention\
Incidentally, it is worth noting here that a Lisp function is normally\
formatted so that everything that is enclosed in a multi-line spread is\
indented more to the right than the first symbol.  In this function\
definition, the @code\{let\} is indented more than the @code\{defun\}, and\
the @code\{save-excursion\} is indented more than the @code\{let\}, like\
this:\
\
@smallexample\
@group\
(defun @dots\{\}\
  @dots\{\}\
  @dots\{\}\
  (let@dots\{\}\
    (save-excursion\
      @dots\{\}\
@end group\
@end smallexample\
\
@need 1500\
@noindent\
This formatting convention makes it easy to see that the lines in\
the body of the @code\{save-excursion\} are enclosed by the parentheses\
associated with @code\{save-excursion\}, just as the\
@code\{save-excursion\} itself is enclosed by the parentheses associated\
with the @code\{let\}:\
\
@smallexample\
@group\
(let ((oldbuf (current-buffer)))\
  (save-excursion\
    @dots\{\}\
    (set-buffer @dots\{\})\
    (insert-buffer-substring oldbuf start end)\
    @dots\{\}))\
@end group\
@end smallexample\
\
@need 1200\
The use of the @code\{save-excursion\} function can be viewed as a process\
of filling in the slots of a template:\
\
@smallexample\
@group\
(save-excursion\
  @var\{first-expression-in-body\}\
  @var\{second-expression-in-body\}\
   @dots\{\}\
  @var\{last-expression-in-body\})\
@end group\
@end smallexample\
\
@need 1200\
@noindent\
In this function, the body of the @code\{save-excursion\} contains only\
one expression, the @code\{let*\} expression.  You know about a\
@code\{let\} function.  The @code\{let*\} function is different.  It has a\
@samp\{*\} in its name.  It enables Emacs to set each variable in its\
varlist in sequence, one after another.\
\
Its critical feature is that variables later in the varlist can make\
use of the values to which Emacs set variables earlier in the varlist.\
@xref\{fwd-para let, , The @code\{let*\} expression\}.\
\
We will skip functions like @code\{let*\} and focus on two: the\
@code\{set-buffer\} function and the @code\{insert-buffer-substring\}\
function.\
\
@need 1250\
In the old days, the @code\{set-buffer\} expression was simply\
\
@smallexample\
(set-buffer (get-buffer-create buffer))\
@end smallexample\
\
@need 1250\
@noindent\
but now it is\
\
@smallexample\
(set-buffer append-to)\
@end smallexample\
\
@noindent\
@code\{append-to\} is bound to @code\{(get-buffer-create buffer)\} earlier\
on in the @code\{let*\} expression.  That extra binding would not be\
necessary except for that @code\{append-to\} is used later in the\
varlist as an argument to @code\{get-buffer-window-list\}.\
\
@ignore\
in GNU Emacs 22\
\
  (let ((oldbuf (current-buffer)))\
    (save-excursion\
      (let* ((append-to (get-buffer-create buffer))\
             (windows (get-buffer-window-list append-to t t))\
             point)\
        (set-buffer append-to)\
        (setq point (point))\
        (barf-if-buffer-read-only)\
        (insert-buffer-substring oldbuf start end)\
        (dolist (window windows)\
          (when (= (window-point window) point)\
            (set-window-point window (point))))))))\
@end ignore\
\
The @code\{append-to-buffer\} function definition inserts text from the\
buffer in which you are currently to a named buffer.  It happens that\
@code\{insert-buffer-substring\} copies text from another buffer to the\
current buffer, just the reverse---that is why the\
@code\{append-to-buffer\} definition starts out with a @code\{let\} that\
binds the local symbol @code\{oldbuf\} to the value returned by\
@code\{current-buffer\}.\
\
@need 1250\
The @code\{insert-buffer-substring\} expression looks like this:\
\
@smallexample\
(insert-buffer-substring oldbuf start end)\
@end smallexample\
\
@noindent\
The @code\{insert-buffer-substring\} function copies a string\
@emph\{from\} the buffer specified as its first argument and inserts the\
string into the present buffer.  In this case, the argument to\
@code\{insert-buffer-substring\} is the value of the variable created\
and bound by the @code\{let\}, namely the value of @code\{oldbuf\}, which\
was the current buffer when you gave the @code\{append-to-buffer\}\
command.\
\
After @code\{insert-buffer-substring\} has done its work,\
@code\{save-excursion\} will restore the action to the original buffer\
and @code\{append-to-buffer\} will have done its job.\
\
@need 800\
Written in skeletal form, the workings of the body look like this:\
\
@smallexample\
@group\
(let (@var\{bind-\}@code\{oldbuf\}@var\{-to-value-of-\}@code\{current-buffer\})\
  (save-excursion                       ; @r\{Keep track of buffer.\}\
    @var\{change-buffer\}\
    @var\{insert-substring-from-\}@code\{oldbuf\}@var\{-into-buffer\})\
\
  @var\{change-back-to-original-buffer-when-finished\}\
@var\{let-the-local-meaning-of-\}@code\{oldbuf\}@var\{-disappear-when-finished\}\
@end group\
@end smallexample\
\
In summary, @code\{append-to-buffer\} works as follows: it saves the\
value of the current buffer in the variable called @code\{oldbuf\}.  It\
gets the new buffer (creating one if need be) and switches Emacs'\
attention to it.  Using the value of @code\{oldbuf\}, it inserts the\
region of text from the old buffer into the new buffer; and then using\
@code\{save-excursion\}, it brings you back to your original buffer.\
\
In looking at @code\{append-to-buffer\}, you have explored a fairly\
complex function.  It shows how to use @code\{let\} and\
@code\{save-excursion\}, and how to change to and come back from another\
buffer.  Many function definitions use @code\{let\},\
@code\{save-excursion\}, and @code\{set-buffer\} this way.\
\
@node Buffer Related Review, Buffer Exercises, append-to-buffer, Buffer Walk Through\
@comment  node-name,  next,  previous,  up\
@section Review\
\
Here is a brief summary of the various functions discussed in this chapter.\
\
@table @code\
@item describe-function\
@itemx describe-variable\
Print the documentation for a function or variable.\
Conventionally bound to @kbd\{C-h f\} and @kbd\{C-h v\}.\
\
@item find-tag\
Find the file containing the source for a function or variable and\
switch buffers to it, positioning point at the beginning of the item.\
Conventionally bound to @kbd\{M-.\} (that's a period following the\
@key\{META\} key).\
\
@item save-excursion\
Save the location of point and mark and restore their values after the\
arguments to @code\{save-excursion\} have been evaluated.  Also, remember\
the current buffer and return to it.\
\
@item push-mark\
Set mark at a location and record the value of the previous mark on the\
mark ring.  The mark is a location in the buffer that will keep its\
relative position even if text is added to or removed from the buffer.\
\
@item goto-char\
Set point to the location specified by the value of the argument, which\
can be a number, a marker,  or an expression that returns the number of\
a position, such as @code\{(point-min)\}.\
\
@item insert-buffer-substring\
Copy a region of text from a buffer that is passed to the function as\
an argument and insert the region into the current buffer.\
\
@item mark-whole-buffer\
Mark the whole buffer as a region.  Normally bound to @kbd\{C-x h\}.\
\
@item set-buffer\
Switch the attention of Emacs to another buffer, but do not change the\
window being displayed.  Used when the program rather than a human is\
to work on a different buffer.\
\
@item get-buffer-create\
@itemx get-buffer\
Find a named buffer or create one if a buffer of that name does not\
exist.  The @code\{get-buffer\} function returns @code\{nil\} if the named\
buffer does not exist.\
@end table\
\
@need 1500\
@node Buffer Exercises,  , Buffer Related Review, Buffer Walk Through\
@section Exercises\
\
@itemize @bullet\
@item\
Write your own @code\{simplified-end-of-buffer\} function definition;\
then test it to see whether it works.\
\
@item\
Use @code\{if\} and @code\{get-buffer\} to write a function that prints a\
message telling you whether a buffer exists.\
\
@item\
Using @code\{find-tag\}, find the source for the @code\{copy-to-buffer\}\
function.\
@end itemize}