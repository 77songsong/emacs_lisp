\input texinfo                                      @c -*-texinfo-*-
@comment %**start of header
@setfilename ../../info/eintr
@c setfilename emacs-lisp-intro.info
@c sethtmlfilename emacs-lisp-intro.html
@settitle Programming in Emacs Lisp
@syncodeindex vr cp
@syncodeindex fn cp
@finalout

@c ---------
@c <<<< For hard copy printing, this file is now
@c      set for smallbook, which works for all sizes
@c      of paper, and with Postscript figures >>>>
@set smallbook
@ifset smallbook
@smallbook
@clear  largebook
@end ifset
@set print-postscript-figures
@c set largebook
@c clear print-postscript-figures
@c ---------

@comment %**end of header

@c per rms and peterb, use 10pt fonts for the main text, mostly to
@c save on paper cost.
@c Do this inside @tex for now, so current makeinfo does not complain.
@tex
@ifset smallbook
@fonttextsize 10

@end ifset
\global\hbadness=6666 % don't worry about not-too-underfull boxes
@end tex

@set edition-number 3.10
@set update-date 28 October 2009

@ignore
 ## Summary of shell commands to create various output formats:

    pushd /usr/local/src/emacs/lispintro/
    ## pushd /u/intro/

    ## Info output
    makeinfo --paragraph-indent=0 --verbose emacs-lisp-intro.texi

      ## ;; (progn (when (bufferp (get-buffer "*info*")) (kill-buffer "*info*")) (info "/usr/local/src/emacs/info/eintr"))

    ## DVI output
    texi2dvi emacs-lisp-intro.texi

      ## xdvi -margins 24pt -topmargin 4pt -offsets 24pt -geometry 760x1140 -s 5 -useTeXpages -mousemode 1 emacs-lisp-intro.dvi &

    ## HTML output
    makeinfo --html --no-split --verbose emacs-lisp-intro.texi

      ## galeon emacs-lisp-intro.html

    ## Plain text output
    makeinfo --fill-column=70 --no-split --paragraph-indent=0 \
    --verbose --no-headers --output=emacs-lisp-intro.txt emacs-lisp-intro.texi

    popd

# as user `root'
# insert thumbdrive
  mtusb       #   mount -v -t ext3 /dev/sda /mnt
  cp -v /u/intro/emacs-lisp-intro.texi /mnt/backup/intro/emacs-lisp-intro.texi
  umtusb      #   umount -v /mnt
# remove thumbdrive

    ## Other shell commands

    pushd /usr/local/src/emacs/lispintro/
    ## pushd /u/intro/

    ## PDF
    texi2dvi --pdf emacs-lisp-intro.texi
       # xpdf emacs-lisp-intro.pdf &

    ## DocBook                    -- note file extension
    makeinfo --docbook --no-split --paragraph-indent=0 \
    --verbose --output=emacs-lisp-intro.docbook emacs-lisp-intro.texi

    ## XML with a Texinfo DTD     -- note file extension
    makeinfo --xml --no-split --paragraph-indent=0 \
    --verbose --output=emacs-lisp-intro.texinfoxml emacs-lisp-intro.texi

    ## PostScript (needs DVI)
        #     gv emacs-lisp-intro.ps &
        # Create DVI if we lack it
        # texi2dvi emacs-lisp-intro.texi
    dvips emacs-lisp-intro.dvi -o emacs-lisp-intro.ps

    ## RTF (needs HTML)
        # Use OpenOffice to view RTF
        # Create HTML if we lack it
        # makeinfo --no-split --html emacs-lisp-intro.texi
    /usr/local/src/html2rtf.pl emacs-lisp-intro.html

    ## LaTeX (needs RTF)
    /usr/bin/rtf2latex emacs-lisp-intro.rtf

    popd

@end ignore

@c ================ Included Figures ================

@c Set  print-postscript-figures  if you print PostScript figures.
@c If you clear this, the ten figures will be printed as ASCII diagrams.
@c (This is not relevant to Info, since Info only handles ASCII.)
@c Your site may require editing changes to print PostScript; in this
@c case, search for `print-postscript-figures' and make appropriate changes.

@c ================ How to Create an Info file ================

@c If you have `makeinfo' installed, run the following command

@c     makeinfo emacs-lisp-intro.texi

@c or, if you want a single, large Info file, and no paragraph indents:
@c     makeinfo --no-split --paragraph-indent=0 --verbose emacs-lisp-intro.texi

@c After creating the Info file, edit your Info `dir' file, if the
@c `dircategory' section below does not enable your system to
@c install the manual automatically.
@c (The `dir' file is often in the `/usr/local/share/info/' directory.)

@c ================ How to Create an HTML file ================

@c To convert to HTML format
@c     makeinfo --html --no-split --verbose emacs-lisp-intro.texi

@c ================ How to Print a Book in Various Sizes ================

@c This book can be printed in any of three different sizes.
@c In the above header, set @-commands appropriately.

@c     7 by 9.25 inches:
@c              @smallbook
@c              @clear largebook

@c     8.5 by 11 inches:
@c              @c smallbook
@c              @set largebook

@c     European A4 size paper:
@c              @c smallbook
@c              @afourpaper
@c              @set largebook

@c ================ How to Typeset and Print ================

@c If you do not include PostScript figures, run either of the
@c following command sequences, or similar commands suited to your
@c system:

@c     texi2dvi emacs-lisp-intro.texi
@c     lpr -d emacs-lisp-intro.dvi

@c or else:

@c     tex emacs-lisp-intro.texi
@c     texindex emacs-lisp-intro.??
@c     tex emacs-lisp-intro.texi
@c     lpr -d emacs-lisp-intro.dvi

@c If you include the PostScript figures, and you have old software,
@c you may need to convert the .dvi file to a .ps file before
@c printing.  Run either of the following command sequences, or one
@c similar:
@c
@c     dvips -f < emacs-lisp-intro.dvi > emacs-lisp-intro.ps
@c
@c or else:
@c
@c     postscript -p < emacs-lisp-intro.dvi > emacs-lisp-intro.ps
@c

@c (Note: if you edit the book so as to change the length of the
@c table of contents, you may have to change the value of `pageno' below.)

@c ================ End of Formatting Sections ================

@c For next or subsequent edition:
@c   create function using with-output-to-temp-buffer
@c   create a major mode, with keymaps
@c   run an asynchronous process, like grep or diff

@c For 8.5 by 11 inch format: do not use such a small amount of
@c whitespace between paragraphs as smallbook format
@ifset largebook
@tex
\global\parskip 6pt plus 1pt
@end tex
@end ifset

@c For all sized formats:  print within-book cross
@c reference with ``...''  rather than [...]

@c This works with the texinfo.tex file, version 2003-05-04.08,
@c in the Texinfo version 4.6 of the 2003 Jun 13 distribution.

@tex
\if \xrefprintnodename
 \global\def\xrefprintnodename#1{\unskip, ``#1''}
 \else
 \global\def\xrefprintnodename#1{ ``#1''}
\fi
% \global\def\xrefprintnodename#1{, ``#1''}
@end tex

@c ----------------------------------------------------

@dircategory Emacs
@direntry
* Emacs Lisp Intro: (eintr).
                          A simple introduction to Emacs Lisp programming.
@end direntry

@copying
This is an @cite{Introduction to Programming in Emacs Lisp}, for
people who are not programmers.
@sp 1
Edition @value{edition-number}, @value{update-date}
@sp 1
Copyright @copyright{} 1990, 1991, 1992, 1993, 1994, 1995, 1997, 2001,
   2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010
   Free Software Foundation, Inc.
@sp 1

@iftex
Published by the:@*

GNU Press,                      @hfill  @uref{http://www.gnupress.org}@*
a division of the               @hfill General: @email{press@@gnu.org}@*
Free Software Foundation, Inc.  @hfill Orders:@w{ }  @email{sales@@gnu.org}@*
51 Franklin Street, Fifth Floor @hfill Tel: +1 (617) 542-5942@*
Boston, MA 02110-1301 USA       @hfill Fax: +1 (617) 542-2652@*
@end iftex

@ifnottex
Published by the:

@example
GNU Press,                          Website: http://www.gnupress.org
a division of the                   General: press@@gnu.org
Free Software Foundation, Inc.      Orders:  sales@@gnu.org
51 Franklin Street, Fifth Floor     Tel: +1 (617) 542-5942
Boston, MA 02110-1301 USA           Fax: +1 (617) 542-2652
@end example
@end ifnottex

@sp 1
@c Printed copies are available for $30 each.@*
ISBN 1-882114-43-4

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; there
being no Invariant Section, with the Front-Cover Texts being ``A GNU
Manual'', and with the Back-Cover Texts as in (a) below.  A copy of
the license is included in the section entitled ``GNU Free
Documentation License''.

(a) The FSF's Back-Cover Text is: ``You have the freedom to
copy and modify this GNU manual.  Buying copies from the FSF
supports it in developing GNU and promoting software freedom.''
@end copying

@c half title; two lines here, so do not use `shorttitlepage'
@tex
{\begingroup%
    \hbox{}\vskip 1.5in \chaprm \centerline{An Introduction to}%
        \endgroup}%
{\begingroup\hbox{}\vskip 0.25in \chaprm%
        \centerline{Programming in Emacs Lisp}%
        \endgroup\page\hbox{}\page}
@end tex

@titlepage
@sp 6
@center @titlefont{An Introduction to}
@sp 2
@center @titlefont{Programming in Emacs Lisp}
@sp 2
@center Revised Third Edition
@sp 4
@center by Robert J. Chassell

@page
@vskip 0pt plus 1filll
@insertcopying
@end titlepage

@iftex
@headings off
@evenheading @thispage @| @| @thischapter
@oddheading @thissection @| @| @thispage
@end iftex

@ifnothtml
@c     Keep T.O.C. short by tightening up for largebook
@ifset largebook
@tex
\global\parskip 2pt plus 1pt
\global\advance\baselineskip by -1pt
@end tex
@end ifset
@end ifnothtml

@shortcontents
@contents

@ifnottex
@node Top, 서문, (dir), (dir)
@top An Introduction to Programming in Emacs Lisp

@insertcopying

This master menu first lists each chapter and index; then it lists
every node in every chapter.
@end ifnottex

@c >>>> Set pageno appropriately <<<<

@c The first page of the Preface is a roman numeral; it is the first
@c right handed page after the Table of Contents; hence the following
@c setting must be for an odd negative number.

@c iftex
@c global@pageno = -11
@c end iftex

@menu
* 서문::                     What to look for.
* List 처리하기::             What is Lisp?
* 평가 연습하기::       Running several programs.
* Writing Defuns::              함수 정의 작성 방법.
* Buffer Walk Through::         Exploring a few buffer-related functions.
* More Complex::                A few, even more complex functions.
* Narrowing & Widening::        Restricting your and Emacs attention to
                                    a region.
* car cdr & cons::              Fundamental functions in Lisp.
* Cutting & Storing Text::      Removing text and saving it.
* List Implementation::         How lists are implemented in the computer.
* Yanking::                     Pasting stored text.
* Loops & Recursion::           How to repeat a process.
* Regexp Search::               Regular expression searches.
* Counting Words::              A review of repetition and regexps.
* Words in a defun::            Counting words in a @code{defun}.
* Readying a Graph::            A prototype graph printing function.
* Emacs Initialization::        How to write a @file{.emacs} file.
* Debugging::                   How to run the Emacs Lisp debuggers.
* Conclusion::                  Now you have the basics.
* the-the::                     An appendix: how to find reduplicated words.
* Kill Ring::                   An appendix: how the kill ring works.
* Full Graph::                  How to create a graph with labelled axes.
* Free Software and Free Manuals::
* GNU Free Documentation License::
* Index::
* About the Author::

@detailmenu
 --- The Detailed Node Listing ---

서문

* 왜::                         Emacs Lisp을 왜 배우는가?
* 이 책 읽기에 대해::        읽고, 친숙해지고, 습관을 들여라....
* 대상 독자::                 누구를 위한 문서.
* Lisp 역사::
* 초보자를 위한 노트::            초보자도 읽을 수 있다.
* 감사합니다.::

List 처리하기

* Lisp에서 List::                  list는 무엇인가?
* 프로그램 실행하기::               Lisp에서 list는 실행할 준비가 된 프로그램이다.
* 에러 만들기::               에러 메시지 만들기.
* 이름과 정의::         기호 이름들과 함수 정의들.
* Lisp Interpreter::            Lisp 해석기가 하는 일.
* 평가하기::                  프로그램 실행.
* Variables::                   변수로부터 값을 넘겨 받기.
* 인자들::                   함수에 정보 넘기기.
* set & setq::                  변수에 값 설정하기.
* 정리::                     중요한 점들.
* Error Message Exercises::

Lisp에서 List

* 숫자와 List::               List는 숫자, List를 가진다
* Lisp Atoms::                  기본적인 요소들.
* List에서 공백 문자::         읽기 쉽게 List 형식 갖추기.
* List 입력하기::                GNU Emacs는 List 입력을 돕는 방법.

Lisp 해석기

* Complications::               Variables, Special forms, Lists within.
* Byte Compiling::              Specially processing code for speed.

평가하기

* 해석기가 동작하는 방식::    Returns and Side Effects...
* 내부 list 평가하기::      Lists within lists...

Variables

* fill-column Example::
* Void Function::               The error message for a symbol
                                  without a function.
* Void Variable::               The error message for a symbol without a value.

인자들

* Data types::                  Types of data passed to a function.
* Args as Variable or List::    An argument can be the value
                                  of a variable or list.
* 여러 개의 인자들::  Some functions may take a
                                  variable number of arguments.
* Wrong Type of Argument::      Passing an argument of the wrong type
                                  to a function.
* message::                     A useful function for sending messages.

변수에 값 설정하기

* set 사용하기::                  값 설정하기.
* setq 사용하기::                 따옴표 붙은 값 설정하기.
* 숫자 세기::                   숫자 세기에 @code{setq}를 사용하기.

평가 연습하기

* How to Evaluate::            Typing editing commands or @kbd{C-x C-e}
                                 causes evaluation.
* 버퍼 이름::               Buffers and files are different.
* 버퍼 얻기::            Getting a buffer itself, not merely its name.
* 버퍼 변경하기::          How to change to another buffer.
* 버퍼 크기와 위치::    Where point is located and the size of
                               the buffer.
* 연습문제 평가::

함수 정의 작성 방법

* Primitive Functions::
* defun::                        특별한 형식 @code{defun}.
* Install::                     함수 정의 설치하기.
* Interactive::                  Making a function interactive.
* Interactive Options::          Different options for @code{interactive}.
* Permanent Installation::       Installing code permanently.
* let::                          Creating and initializing local variables.
* if::                           What if?
* else::                         If--then--else expressions.
* Truth & Falsehood::            What Lisp considers false and true.
* save-excursion::               Keeping track of point, mark, and buffer.
* Review::
* defun Exercises::

Install a Function Definition

* Effect of installation::
* Change a defun::              How to change a function definition.

Make a Function Interactive

* Interactive multiply-by-seven::  An overview.
* multiply-by-seven in detail::    The interactive version.

@code{let}

* Prevent confusion::
* Parts of let Expression::
* Sample let Expression::
* Uninitialized let Variables::

The @code{if} Special Form

* if in more detail::
* type-of-animal in detail::    An example of an @code{if} expression.

Truth and Falsehood in Emacs Lisp

* nil explained::               @code{nil} has two meanings.

@code{save-excursion}

* Point and mark::              A review of various locations.
* Template for save-excursion::

A Few Buffer--Related Functions

* Finding More::                How to find more information.
* simplified-beginning-of-buffer::  Shows @code{goto-char},
                                @code{point-min}, and @code{push-mark}.
* mark-whole-buffer::           Almost the same as @code{beginning-of-buffer}.
* append-to-buffer::            Uses @code{save-excursion} and
                                @code{insert-buffer-substring}.
* Buffer Related Review::       Review.
* Buffer Exercises::

The Definition of @code{mark-whole-buffer}

* mark-whole-buffer overview::
* Body of mark-whole-buffer::   Only three lines of code.

The Definition of @code{append-to-buffer}

* append-to-buffer overview::
* append interactive::          A two part interactive expression.
* append-to-buffer body::       Incorporates a @code{let} expression.
* append save-excursion::       How the @code{save-excursion} works.

A Few More Complex Functions

* copy-to-buffer::              With @code{set-buffer}, @code{get-buffer-create}.
* insert-buffer::               Read-only, and with @code{or}.
* beginning-of-buffer::         Shows @code{goto-char},
                                @code{point-min}, and @code{push-mark}.
* Second Buffer Related Review::
* optional Exercise::

The Definition of @code{insert-buffer}

* insert-buffer code::
* insert-buffer interactive::   When you can read, but not write.
* insert-buffer body::          The body has an @code{or} and a @code{let}.
* if & or::                     Using an @code{if} instead of an @code{or}.
* Insert or::                   How the @code{or} expression works.
* Insert let::                  Two @code{save-excursion} expressions.
* New insert-buffer::

The Interactive Expression in @code{insert-buffer}

* Read-only buffer::            When a buffer cannot be modified.
* b for interactive::           An existing buffer or else its name.

Complete Definition of @code{beginning-of-buffer}

* Optional Arguments::
* beginning-of-buffer opt arg::  Example with optional argument.
* beginning-of-buffer complete::

@code{beginning-of-buffer} with an Argument

* Disentangle beginning-of-buffer::
* Large buffer case::
* Small buffer case::

Narrowing and Widening

* Narrowing advantages::        The advantages of narrowing
* save-restriction::            The @code{save-restriction} special form.
* what-line::                   The number of the line that point is on.
* narrow Exercise::

@code{car}, @code{cdr}, @code{cons}: Fundamental Functions

* Strange Names::               An historical aside: why the strange names?
* car & cdr::                   Functions for extracting part of a list.
* cons::                        Constructing a list.
* nthcdr::                      Calling @code{cdr} repeatedly.
* nth::
* setcar::                      Changing the first element of a list.
* setcdr::                      Changing the rest of a list.
* cons Exercise::

@code{cons}

* Build a list::
* length::                      How to find the length of a list.

Cutting and Storing Text

* Storing Text::                Text is stored in a list.
* zap-to-char::                 Cutting out text up to a character.
* kill-region::                 Cutting text out of a region.
* copy-region-as-kill::         A definition for copying text.
* Digression into C::           Minor note on C programming language macros.
* defvar::                      How to give a variable an initial value.
* cons & search-fwd Review::
* search Exercises::

@code{zap-to-char}

* Complete zap-to-char::        The complete implementation.
* zap-to-char interactive::     A three part interactive expression.
* zap-to-char body::            A short overview.
* search-forward::              How to search for a string.
* progn::                       The @code{progn} special form.
* Summing up zap-to-char::      Using @code{point} and @code{search-forward}.

@code{kill-region}

* Complete kill-region::        The function definition.
* condition-case::              Dealing with a problem.
* Lisp macro::

@code{copy-region-as-kill}

* Complete copy-region-as-kill::  The complete function definition.
* copy-region-as-kill body::      The body of @code{copy-region-as-kill}.

The Body of @code{copy-region-as-kill}

* last-command & this-command::
* kill-append function::
* kill-new function::

Initializing a Variable with @code{defvar}

* See variable current value::
* defvar and asterisk::

How Lists are Implemented

* Lists diagrammed::
* Symbols as Chest::            Exploring a powerful metaphor.
* List Exercise::

Yanking Text Back

* Kill Ring Overview::
* kill-ring-yank-pointer::      The kill ring is a list.
* yank nthcdr Exercises::       The @code{kill-ring-yank-pointer} variable.

Loops and Recursion

* while::                       Causing a stretch of code to repeat.
* dolist dotimes::
* Recursion::                   Causing a function to call itself.
* Looping exercise::

@code{while}

* Looping with while::          Repeat so long as test returns true.
* Loop Example::                A @code{while} loop that uses a list.
* print-elements-of-list::      Uses @code{while}, @code{car}, @code{cdr}.
* Incrementing Loop::           A loop with an incrementing counter.
* Incrementing Loop Details::
* Decrementing Loop::           A loop with a decrementing counter.

Details of an Incrementing Loop

* Incrementing Example::        Counting pebbles in a triangle.
* Inc Example parts::           The parts of the function definition.
* Inc Example altogether::      Putting the function definition together.

Loop with a Decrementing Counter

* Decrementing Example::        More pebbles on the beach.
* Dec Example parts::           The parts of the function definition.
* Dec Example altogether::      Putting the function definition together.

Save your time: @code{dolist} and @code{dotimes}

* dolist::
* dotimes::

Recursion

* Building Robots::             Same model, different serial number ...
* Recursive Definition Parts::  Walk until you stop ...
* Recursion with list::         Using a list as the test whether to recurse.
* Recursive triangle function::
* Recursion with cond::
* Recursive Patterns::          Often used templates.
* No Deferment::                Don't store up work ...
* No deferment solution::

Recursion in Place of a Counter

* Recursive Example arg of 1 or 2::
* Recursive Example arg of 3 or 4::

Recursive Patterns

* Every::
* Accumulate::
* Keep::

Regular Expression Searches

* sentence-end::                The regular expression for @code{sentence-end}.
* re-search-forward::           Very similar to @code{search-forward}.
* forward-sentence::            A straightforward example of regexp search.
* forward-paragraph::           A somewhat complex example.
* etags::                       How to create your own @file{TAGS} table.
* Regexp Review::
* re-search Exercises::

@code{forward-sentence}

* Complete forward-sentence::
* fwd-sentence while loops::    Two @code{while} loops.
* fwd-sentence re-search::      A regular expression search.

@code{forward-paragraph}: a Goldmine of Functions

* forward-paragraph in brief::  Key parts of the function definition.
* fwd-para let::                The @code{let*} expression.
* fwd-para while::              The forward motion @code{while} loop.

Counting: Repetition and Regexps

* Why Count Words::
* count-words-region::          Use a regexp, but find a problem.
* recursive-count-words::       Start with case of no words in region.
* Counting Exercise::

The @code{count-words-region} Function

* Design count-words-region::   The definition using a @code{while} loop.
* Whitespace Bug::              The Whitespace Bug in @code{count-words-region}.

Counting Words in a @code{defun}

* Divide and Conquer::
* Words and Symbols::           What to count?
* Syntax::                      What constitutes a word or symbol?
* count-words-in-defun::        Very like @code{count-words}.
* Several defuns::              Counting several defuns in a file.
* Find a File::                 Do you want to look at a file?
* lengths-list-file::           A list of the lengths of many definitions.
* Several files::               Counting in definitions in different files.
* Several files recursively::   Recursively counting in different files.
* Prepare the data::            Prepare the data for display in a graph.

Count Words in @code{defuns} in Different Files

* lengths-list-many-files::     Return a list of the lengths of defuns.
* append::                      Attach one list to another.

Prepare the Data for Display in a Graph

* Data for Display in Detail::
* Sorting::                     Sorting lists.
* Files List::                  Making a list of files.
* Counting function definitions::

Readying a Graph

* Columns of a graph::
* graph-body-print::            How to print the body of a graph.
* recursive-graph-body-print::
* Printed Axes::
* Line Graph Exercise::

Your @file{.emacs} File

* Default Configuration::
* Site-wide Init::              You can write site-wide init files.
* defcustom::                   Emacs will write code for you.
* Beginning a .emacs File::     How to write a @code{.emacs file}.
* Text and Auto-fill::          Automatically wrap lines.
* Mail Aliases::                Use abbreviations for email addresses.
* Indent Tabs Mode::            Don't use tabs with @TeX{}
* Keybindings::                 Create some personal keybindings.
* Keymaps::                     More about key binding.
* Loading Files::               Load (i.e., evaluate) files automatically.
* Autoload::                    Make functions available.
* Simple Extension::            Define a function; bind it to a key.
* X11 Colors::                  Colors in X.
* Miscellaneous::
* Mode Line::                   How to customize your mode line.

Debugging

* debug::                       How to use the built-in debugger.
* debug-on-entry::              Start debugging when you call a function.
* debug-on-quit::               Start debugging when you quit with @kbd{C-g}.
* edebug::                      How to use Edebug, a source level debugger.
* Debugging Exercises::

Handling the Kill Ring

* What the Kill Ring Does::
* current-kill::
* yank::                        Paste a copy of a clipped element.
* yank-pop::                    Insert element pointed to.
* ring file::

The @code{current-kill} Function

* Code for current-kill::
* Understanding current-kill::

@code{current-kill} in Outline

* Body of current-kill::
* Digression concerning error::  How to mislead humans, but not computers.
* Determining the Element::

A Graph with Labelled Axes

* Labelled Example::
* print-graph Varlist::         @code{let} expression in @code{print-graph}.
* print-Y-axis::                Print a label for the vertical axis.
* print-X-axis::                Print a horizontal label.
* Print Whole Graph::           The function to print a complete graph.

The @code{print-Y-axis} Function

* print-Y-axis in Detail::
* Height of label::             What height for the Y axis?
* Compute a Remainder::         How to compute the remainder of a division.
* Y Axis Element::              Construct a line for the Y axis.
* Y-axis-column::               Generate a list of Y axis labels.
* print-Y-axis Penultimate::    A not quite final version.

The @code{print-X-axis} Function

* Similarities differences::    Much like @code{print-Y-axis}, but not exactly.
* X Axis Tic Marks::            Create tic marks for the horizontal axis.

Printing the Whole Graph

* The final version::           A few changes.
* Test print-graph::            Run a short test.
* Graphing words in defuns::    Executing the final code.
* lambda::                      How to write an anonymous function.
* mapcar::                      Apply a function to elements of a list.
* Another Bug::                 Yet another bug @dots{} most insidious.
* Final printed graph::         The graph itself!

@end detailmenu
@end menu


@node 서문, List 처리하기, Top, Top
@comment  node-name,  next,  previous,  up
@unnumbered 서문

GNU Emacs 통합 환경의 대부분은 Emacs Lisp이라는 프로그래밍 언어로 만들어졌다. 이
프로그래밍 언어로 작성된 코드는 컴퓨터가 무엇을 해야 하는지 말해주는 소프트웨어 --- 
명령들의 집합들 --- 이다. Emacs Lisp으로 새로운 코드를 작성할 수 있고, 편집기의 확장으로
쉽게 설치될 수 있게 Emacs는 설계되었다.

( 때때로 GNU Emacs는 “확장 가능한 편집기”로 불리지만 편집 능력 이상을 한다. “확장 가능한 컴퓨팅 환경”으로 언급되는 것이 더 맞다. 그러나, 저 문구는 꽤 어려운 말이다. 단순히 편집기로  Emacs가 언급되는 것이 더 쉽다. 게다가 Emacs에서 하는 모든 것은 --- 마야 날짜와 달의 위상 찾기, 다항식 풀기, 코드 디버깅, 파일 관리, 편지 읽기, 책 읽기 --- 가장 일반적인 의미에서 편집의 종류이다. )

@menu
* 왜::                         Emacs Lisp을 왜 배우는가?
* 이 책 읽기에 대해::        읽고, 친숙해지고, 습관을 들여라....
* 대상 독자::                 누구를 위한 문서.
* Lisp 역사::
* 초보자를 위한 노트::            초보자도 읽을 수 있다.
* 감사합니다.::
@end menu


@node 왜, 이 책 읽기에 대해, 서문, 서문
@ifnottex
@unnumberedsec Emacs Lisp을 왜 배우는가?
@end ifnottex

Emacs Lisp이 오직 Emacs와 관련된 것으로 대개 생각하지만, Emacs Lisp은 완전한 컴퓨터
프로그래밍 언어다. 다른 프로그래밍 언어처럼 Emacs Lisp을 사용할 수 있다.

아마도 프로그래밍을 이해하고 싶어할 것이다.; 아마도 Emacs를 확장하기를 원할 것이다.; 또는 아마도 프로그래머가 되기를 원할 것이다. Emacs Lisp에 대한 소개는 시작하기 위해 설계되었다.: 프로그래밍의 기본을 배우게 안내하고, 더 중요한 것은 앞으로 자신에게 가르칠 수 있는 방법을 보여주는 것이다.


@node 이 책 읽기에 대해, 대상 독자, 왜, 서문
@comment  node-name,  next,  previous,  up
@unnumberedsec 이 책 읽기에 대해

이 문서에서 Emacs에 실행할 수 있는 작은 샘플 프로그램들을 볼 수 있다. GNU Emacs 안에서 
이 문서를 읽는다면, 보이는 것 처럼 프로그램들을 수행할 수 있다. ( 이 것은 쉽고, 예제가 나올 때
설명할 것이다. ) 아니면 Emacs가 수행되는 컴퓨터 옆에 앉아서 출력 된 책으로 이 소개를 읽을 
수 있다. ( 이 것은 내가 좋아하는 방법이다.; 출력 된 책을 좋아한다. ) 옆에서 Emacs를 수행할 
수 없더라도 여전히 이 책을 읽을 수 있다. 그러나 이 경우에는 소설이나 아직 방문하지 않은 
나라에 대한 여행 가이드를 읽는 것처럼 하는 것이 제일 좋다.; 흥미로움은 차이가 없다.

이 소개의 대부분은 GNU Emacs에서 사용되는 코드의 길잡이 여행 또는 자세한 설명에 
집중한다. 이 여행에는 두 가지 목적이 있다. 첫 번째는 실제로 동작하는 코드에 익숙함을 준다. 
( 매일 사용하는 코드 ); 그리고 두 번재는 Emacs가 동작하는 방식에 익숙함을 주는 것이다. 
동작하는 환경이 어떻게 구현되어있는지 보는 것은 흥미롭다. 또한 소스 코드를 살펴보는 습관을 
얻기를 희망한다. 소스 코드로부터 배울 수 있고 생각들을 얻을 수 있다. GNU Emacs를 얻는 
것은 용의 보물 동굴을 얻는 것과 같다.

편집기로 Emacs와 프로그래밍 언어로 Emacs Lisp을 배우는 것 뿐만 아니라, 예제들과 길잡이 
여행은 Lisp 프로그래밍 환경으로 Emacs를 알 수 있는 기회를 줄 것이다. GNU Emacs는 
프로그래밍을 지원하고 @kbd{M-.} ( @code{find-tag} 명령을 실행하는 키 ) 같이 사용하면 
편안할 도구들을 제공한다. 버퍼와 환경의 부분인 다른 객체들도 배울 것이다. Emacs의 이런 
특징들을 배우는 것은 집 주변에 새로운 길을 배우는 것과 같다.

@ignore
In addition, I have written several programs as extended examples.
Although these are examples, the programs are real.  I use them.
Other people use them.  You may use them.  Beyond the fragments of
programs used for illustrations, there is very little in here that is
`just for teaching purposes'; what you see is used.  This is a great
advantage of Emacs Lisp: it is easy to learn to use it for work.
@end ignore

마지막으로 모르는 프로그래밍의 양상을 배우기 위해 Emacs를 사용하는 몇 가지 기술을 전달할 
것이다. 당혹스럽게 만드는 것을 이해하는데 도움을 주거나 새로운 것을 하는 방법을 찾기위해 
종종 Emacs 사용할 수 있다. 자기 의존은 기쁨일 뿐만 아니라 장점이기도 하다.



@node 대상 독자, Lisp 역사, 이 책 읽기에 대해, 서문
@comment  node-name,  next,  previous,  up
@unnumberedsec 대상 독자

이 글은 프로그래머가 아닌 사람들을 위해서 쉽고 간단한 소개로서 쓰여졌다. 프로그래머라면 
입문서로 만족하지 않을 수 있다. 참고 설명서들을 읽는 것에 전문가이고 이 글이 구성된 방식에 
흥미가 없는 것이 이유이다.

전문적인 프로그래머가 이 글을 보고 이렇게 이야기 했다.:

@quotation
@i{ 나는 참고 설명서들로부터 배우는 것을 선호한다. 나는 각 절에 “빠져 들었고”, 각 절 중간에
 “수면으로 나왔다”. }

@i{ 각 절의 끝에 도달했을 때, 다뤄지는 주제는 완료되었고 내가 필요한 모든 것을 안다고 
추정했다. ( 다음 절에서 그 주제에 대해서 보다 자세한 것을 이야기하면서 시작할 때 그 경우의 
가능한 예외로 ). 많은 중복을 갖지 않는 잘 쓰여진 참고 설명서와 내가 원하는 정보들이 모여있는 
장소에 대한 좋은 위치 표시를 가지고 있을 것으로 기대했다.  }
@end quotation

이 소개는 이런 사람을 위해서 쓰여지지 않았다!

첫 번째로 적어도 세 번에 모든 것을 이야기 하려고 했다.: 소개하는 것이 처음; 문맥에서 
보여주는 것이 두 번째; 그리고 다른 문맥에서 보여주거나 복습하는 것이 세 번째이다.

두 번째로 한 절보다 작은 한 장소에 어떤 주제에 대한 모든 정보를 좀처럼 놓지 않았다. 독자에게 
너무 무거운 부담을 부과하는 것으로 생각한다. 대신 단지 그 때 알아야 할 것을 설명하고자 했다. 
( 때로는 추가 정보가 공식적으로 소개 될 때, 나중에 놀라지 않게 약간의 추가 정보를 포함했다. )

이 글을 읽을 때, 처음에 모든 것을 배우기를 기대 하지 마라. 말하자면 언급된 몇 가지 항목에 대한  
‘어설픈 지식’ 으로 할 만할 정도이다 . 글을 구조화했고 무엇이 중요하고 무엇에 집중해야 하는지 
경고하는 충분한 힌트를 제공하는 것이 희망이다.

몇 단락에 “빠져 들” 필요가 있을 것이다.; 그 것을 읽는 다른 방법은 없다. 그러나 그런 단락들을 
적게 하려고 노력했다. 이 책은 부담스러운 산 보다 접근하기 쉬운 언덕처럼 의도했다.

@cite{Programming in Emacs Lisp} 소개는 자매 문서를 가지고 있다.
@iftex
@cite{The GNU Emacs Lisp Reference Manual}.
@end iftex
@ifnottex
@ref{Top, , The GNU Emacs Lisp Reference Manual, elisp, The GNU
Emacs Lisp Reference Manual}.
@end ifnottex
참고 설명서는 이 소개보다 더욱 세세한 내용을 가지고 있다. 참고 설명서에서 하나의 주제에 대한 
모든 정보는 한 장소에 집중되어 있다. 위에 인용한 프로그래머라면 이 것에 의지할 것이다. 그리고 
물론 이 @cite{Introduction}을 읽은 후에는 자신의 프로그램을 작성할 때, @cite{Reference 
Manual}을 유용하게 찾을 것이다.


@node Lisp 역사, 초보자를 위한 노트, 대상 독자, 서문
@unnumberedsec Lisp 역사
@cindex Lisp 역사

Lisp은 1950년대 말에 인공 지능 연구를 위해 MIT에서 처음으로 개발되었다. Lisp 언어의 큰
힘은 통합 환경과 편집기 명령을 작성하는 것 뿐만 아니라 다른 목적들에도 우수하다는 것이다.

@cindex Maclisp
@cindex Common Lisp
GNU Emacs Lisp 은 1960년대에 MIT에서 만든 Maclisp에 가장 큰 영향을 받았다.  1980년대에 표준이 된 Common Lisp에도 다소 영향을 받았다. 그러나, Emacs Lisp은 Common Lisp보다 많이 단순하다. ( 표준 Emacs 배포판은 Emacs Lisp에 많은 Common Lisp의 특징을 추가하는 선택적인 확장 파일 @file{cl.el}을 포함하고 있다. )



@node 초보자를 위한 노트, 감사합니다., Lisp 역사, 서문
@comment  node-name,  next,  previous,  up
@unnumberedsec 초보자를 위한 노트

GNU Emacs를 모르더라도, 여전히 이 문서를 유익하게 읽을 수 있다. 그러나, 컴퓨터 
화면 주위만 움직이는 것만을 배우고자 한다면 Emacs를 배우는 것을 추천한다. 온라인 교재를 
통해 Emacs 사용법을 스스로 익힐 수 있다. 온라인 사용 교재를 쓰기 위해서 @kbd{C-h t}를 
눌러라.  ( 이 것은 동시에 @key{CTRL} 와 @kbd{h} 를 눌렀다 땐 후 @kbd{t}를 눌렀다 때는 
것을 의미한다.)

@kbd{M-C-\} (@code{indent-region}) 처럼 명령 키와 괄호 안에 명령의 이름의 목록을 
통해서 Emacs의 표준 명령들의 하나를 종종 참조한다. 이는 @code{indent-region} 명령은 
@kbd{M-C-\} 입력에 의해서 관례 상 불려지는 것을 나타낸다. ( 원한다면 명령을 부르는 
키들을 변경할 수 있다.; 이 것은 @dfn{rebinding}이라 부른다. 
@xref{Keymaps, ,Keymaps}. ) 축약어 @kbd{M-C-\} 은 @key{META} 키, 
@key{CTRL} 키 그리고 @key{\} 키를 모두 같은 시간에 눌러야한다는 것을 의미한다. ( 많은 
현대 키보드들에서 @key{META} 키는 @key{ALT} 키이다. ) 피아노에서 코드를 연주하는
방식과 비슷하기 때문에 이 같은 조합을 키 코드라고 부르기도 한다. 키보드에 @key{META} 
키가 없다면, @key{ESC} 키가 앞에 쓰여진다. 이 경우에 @kbd{M-C-\} 는 @key{ESC} 키를 
눌렀다 땐 후, @key{CTRL} 키 와 @key{\} 키를 동시에 누른다. 그러나 보통 @kbd{M-C-\}은 
@key{CTRL} 키와 @key{ALT} 키 그리고 @key{\} 키를 동시에 누르는 것을 의미한다.

하나의 키 코드 입력 뿐만 아니라 ‘보편적 인자”로 불리는 @kbd{C-u}를 먼저 입력할 수 있다. 
@kbd{C-u} 키 코드는 인자를 다음 명령에 전달한다. 공백 6개 만큼 텍스트의 공간을 들여쓰기 
한다면 지역을 표시하고 @w{@kbd{C-u 6 M-C-\}}를 입력한다. ( 숫자를 명시하지 않는다면 
명령에 숫자 4를 넘기거나 다르게 동작한다. ) @xref{Arguments, ,Numeric Arguments, 
emacs, The GNU Emacs Manual}.

GNU Emacs를 사용하여 Info에서 이 문서를 읽는 중이라면, 스페이스 바, @key{SPC}를 
누르는 것으로 문서 전체를 읽을 수 있다. ( Info에 대해서 배우기 위해서 @kbd{C-h i} 입력한 후 
Info를 선택하라. )

용어에 대한 메모: Lisp 단어 혼자만 사용할 때는 일반적으로 다양한 Lisp을 가리킨다. 그러나 
Emacs Lisp이라고 할 때는 특히 GNU Emacs Lisp을 가리킨다.



@node 감사합니다.,  , 초보자를 위한 노트, 서문
@comment  node-name,  next,  previous,  up
@unnumberedsec 감사합니다.

이 책을 도와주신 모든 분들에게 감사 드립니다. @r{Jim Blandy}, @r{Noah Friedman}, @w{Jim Kingdon}, @r{Roland McGrath}, @w{Frank Ritter}, @w{Randy Smith}, @w{Richard M.@:Stallman}, 그리고 @w{Melissa Weisshaus} 이 분들에게는 더욱 감사함을 느낍니다.  꾸준한 격려를 주신 @w{Philip Johnson} 와 @w{David Stampe} 이 두 분에게도 감사합니다. 이 책의 모든 실수는 모두 저의 것입니다.

@flushright
Robert J. Chassell
@email{bob@@gnu.org}
@end flushright

@c ================ Beginning of main text ================

@c Start main text on right-hand (verso) page

@tex
\par\vfill\supereject
\headings off
\ifodd\pageno
    \par\vfill\supereject
\else
    \par\vfill\supereject
    \page\hbox{}\page
    \par\vfill\supereject
\fi
@end tex

@iftex
@headings off
@evenheading @thispage @| @| @thischapter
@oddheading @thissection @| @| @thispage
@global@pageno = 1
@end iftex


@node List 처리하기, 평가 연습하기, 서문, Top
@comment  node-name,  next,  previous,  up
@chapter List 처리하기

특별한 지식이 없는 사람들에게는 Lisp은 이상한 프로그래밍 언어로 보인다. Lisp 코드 어디나
괄호들이 보인다. 몇몇 사람들은 심지어 이름이 ‘Lots of Isolated Silly Parentheses’을 
나타낸다고 한다. 그러나, 이것은 틀렸다. Lisp은 LISt Processing을 나타내고, 괄호 사이에
@emph{list}를(그리고 list의 list) 넣어서 다루는 프로그래밍 언어이다. 괄호는 리스트의 경계를
표시한다. 때로는 작은 따옴표 또는 인용 기호 @samp{‘} @footnote{ 작은 따옴표 또는 인용
기호는 @code{quote} 함수의 약어다.; 지금 함수들에 대해서 몰라도 된다.; 함수들은 
@ref{에러 만들기, , 에러 메시지 만들기}.에 정의 되어 있다. } 뒤에 list가 
위치한다. List는 Lisp의 근본이다.

@menu
* Lisp에서 List::                list는 무엇인가?
* 프로그램 실행하기::               Lisp에서 list는 실행할 준비가 된 프로그램이다.
* 에러 만들기::               에러 메시지 만들기.
* 이름과 정의::         기호 이름들과 함수 정의들.
* Lisp Interpreter::            Lisp 해석기가 하는 일.
* 평가하기::                  프로그램 실행.
* Variables::                   변수로부터 값을 넘겨 받기.
* 인자들::                   함수에 정보 넘기기.
* set & setq::                  변수에 값 설정하기.
* 정리::                     중요한 점들.
* Error Message Exercises::
@end menu


@node Lisp에서 List, 프로그램 실행하기, List 처리하기, List 처리하기
@comment  node-name,  next,  previous,  up
@section Lisp에서 List
@cindex Lisp Lists

Lisp에서 list는 이런 형태이다.; @code{'(rose violet daisy buttercup)}. 이 list는 작은 
따옴표로 시작한다. 다음 처럼 쓰여질 수 있을 뿐만 아니라, 더 친숙한 list의 형태로 보인다.

@smallexample
@group
'(rose
  violet
  daisy
  buttercup)
@end group
@end smallexample

@noindent
주위에 돌로 둘러싸여 있는 들판에 꽃들처럼 공백에 의해서 구분되고 괄호에 싸여 있는 이 list의 요소들은 
다른 4가지의 꽃들의 이름들이다. 
@cindex Flowers in a field

@menu
* 숫자와 List::                  List는 숫자, List를 가진다
* Lisp Atoms::                  기본적인 요소들.
* List에서 공백 문자::         읽기 쉽게 List 형식 갖추기.
* List 입력하기::                GNU Emacs는 List 입력을 돕는 방법.
@end menu


@node 숫자와 List, Lisp Atoms, Lisp에서 List, Lisp에서 List
@ifnottex
@unnumberedsubsec 숫자, List 안의 List
@end ifnottex

List는 이 List 처럼 그 안에 숫자들을 가질 수 있다.: @code{(+ 2 2)}. 이 List는 더하기 기호, 
@samp{+}, 그리고 이어서 공백으로 구분되는 두 개의 @samp{2} 가 온다.

Lisp에서 데이터와 프로그램은 같은 방식으로 표현된다.; 공백에 의해서 구분되고 괄호에 싸여있는 단어들, 
숫자들 또는 다른 List들이다. ( 프로그램이 데이터처럼 보이기 때문에 하나의 프로그램은 쉽게 다른 
프로그램을 위한 데이터로 쉽게 제공할 수 있다.; 이는 Lisp의 매우 강력한 특징이다. ) ( 부수적으로 지금 
괄호로 싸여있는 구절들은 @samp{;}와 구두점인 @samp{.}을 포함하고 있기 때문에 Lisp의 List가 
@emph{아니다}. )

@need 1200
이번에는 List 안에 List를 가지고 있는 다른 List가 있다.

@smallexample
'(this list has (a list inside of it))
@end smallexample

이 List의 요소들은 단어 @samp{this}, @samp{list}, @samp{has}, 와 List @samp{(a list 
inside of it)} 이다. 내부 List는 단어 @samp{a}, @samp{list}, @samp{inside},
@samp{of}, @samp{it} 로 구성되어 있다.



@node Lisp Atoms, List에서 공백 문자, 숫자와 List, Lisp에서 List
@comment  node-name,  next,  previous,  up
@subsection Lisp Atoms
@cindex Lisp Atoms

Lisp에서 @dfn{atom}라 부르는 단어들이 있다. 이 용어는 단어 ‘쪼갤 수 없는’ 것을 
의미하는 atom의 역사적인 의미에서 왔다. Lisp까지 영향을 주었다. List에 사용하는 
단어들은 더 이상 작은 부분으로 쪼갤 수 없고 여전히 프로그램의 부분으로 같은 것을 
의미한다.; 숫자와 @samp{+} 같은 하나의 문자 기호처럼. 반면에 atom과 다르게 List는 
부분들로 나눠질 수 있다. (  @xref{car cdr & cons,
, @code{car} @code{cdr} & @code{cons} Fundamental Functions}. )

List에서 atom은 공백으로 구분된다. 괄호의 바로 옆에 있을 수 있다.

@cindex @samp{empty list} defined
기술적으로 이야기 하면 Lisp에서 List는 공백으로 구분되는 atom들 또는 다른 List들 
혹은 둘 다를 둘러싼 괄호로 구성된다. List는 그 안에 하나의 atom을 가질 수 있거나 
아무 것도 가지지 않을 수 있다. 안에 아무 것도 없는 List는 다음과 같다.: @code{()} 
이고 @dfn{빈 List}로 불린다. 다른 것과 다르게 빈 List는 동시에 atom이면서 List로 
간주된다.

@cindex Symbolic expressions, introduced
@cindex @samp{expression} defined
@cindex @samp{form} defined
atom과 List 둘의 출력 된 표현은 @dfn{symbolic expressions} 또는 보다 간결하게 
@dfn{s-expressions}라 불린다. 단어 @dfn{expression} 자체는 출력 된 표현 또는 
컴퓨터에 내부에 저장된 것으로 List 또는 atom으로 참조될 수 있다. 종종 사람들은 
@dfn{expression}을 마구잡이로 사용한다. ( 또한 많은 글들에서 @dfn{form} 단어는 
expression의 동의어로 사용되고 있다. )

우연히 우주를 구성하는 atom들은 쪼개질 수 없다고 생각되어 그렇게 불리었다.; 그러나 
물리적인 atom들은 쪼개질 수 있다고 판명되었다. 부분은 atom으로 쪼개질 수 있거나 
같은 크기의 두 부분으로 분열될 수 있다. 물리적 진짜 성질을 알기 전에 atom은 성급하게 
이름 지어졌다. Lisp에서 배열과 같은 어떤 종류의 atom은 부분으로 나눠질 수 있다.; 
그러나 이렇게 하는 방법은 List를 나누는 방법과는 다르다. List 연산에 영향 주는 
범위에서는 List의 atom들은 나눠질 수 없다.

영어처럼 Lisp atom의 구성하는 문자들의 의미들은 단어를 만드는 문자들의 의미와 
다르다. 예를 들면 세 발가락 나무늘보(South American sloth)의 단어, 
@samp{ai} 는 두 단어 @samp{a}와 @samp{i} 와 전혀 다르다.

자연에는 많은 종류의 atom들이 있지만 Lisp에서는 단지 몇 개만 있다. : 예를 들면 
37,511 또는 1729와 같은 @dfn{숫자}와 @samp{+}, @samp{foo} 또는 
@samp{forward-line} 같은 @dfn{기호}가 있다. 앞에 예제에서 열거한 단어들은 모두 
기호들이다. 프로그래머들은 다루는 atom의 종류에 보다 명확하게 하기 때문에, 일상적인 
Lisp 대화에서 “atom” 단어는 자주 사용되지는 않는다. Lisp 프로그래밍은 List에 있는 
대부분 기호( 와 때로는 숫자 )에 대한 것이다. ( 덧붙여 삽입 어구로 제시된 앞의 3 단어는 
공백으로 구분된 기호인 atom으로 구성되어 있고 괄호로 싸여있기 때문에 Lisp에서 
적절한 list이다. )

@need 1250
큰 따옴표 사이에 있는 글 -- 문장들 또는 문단들 조차 --  또한 atom이다. 여기 예가 
있다.
@cindex Text between double quotation marks

@smallexample
'(this list includes "text between quotation marks.")
@end smallexample

@cindex @samp{string} defined
@noindent
Lisp에서 구두점과 공백 문자들을 포함한 모든 큰 따옴표로 묶인 글은 단일 atom이다. 
이런 종류의 atom은 @dfn{문자열}이라고 불리고 사람이 읽을 수 있게 컴퓨터가 출력할 
수 있는 메시지로 사용되는 것들이다. 문자열은 숫자 또는 기호와 다른 종류의 atom이고 
다르게 사용된다.



@node List에서 공백 문자, List 입력하기, Lisp Atoms, Lisp에서 List
@comment  node-name,  next,  previous,  up
@subsection List에서 공백 문자
@cindex Whitespace in lists

@need 1200
List에서 공백의 양은 중요하지 않다. Lisp 언어의 관점에서는,

@smallexample
@group
'(this list
   looks like this)
@end group
@end smallexample

@need 800
@noindent
은 다음과 정확히 동일하다.:

@smallexample
'(this list looks like this)
@end smallexample

두 예제는 Lisp에서 같은 List를 보여준다. List는 기호 @samp{this}, @samp{list}, 
@samp{looks}, @samp{like}, 그리고 @samp{this} 순으로 구성되어 있다.

추가 공백과 새 줄은 List를 읽기 좋게 만들기 위해서 설계되었다. Lisp이 이 표현을 
읽을 때, 모든 공백은 제거 된다. ( 그러나 구분하기 위해서 atom 사이에 적어도 하나의 
공백은 필요하다. )

보기에는 다루었던 예제들이 Lisp list의 대부분을 다룬 것처럼 보인다. Lisp에서 다른 
list는 더 길거나 더 복잡한 것을 제외하고는 정도의 차이는 있어도 이 예제들 중에 하나로 
보인다. 요약하면 List는 괄호 사이에 있고 문자열은 큰 따옴표 사이에 있다. 기호는 단어 
같이 보이고 숫자는 숫자이다. ( 어떤 상황에서는 꺽쇠 괄호, 점 그리고 다른 특수 문자들도 
사용될 수 있다.; 그러나 그 것들 없이 멀리 갈 것이다. )



@node List 입력하기,  , List에서 공백 문자, Lisp에서 List
@comment  node-name,  next,  previous,  up
@subsection GNU Emacs는 List 입력을 돕는다
@cindex Help typing lists
@cindex Formatting help

Lisp 대화 모드 또는 Emacs Lisp 모드의 GNU Emacs에서 Lisp 표현식을 입력할 때, 
읽기 쉽게 Lisp 표현식을 나타내는 몇 가지 명령이 있다. 예를 들면 @key{TAB}을 누르는 
것은 자동으로 줄 들여쓰기를 한다. 지역 안에 코드를 들여쓰기하는 명령은 관례상 
@kbd{M-C-\}에 엮여있다. 들여쓰기는 List의 요소들이 어떤 List에 속해있는지 볼 수 
있게 설계되었다. --- 하위 List의 요소들은 상위 리스트의 요소들보다 더 들여쓰기한다.

게다가 닫는 괄호를 입력할 때, Emacs는 확인할 수 있게 즉시 짝을 이루는 여는 괄호로 
커서를 움직인다. Lisp에서 입력하는 모든 List는 닫는 괄호와 짝을 이루는 여는 괄호가 
있어야 하기 때문에 이 것은 매우 유용하다. ( Emacs의 모드들에 관한 자세한 정보는 
(@xref{Major Modes, , Major Modes, emacs, The GNU Emacs Manual}.)


@node 프로그램 실행하기, 에러 만들기, Lisp에서 List, List 처리하기
@comment  node-name,  next,  previous,  up
@section 프로그램 실행하기
@cindex Run a program
@cindex Program, running one

@cindex @samp{evaluate} defined

Lisp에서 list는 --- 아무 List ---  어 수행 시킬 수 있는 프로그램이다. 그 것을 수행하면 
( Lisp의 전문 용어로는 @dfn{evalute}라고 한다. )컴퓨터는 세 가지 중 한 가지를 할 것
이다.: list 자체를 반환하는 것을 제외하고 아무 것도 하지 않는다.; 에러 메시지를 
보여준다.; 또는 list의 첫 기호를 어떤 일을 하는 명령으로 다룬다. ( 물론 보통 이 세 가지 
중 마지막이 진짜 원하는 것이다! )

@c use code for the single apostrophe, not samp.
앞 절의 예제 list 앞에 놓은 작은 따옴표는, @code{‘}, @dfn{인용}라고 불린다.; List 
앞에 있을 때, Lisp에게 list가 쓰여진 데로 가지는 것 에 아무 것도 하지 말라고 하는 
것이다. 그러나, List앞에 인용이 없다면, List의 첫 항목은 특별하다.: 그 것은 컴퓨터가 
따라할 명령이다. ( Lisp에서 이 명령은 @emph{함수}라 불린다. ) List 
@code{(+ 2 2)} 는 앞에 인용이 없다. 그래서 Lisp은 @code{+}를 List의 나머지 
항목들과 무엇을 하는 명령을 이해한다.; 뒤이어 나오는 숫자들을 더하라.

@need 1250
GNU Emacs에서 info로 이 문서를 보고 있다면 그런 List를 실행하는 방법이 있다.: 
다음 List의 맨 오른쪽 괄호 뒤로 커서를 이동 시키고 @kbd{C-x C-e}를 입력해라.

@smallexample
(+ 2 2)
@end smallexample

@c use code for the number four, not samp.
@noindent
메아리 영역에 숫자 @code{4}가 나타나는 것을 볼 수 있을 것이다.( 전문 용어로 지금 
한 것을 “List를 평가하다.” 라고 한다. 메아리 영역은 출력 또는 글을 “메아리치는” 화면의 
아래의 줄이다. ) 지금 인용된 List로 같은 것을 하고자 한다. 커서를 다음 리스트 바로 
뒤로 이동 시킨 후, @kbd{C-x C-e}를 입력해라.

@smallexample
'(this is a quoted list)
@end smallexample

@noindent
메아리 영역에 @code{(this is a quoted list)}이 나타나는 것을 볼 것이다.

@cindex Lisp interpreter, explained
@cindex Interpreter, Lisp, explained
두 경우에서 했던 것은 @dfn{Lisp 해석기}로 불리는 GNU Emacs 내부의 프로그램에게 
명령을 주는 것이다. --- 표현식을 평가하기 위해 해석기에게 명령을 주는 것. Lisp 
해석기의 이름은 표현식의 의미를 찾는 사람에 의해서 수행된 작업을 뜻하는 단어에서 
유래했다. --- “통역하는” 사람. 

List의 부분이 아닌 atom을 평가할 수 있다. --- 괄호에 둘러 싸이지 않았다.; 다시 Lisp 
해석기는 사람이 읽을 수 있는 표현식을 컴퓨터의 언어로 번역한다. 그러나 이 것 
(@pxref{Variables})을 토론하기 전에  에러를 만들었을 때, List 해석기가 무엇을 
하는지 의논할 것이다.


@node 에러 만들기, 이름과 정의, 프로그램 실행하기, List 처리하기
@comment  node-name,  next,  previous,  up
@section 에러 메시지 만들기
@cindex Generate an error message
@cindex Error message generation

Lisp 해석기가 에러 메시지를 출력하는 명령을 알려줄 것이고, 어느 정도 실수를 하더라도 
걱정하지 않을 것이다. 이 것은 해가 없는 행동이다.; 그리고 실제로 의도적으로 종종 에러 
메시지를 생성할 것이다. 한번 용어를 이해하면, 에러 메시지는 유용할 수 있다. “에러” 
메시지라 불리는 것 대신에 “도움” 메시지들이라 불릴 수 있다. 그것들은 낯선 도시에 
여행자에게 이정표 같은 것이다.; 그것들을 해석하는 것은 어려울 수 있지만, 한번 이해 
했다면 길을 알려줄 것이다.

에러 메시지는 내장된 GNU Emacs 디버거에 의해서 생성된다. ‘디버거를 시작’ 할 
것이다. @code{q}를 입력함으로 디버거를 빠져나올 수 있다.

따옴표가 없고 첫 번째 항목이 의미 있는 명령이 아닌 list를 평가할 것이다. 작은 따옴표가 
없는 것을 제외하고는 앞에서 사용했던 것과 같은 list가 있다. 커서를 이 list의 오른쪽으로 
옮긴 후, @kbd{C-x C-e}를 입력해라.: 

@smallexample
(this is an unquoted list)
@end smallexample

@noindent
사용하는 Emacs의 버전에 따라 다르게 보일 것이다. GNU Emacs 22 버전은 20 
버전과 그 이전 버전보다는 더 많은 정보를 제공한다. 첫 째, 에러를 만든 최근 결과 ; 
다음에는 이전, 20 버전 결과.  

@need 1250
@noindent
GNU Emacs 22 버전에서는 @file{*Backtrace*} 창이 열리고 그 안에 다음과 같은 
것을 볼 것이다.:

@smallexample
@group
---------- Buffer: *Backtrace* ----------
Debugger entered--Lisp error: (void-function this)
  (this is an unquoted list)
  eval((this is an unquoted list))
  eval-last-sexp-1(nil)
  eval-last-sexp(nil)
  call-interactively(eval-last-sexp)
---------- Buffer: *Backtrace* ----------
@end group
@end smallexample

@need 1200
@noindent
커서는 이 윈도우에 있을 것이다.( 보이기 전까지 몇 초를 기다려야 할 지도 모른다. ) 
디버거를 빠져나오고 디버거 창을 닫기 위해서는 입력하라:

@smallexample
q
@end smallexample

@noindent
디버거를 빠져나와 편안해지기 위해서 @kbd{q}를 바로 입력하라. 그때, 다시 
@kbd{C-x C-e}를 입력하면 디버거로 다시 들어간다.

@cindex @samp{function} defined
이미 알고있는 것을 바탕으로 이 에러 메시지를 읽을 수 있다.

@file{*Backtrace*} 버퍼를 아래에서 위로 읽는다.; Emacs가 한 것을 보여준다. 
@kbd{C-x C-e}를 입력했을 때, @code{eval-last-sexp} 명령에 대해서 대화형 
호출을 했다. @code{eval}은 ‘평가하다(evaluate)’에 대한 약어이고 @code{sexp}는 
‘기호 표현식(symbolic expression)’에 대한 약어이다. 명령은 커서 바로 앞의 표현식에 
대해서 ‘마지막 기호 표현식을 평가하라’를 의미한다.

위의 각 줄은 Lisp 해석기가 평가한 것을 나타낸다. 가장 최근의 행동은 맨 위에 있다. 
Emacs를 역으로 추적하는 것을 가능하게 하기 때문에 @file{*Backtrace*}라는 
버퍼라 불린다.

@need 800
@file{*Backtrace*} 버퍼의 맨 위에서, 이 줄을 본다.

@smallexample
Debugger entered--Lisp error: (void-function this)
@end smallexample

@noindent
Lisp 해석기는 list의 첫 atom인 @samp{this} 단어를 평가하려고 한다. 이 행동은 에러 
메시지 @samp{void-function this}를 만들어냈다.

메시지는 @samp{void-function}과 @samp{this}를 포함하고 있다.

@cindex @samp{function} defined
@samp{function}은 전에 한번 언급했었다. 매우 중요한 단어이다. 우리의 목적을 위해 
@dfn{function}은 컴퓨터가 처리해야 할 것들을 지시하는 명령들의 집합이라고 말하는 
것으로 정의할 수 있다.

이제 에러 메시지를 이해할 수 있다.: @samp{void-function this}. 함수는 ( 단어 
@samp{this} 이다. ) 컴퓨터가 수행할 명령들의 집합의 정의를 가지고 있지 않다.

다소 이상한 단어, @samp{void-function}는 Emacs Lisp이 구현된 방식을 감추기
위해 설계되었고, 기호는 연결된 함수 정의를 갖지 않을 때, 명령들을 포함해야 하는 
장소는 ‘비었다’.

반면에 @code{(+ 2 2)}를 평가하는 것으로 성공적으로 2 더하기 2를 할 수 있기 때문에, 
기호 @code{+}는 컴퓨터가 따라야 할 명령들의 집합을 가지고 있고 그 명령들은 
@code{+} 뒤에 따라오는 숫자들을 합해야 한다는 것을 추론할 수 있다.

@need 1250
GNU Emacs 20 버전과 초기 모든 버전들에서 에러 메시지의 한 줄을 볼것이다.; 메아리 
영역에 다음 처럼 나타날 것이다.

@smallexample
Symbol's function definition is void:@: this
@end smallexample

@noindent
(또한 터미널은 삑 소리를 낼 것이다. --- 소리가 날 수도 있고, 아닐 수도 있다.; 그리고 
다른 것들은 깜박인다. 단지 관심을 얻기 위한 장치이다. ) 커서를 움직이거나, 다른 키를 
누르면 메시지는 바로 사라진다.

@samp{Symbol}의 의미를 안다. 이 것은 List의 첫 번째 항목, @samp{this} 단어를 
가리킨다. @samp{function}는 컴퓨터가 할 일을 나타내는 명령들을 의미한다. ( 
기술적으로 기호는 컴퓨터가 명령들을 찾을 수 있는 위치를 나타내지만, 우리는 잠시 동안 
무시할 수 있는 복잡한 것이다. ) 

이제 에러 메시지를 이해할 수 있다.: @samp{Symbol’s function definition is 
void:@: this}. 기호는 ( @samp{this} 단어 ) 컴퓨터가 수행할 수 있는 명령들이 없다.



@node 이름과 정의, Lisp Interpreter, 에러 만들기, List 처리하기
@comment  node-name,  next,  previous,  up
@section 기호 이름들과 함수 정의들
@cindex Symbol names

지금까지 논의한 내용을 바탕으로 Lisp의 또 다른 특성들을 분명하게 설명할 수 있다. --- 
중요한 특성: @code{+} 같은 기호는 컴퓨터가 이해하는 명령들의 집합이 아니다. 대신에 
아마 일시적으로 명령들의 집합 또는 정의를 찾는 하나의 방법으로 기호가 사용된다. 
명령들이 발견될 수 있는 것을 통해서 이름들을 볼 것이다. 사람들의 이름들도 같은 
방식이다. 나는 @samp{Bob} 이다.; 하지만, 나는 글자 @samp{B}, @samp{o}, 
@samp{b}은 아니다. 그러나 특정 생활에 지속적으로 관련된 의식이었다. 이름은 내가 
아니지만 나를 지칭할 수 있다.

Lisp에서 하나의 명령들의 집합은 여러 이름들에 붙을 수 있다. 예를 들면, 숫자를 더하는 
컴퓨터 명령들은 기호 @code{+} 뿐만 아니라 기호 @code{plus}에도 연결될 수 있다. 
(그리고 Lisp의 일부 방언들에 있다. ) 사람들 사이에서 나는 @samp{Robert}와 
@samp{Bob} 뿐만 아니라 다른 단어에 의해서 참조될 수 있다.

반면에, 기호는 한번에 오직 하나의 함수 정의에만 연결될 수 있다. 그렇지 않으면, 
컴퓨터는 사용할 함수 정의에 대해서 혼동할 것이다. 만약 사람들 사이의 경우라면, 세상에 
오직 한 사람만이 @samp{Bob}이라는 이름을 가질 수 있는 것이다. 그러나, 이름에 
의해서 참조되는 함수 정의는 손쉽게 변경될 수 있다. (@xref{Install, , Install a 
Function Definition}.)

Emacs Lisp이 거대해진 이후로, 함수가 속한 Emacs의 일부를 지칭하는 방식으로 
기호들을 명명하는 관례가 있다. 따라서 Texinfo를 다루는 함수들에 대한 모든 이름들은 
@samp{texinfo-}로 시작하고 mail 읽는 것을 다루는 함수들은 @samp{rmail-}로 
시작한다.



@node Lisp Interpreter, 평가하기, 이름과 정의, List 처리하기
@comment  node-name,  next,  previous,  up
@section Lisp 해석기
@cindex Lisp interpreter, what it does
@cindex Interpreter, what it does

살펴본 것을 바탕으로, list를 평가하라는 명령을 내렸을 때 Lisp 해석기가 무엇을 하는지 
알 수 있다. 첫 번째, list 앞에 따옴표가 있는지 본다.; 만약 있다면, 해석기는 list를 단지 
우리에게 준다. 반면에 따옴표가 없다면, 해석기는 list의 첫 요소를 보고 그 요소에 
해당하는 함수가 있는지 본다. 만약 있다면 해석기는 함수 정의에 명령들을 수행한다. 만약 
없다면 해석기는 에러 메시지를 출력한다.

이 것이 Lisp이 동작하는 방식이다. 단순하다. 잠시 후에 볼 추가적인 복잡함이 있지만, 
이 것이 기본이다. 물론 Lisp 프로그램을 작성하기 위해서는 함수 정의를 작성하고 그 
함수에 이름을 붙이는 것을 알아야 한다. 그리고 자신 또는 컴퓨터가 혼동하지 않게 이 
것을 하는 것도 알아야 한다.

@menu
* Complications::               Variables, Special forms, Lists within.
* Byte Compiling::              Specially processing code for speed.
@end menu


@node Complications, Byte Compiling, Lisp Interpreter, Lisp Interpreter
@ifnottex
@unnumberedsubsec Complications
@end ifnottex

이제 첫 복잡함이다. List에 추가적으로 Lisp 해석기는 따옴표와 괄호가 없는 기호를 평가
할 수 있다. Lisp 해석기는 @dfn{variable}로서 기호의 값을 결정하려고 할 것이다. 이 
상황은 변수들 섹션에서 설명한다. (@xref{Variables}.)

@cindex Special form
몇 함수들이 비정상적이며 일반적인 방식으로 동작하지 않기 때문에 두 번째 복잡함이 
발생한다. 이 것들은 @dfn{special forms}라 부른다. 함수를 정의하는 것 같은 특별한 
일에 대해서 사용된다. 그리고 많지는 않다. 다음 장에서 더 중요한 special form에 
대해서 나온다.

세 번재와 마지막 복잡함은 이것이다.: 만약 Lisp 해석기가 찾는 함수가 special form이 
아니고 list의 한 부분이라면 Lisp 해석기는 List 안에 List를 가지고 있는지 본다. 만약에 
내부 List라면 Lisp 해석기는 안쪽 List에 대해서 먼저 알아내고 그 이후에 바깥쪽 List에 
대해서 처리한다. 만약 안쪽 List에 또 다른 List가 포함되어 있다면, 그 안쪽 List를 먼저 
처리한다. 항상 가장 안쪽의 List를 처리한다. List의 결과를 평가하기 위해서 해석기는 
먼저 가장 안쪽 List에 대해서 처리한다. 결과는 둘러싸인 표현으로 사용될 것이다.

그렇지 않으면 해석기는 왼쪽에서 오른쪽으로, 한 표현에서 그 다음으로 처리한다.



@node Byte Compiling,  , Complications, Lisp Interpreter
@subsection Byte Compiling
@cindex Byte compiling

해석기의 한 가지 다른 측면이 있다.: Lisp 해석기는 두 종류의 독립체를 해석할 수 있다.: 
앞으로 주로 살펴볼 사람이 읽을 수 있는 코드 그리고 사람이 읽을 수 없는 @dfn{byte 
compiled} 코드라 불리는 특수하게 처리되는 코드. Byte compiled 코드는 사람이 
읽는 코드 보다 빠르게 수행된다.

@code{byte-compile-file} 같은 컴파일 명령의 하나를 실행하여 사람이 읽을 수 있는 
코드를 byte compiled 코드로 변환할 수 있다. byte compiled 코드는 @file{.el} 
확장자가 아닌 @file{.elc} 확장자를 가지는 보통 파일에 저장된다. @file{emacs/lisp} 
디렉토리에서 두 종류의 파일을 볼 수 있다.; 읽을 수 있는 파일들은 @file{.el} 확장자를
가진다.

실제 문제로서 Emacs를 변경하거나 확장하는 대부분의 것들은 byte compile이 
필요하지 않다. 그리고 이 주제는 여기서 다루지 않을 것이다. byte compilation의 모든 
설명은 @xref{Byte Compilation, , Byte Compilation, elisp, The GNU Emacs 
Lisp Reference Manual} 에 있다.



@node 평가하기, Variables, Lisp Interpreter, List 처리하기
@comment  node-name,  next,  previous,  up
@section 평가하기
@cindex Evaluation

Lisp 해석기가 표현에서 동작할 때, 그 행위를 위한 용어로 @dfn{evaluation}이라고 
한다. 해석기가 ‘표현을 평가한다.’라고 이야기 한다. 이미 이 용어를 앞에서 여러 번 
사용했다. @cite{Webster's New Collegiate Dictionary}.에 따르면 ‘가치 또는 
금액을 알아보다; 평가하다.’라는 일상 언어에서 사용하는 것에서 유래되었다.

@menu
* 해석기가 동작하는 방식::    Returns and Side Effects...
* 내부 list 평가하기::      Lists within lists...
@end menu


@node 해석기가 동작하는 방식, 내부 list 평가하기, 평가하기, 평가하기
@ifnottex
@unnumberedsubsec Lisp 해석기가 동작하는 방식
@end ifnottex

@cindex @samp{returned value} explained.
표현을 평가한 후에 Lisp 해석기는 함수 정의에 명령들을 수행하여 얻은 값을 
@dfn{return}하거나 아마도 함수 수행을 포기하고 에러 메시지를 출력할 것이다. 
(   말하자면 그 자체가 다른 함수로 넘겨지거나, ‘무한 반복’이라 하는 것으로 영원히 계속 
반복할지도 모른다. 이런 동작들은 드물다.; 그리고 그것들을 무시할 수 있다. ) 대다수의 
경우 해석기는 값을 넘겨준다.

@cindex @samp{side effect} defined
해석기가 값을 넘겨주는 동시에, 커서를 옮기거나 파일을 복사하는 것같은 다른 일을 할 
수도 있다.; 이런 다른 종류의 행동을 @dfn{side effect}라고 한다. 결과를 출력하는 
것처럼 사람들이 생각하는 행동들은 중요하고 Lisp 해석기에는 종종 “side effects”이다. 
이 용어는 이상하게 들릴 수 있다. 그러나 side effects를 사용하는 것을 배우는 것이 
매우 쉬운 것으로 밝혀졌다.

요약하면, 가장 흔하게 기호 표현을 평가하는 것은 Lisp 해석기가 값을 넘겨주고 아마도 
side effect을 수행한다.; 또는 에러를 발생한다.



@node 내부 list 평가하기,  , 해석기가 동작하는 방식, 평가하기
@comment  node-name,  next,  previous,  up
@subsection 내부 list 평가하기
@cindex Inner list evaluation
@cindex Evaluating inner lists

안쪽에 다른 list에 평가가 적용된다면 바깥 list가 평가될 때, 첫 평가에 의해서 넘겨진 
값을 정보로서 사용할 것이다. 이는 안쪽의 표현들이 먼저 평가되는 이유이다.: 밖의 
표현들은 넘겨진 값들을 사용한다.

@need 1250
다른 예제를 평가하는 것으로 이 과정을 살펴볼 수 있다. 커서를 다음 표현식 뒤에 
위치시킨 후, @kbd{C-x C-e}를 입력하라.:

@smallexample
(+ 2 (+ 3 3))
@end smallexample

@noindent
숫자 8이 echo 영역에 나타날 것이다.

Lisp 해석기가 먼저 값 6을 넘겨주는 안쪽 표현 @code{(+ 3 3)} 을 평가한다.; 그리고 
값 8을 넘겨주는 바깥 표현 @code{(+ 2 6)} 을 평가한다. 더 이상의 포함하는 표현들이 
없기 때문에 해석기는 echo 영역에 값을 출력한다.

이제 키 입력 @kbd{C-x C-e}에 의해 수행되는 명령의 이름을 이해하는 것이 쉽다.: 
@code{eval-last-sexp}가 이름이다. @code{sexp}의 문자들은 ‘symbolic 
expression’의 약어이다. 그리고 @code{eval}은 ‘evaluate’의 약어이다. 이 명령은 
‘마지막 기호 표현을 평가하라’를 의미한다.

실험처럼 표현 바로 뒤 다음 줄의 시작에 커서를 놓거나 표현 안쪽에 커서를 놓고 표현을 
평가하는 것을 해볼 수 있다.

@need 800
여기 다른 표현의 사본이 있다.

@smallexample
(+ 2 (+ 3 3))
@end smallexample

@noindent
커서를 표현 바로 뒤의 빈줄의 시작에 놓고 @kbd{C-x C-e}를 입력하면 echo 영역에 
값 8을 얻을 것이다. 지금 커서를 표현 안쪽에 놓고 시도해봐라. 만약 마지막 괄호의 바로 
옆에  놓는다면, ( 마지막 괄호의 바로 위에 놓인 것으로 나타난다. ) echo 영역에 6이 
출력되는 것을 볼 것이다. 표현 @code{(+ 3 3)}을 평가한 명령이기 때문이다.

지금 숫자 바로 뒤에 커서를 움직여라. @kbd{C-x C-e}를 입력하면 숫자 그 자체를 얻을 
것이다. Lisp에서 숫자를 평가하면 숫자 그 자체를 얻는다. --- 숫자는 기호와 다른다. 
@code{+} 같은 기호로 시작하는 list를 평가한다면, 그 이름에 연결된 함수 정의에 있는 
명령들을 실행함으로 얻은 값을 넘겨 받을 것이다. 기호 그 자체를 평가한다면 다음 장에서 
보겠지만 다른 어떤 일이 생길 것이다. 


@node Variables, 인자들, 평가하기, List 처리하기
@comment  node-name,  next,  previous,  up
@section Variables
@cindex Variables

Emacs Lisp에서 기호는 기호에 연결된 함수 정의를 가질 수 있는 것 처럼 그 기호에 연결
된 값을 가질 수 있다.이 두개는 다르다. 함수 정의는 컴퓨터가 처리해야 하는 명령의 
집합이다. 반면에 값은 변할 수 있는 숫자 또는 이름이다. ( 그런 기호가 변수라 하는 
이유이다. ) 기호의 값은 기호, 숫자, list, 문자열 처럼 Lisp에서 표현이 될 수 있다. 값을 
가질 수 있는 기호는 @dfn{variable}이라고 한다.

기호는 동시에 함수 정의와 값을 가질 수 있다. 또는 둘 중 하나를 가질 수 있다. 이 둘은 
다르다. 이름 Cambridge는 Massachusetts에 있는 도시를 나타낼 수도 있고 “대단한 
프로그래밍 센터” 같이 이름에 있는 몇 가지 정보를 가지는 것과 유사하다.

@ignore
( 그런데 Emacs Lisp에서 기호는 다른 두 가지를 가질 수 있다. 속성 list, 문서 문자열; 
이 것들은 나중에 논의 될 것이다. )
@end ignore

이 것과 관련된 다른 방식은 기호를 서랍장으로 상상하는 것이다. 함수 정의는 한 서랍에 
있다. 값은 다른 서랍에 있다. 값을 담고 있는 서랍은 함수 정의를 담고 있는 서랍에 영향 
없이 변경될 수 있다. 그 반대로도 마찬가지이다.

@menu
* fill-column Example::
* Void Function::               The error message for a symbol
                                  without a function.
* Void Variable::               The error message for a symbol without a value.
@end menu


@node fill-column Example, Void Function, Variables, Variables
@ifnottex
@unnumberedsubsec @code{fill-column}, an Example Variable
@end ifnottex

@findex fill-column, @r{an example variable}
@cindex Example variable, @code{fill-column}
@cindex Variable, example of, @code{fill-column}
변수 @code{fill-column}은 값을 가지고 있는 기호를 보여준다.: 모든 Emacs 
버퍼에서 이 기호는 어떤 값으로 설정되어 있다. 보통 72 또는 70이나 때로는 다른 값일 
수 있다. 이 기호의 값을 알기 위해서 이 기호를 평가한다. GNU Emacs의 info로 이 
문서를 읽고 있다면, 이 기호 뒤에 커서를 이동한 후 @kbd{C-x C-e}를 입력하는 것으로 
이 기호를 평가할 수 있다.

@smallexample
fill-column
@end smallexample

@noindent
@kbd{C-x C-e}를 입력하면 Emacs는 echo 영역에 숫자 72를 출력한다. 내가 이 
문서를 쓸 당시 나를 위해 설정한 @code{fill-column}의 값이다. 이 값은 다를 수 있다. 
변수로 넘겨진 값은 함수의 명령을 실행하여 넘겨진 값과 바로 같은 방식으로 출력된다. 
Lisp 해석기의 관점으로 보면 값이 넘겨지는 것은 값이 넘겨지는 것이다. What kind of 
expression it came from ceases to matter once the value is known.

기호는 어떤 값을 가질 수 있다. 전문 용어를 사용하면 변수에 값을 @dfn{bind} 한다.: 
72같은 숫자; @code{“such as this”} 같은 문자열; @code{(spruce pine oak)}
같은 list; 심지어 변수를 함수에 bind 할 수 있다.

기호는 다른 방식으로 값에 bind 될 수 있다. 이 것과 관련된 정보는 @xref{set & setq, ,
변수에 값 설정하기} 참조하라.


@node Void Function, Void Variable, fill-column Example, Variables
@comment  node-name,  next,  previous,  up
@subsection Error Message for a Symbol Without a Function
@cindex Symbol without function error
@cindex Error for symbol without function

변수로의 값을 얻기 위해 @code{fill-column}을 평가 할 때, 이 단어 주변의 괄호가 
없었다. 이 것은 함수 이름으로 사용하는 것을 생각하지 않았기 때문이다.

만약 @code{fill-column}이 list의 하나 뿐인 요소라면, Lisp 해석기는 이 기호에 연결
된 함수 정의를 찾으려고 할 것이다. 그러나 @code{fill-column}은 어떤 함수 정의도 
가지고 있지 않다. 이 기호를 평가하는 것을 시도해보자.:

@smallexample
(fill-column)
@end smallexample

@need 1250
@noindent
GNU Emacs 22 버전에서는 @file{*Backtrace*} 버퍼를 생성할 것이다.

@smallexample
@group
---------- Buffer: *Backtrace* ----------
Debugger entered--Lisp error: (void-function fill-column)
  (fill-column)
  eval((fill-column))
  eval-last-sexp-1(nil)
  eval-last-sexp(nil)
  call-interactively(eval-last-sexp)
---------- Buffer: *Backtrace* ----------
@end group
@end smallexample

@noindent
( 기억해라. 디버거를 종료하고 디버거 윈도우를 날리기 위해서 @file{*Backtrace*} 버퍼에서 @kbd{q}를 입력하라. )

@ignore
@need 800
GNU Emacs 20 버전 이하에서는 에러 메시지가 나타날 것이다.

@smallexample
Symbol's function definition is void:@: fill-column
@end smallexample

@noindent
( 이메시지는 커서를 옮기거나 다른 키를 입력하는 순간 사라진다. )
@end ignore


@node Void Variable,  , Void Function, Variables
@comment  node-name,  next,  previous,  up
@subsection Error Message for a Symbol Without a Value
@cindex Symbol without value error
@cindex Error for symbol without value

bind된 값이 없는 기호를 평가하려고 한다면 에러 메시지를 만날 것이다. 2 더하기 2를 
실험하는 것으로 볼 수 있다. 다음 표현에서 커서를 @code{+} 와 첫 숫자 2 사이에 놓고 
@kbd{C-x C-e}를 입력한다.

@smallexample
(+ 2 2)
@end smallexample

@need 1500
@noindent
GNU Emacs 22 버전에서 @file{*Backtrace*} 버퍼가 만들어진다.

@smallexample
@group
---------- Buffer: *Backtrace* ----------
Debugger entered--Lisp error: (void-variable +)
  eval(+)
  eval-last-sexp-1(nil)
  eval-last-sexp(nil)
  call-interactively(eval-last-sexp)
---------- Buffer: *Backtrace* ----------
@end group
@end smallexample

@noindent
( 디버거를 들어간 다른 때 처럼 @file{*Backtrace*} 버퍼에서 @kbd{q}를 입력함으로 빠져나올 수 있다. )

이 @samp{Debugger entered--Lisp error: (void-function this)}에 있던 첫 에러 
메시지와는 backtrace는 다르다. 이 경우 함수는 변수로서 값을 가지고 있지 않다.; 다른 
에러 메시지에서 함수는 ( ‘this’ 단어 ) 정의를 가지고 있지 않았다.

@code{+}의 실험에서 @code{+}를 평가하는 Lisp 해석기는 함수 정의 대신에 변수의 
값을 찾고자 했다. 커서를 List의 닫는 괄호가 아닌 기호 바로 옆에 놓았다. 결과적으로 
Lisp 해석기는 커서 바로 앞의 기호를 평가했다. 이 경우에는 @code{+} 그 자체이다.

@code{+}는 단지 함수 정의이지 bind된 값이 없기 때문에 에러 메시지는 변수로서 그 기호의 값이 void라는 것을 알려준다.

@ignore
@need 800
GNU Emacs 20 버전 이하에서는 다음과 같은 에러 메시지가 출력된다.

@example
Symbol's value as variable is void:@: +
@end example

@noindent
이 의미는 GNU 22 버전과 동일하다.
@end ignore


@node 인자들, set & setq, Variables, List 처리하기
@comment  node-name,  next,  previous,  up
@section 인자들
@cindex Arguments
@cindex Passing information to functions

정보가 함수로 전달되는 방법을 보기 위해 예전의 준비물인 2 더하기 2를 보자. Lisp에서 
다음처럼 작성한다.

@smallexample
(+ 2 2)
@end smallexample

이 표현을 평가하면 숫자 4가 echo 영역에 나타날 것이다. Lisp 해석기는 @code{+} 
뒤에 숫자들을 더한다.

@cindex @samp{argument} defined
@code{+}가 더하는 숫자들은 함수 @code{+}의 @dfn{arguments}라 부른다. 이 
숫자들은 함수에 @dfn{passed}되는 정보들이다.

‘argument” 단어는 수학에서 사용된 방법에서 유래되었다. 그리고 두 사람 사이의 분쟁을 
의미하는 것이 아니다.; 대신 이 경우에 함수 @code{+}에 넘겨지는 정보를 가리킨다. 
Lisp에서 함수에 인자들은 함수 뒤에 오는 atom 또는 list 이다. 이 atom 또는 list의 
평가에 의해서 넘겨지는 값들은 함수로 전달된다. 다른 함수들은 다른 개수의 인자들을 
요구한다.; 어떤 함수는 아무 것도 요구하지 않는다.@footnote{‘argument’ 단어가 
수학에서 의미, 일상 영어에서의 의미가 서로 다른 것에 대한 흔적을 찾는 것은 특이하다. 
@cite{Oxford English Dictionary}에 따르면, 이 단어는 @samp{분명하게 하다, 
증명하다}라는 Latin어에서 유래되었다.; 그래서 한 어원의 실을 따라가면 `증명을 하기 
위해 제시되는 증거`이고 여기서 Lisp에서는 `제공되는 정보`로 되었다. 그러나 다른 
어원의 실을 따라가면 `반대 주장에 대해서 주장하는 것`에서 분쟁같은 단어의 의미로 
되었다. (여기서 영어 단어는 동시에 두 가지 다른 정의를 가진다. 반면에 Emac 
Lisp에서는 기호는 동시에 두 개의 다른 함수 정의를 가질 수 없다. )}

@menu
* Data types::                  Types of data passed to a function.
* Args as Variable or List::    An argument can be the value
                                  of a variable or list.
* 여러 개의 인자들::  Some functions may take a
                                  variable number of arguments.
* Wrong Type of Argument::      Passing an argument of the wrong type
                                  to a function.
* message::                     A useful function for sending messages.
@end menu


@node Data types, Args as Variable or List, 인자들, 인자들
@comment  node-name,  next,  previous,  up
@subsection 인자의 데이터 타입
@cindex Data types
@cindex Types of data
@cindex Arguments' data types

데이터의 타입은 사용하는 정보의 종류에 맞게 함수에 전달되어야 한다. @code{+}가 
숫자들을 더하기 때문에 @code{+} 같은 함수의 인자들은 숫자 값들이어야 한다.
다른 함수들은 인자에 맞게 다른 종류의 데이터를 사용한다.

@need 1250
@findex concat
예를 들면 @code{concat} 함수는 둘 또는 그 이상의 문자열들을 연결하거나 하나로 
만든다. 인자들은 문자열이다. 두 문자열 @code{abc}, @code{def}를 연결 시켜 단일 
문자열 @code{abcdef}를 만든다. 다음을 평가 함으로 결과를 볼 수 있다.:

@smallexample
(concat "abc" "def")
@end smallexample

@noindent
이 표현을 평가하면 @code{“abcdef”} 값이 만들어진다.

@code{substring} 같은 함수는 문자열과 숫자를 모두를 인자로 받는다. 이 함수는 첫 
인자의 부분 문자열로 문자열의 일부분을 넘겨준다. 이 함수는 3개의 인자를 받는다. 첫 
인자는 문자열이고 두 번째와 세 번째는 부분 문자열의 시작과 끝을 의미하는 숫자이다. 
숫자들은 문자열의 시작부터( 공백과 구두점들을 포함한 ) 문자의 개수이다.

@need 800
예제로 다음을 평가한다면:

@smallexample
(substring "The quick brown fox jumped." 16 19)
@end smallexample

@noindent
echo 영역에 @code{“fox”}이 나타날 것이다. 인자들은 문자열과 2 개의 숫자이다.

@code{substring}에 전달되는 문자열은 공백에 의해서 구분되는 여러 단어로 
구성되었지만 단일 atom 이다. Lisp은 두 따옴표 기호 사이에 모든 것을 공백을 포함해서 
문자열의 일부분으로 계산한다. 개별 atom을 받아서 일부분을 추출하기 때문에 
@code{substring} 함수를 `atom 분쇄기`의 종류로 생각할 수 도 있다. 그러나 
@code{substring}은 숫자나 기호같은 atom의 종류가 아닌 문자열 인자로 부터 단지 
부분 문자열을 빼는 것만 가능하다.



@node Args as Variable or List, 여러 개의 인자들, Data types, Arguments
@comment  node-name,  next,  previous,  up
@subsection 변수의 값 또는 list인 인자

인자는 평가될 때 값을 넘겨주는 기호가 될 수 있다. 예를 들면 @code{fill-column} 
기호는 평가될 때 숫자를 넘긴다. 이 숫자는 추가로 사용될 수 있다.

@need 1250
다음 표현 뒤에 커서를 위치한 후, @kbd{C-x C-e}를 입력해라.

@smallexample
(+ 2 fill-column)
@end smallexample

@noindent
값은 @code{fill-column}을 평가한 것에 2가 더해진 숫자가 될 것이다. 나의 경우 
@code{fill-column}이 72이기 때문에 74이다.

앞에서 본 것처럼 인자는 평가 시 값을 넘겨주는 기호가 될 수 있다. 게다가 인자는 평가 시 
값을 넘겨주는 list가 될 수 있다. 예를 들면 다음 표현에서 @code{concat} 함수의 
인자는 문자열 @w{@code{“The”}}와 @w{@code{“ red foxex.”}} 이고, 
@code{(number-to-string(+ 2 fill-column))} list이다.

@c For GNU Emacs 22, need number-to-string
@smallexample
(concat "The " (number-to-string (+ 2 fill-column)) " red foxes.")
@end smallexample

@noindent
이 표현을 평가하면—내 Emacs에서는 @code{fill-column}은 72 이다.—
@code{“The 74 red foxes.”}이 echo 영역에 나타날 것이다. ( @samp{The} 단어 
뒤와 @samp{red} 앞에 공백을 넣어야 한다. @code{number-to-string} 함수는 
숫자를 문자열로 변환하여 넘겨준다. @code{number-to-string}은 
@code{int-to-string}으로도 알려졌다.



@node 여러 개의 인자들, Wrong Type of Argument, Args as Variable or List, 인자들
@comment  node-name,  next,  previous,  up
@subsection 여러 개의 인자들
@cindex Variable number of arguments
@cindex Arguments, variable number of

@code{concat}, @code{+}, @code{*} 같은 함수들은 원하는 개수의 인자를 받는다. 
( @code{*}은 곱하기를 위한 기호이다. ) 보통 다음 표현들의 각각을 평가하는 것으로 볼 
수 있다. echo 영역에 `로 평가된다.`로 읽을 수 있는 @samp{@result{}} 뒤에 있는 
것이 echo 영역에 출력되는 것을 볼 수 있다.

@need 1250
첫 번째로 함수는 인자를 받지 않는다.

@smallexample
@group
(+)       @result{} 0

(*)       @result{} 1
@end group
@end smallexample

@need 1250
이 예제에서 함수들은 각 1개의 인자를 받는다.

@smallexample
@group
(+ 3)     @result{} 3

(* 3)     @result{} 3
@end group
@end smallexample

@need 1250
다음 예에서 함수들은 각 3개의 인자를 받는다.

@smallexample
@group
(+ 3 4 5) @result{} 12

(* 3 4 5) @result{} 60
@end group
@end smallexample


@node Wrong Type of Argument, message, 여러 개의 인자들, 인자들
@comment  node-name,  next,  previous,  up
@subsection잘못된 타입의 인자를 사용하기
@cindex Wrong type of argument
@cindex Argument, wrong type of

함수에 잘못된 타입의 인자가 넘겨지면 Lisp 해석기는 에러 메시지를 출력한다. 예를 들면 
@code{+} 함수는 인자들의 값으로 숫자를 기대한다. 실험처럼 숫자 대신 따옴표로 
시작하는 @code{hello}를 넘겨볼 수 있다. 다음 표현 뒤에 커서를 이동한 후 
@kbd{C-x C-e}를 입력해보자.

@smallexample
(+ 2 'hello)
@end smallexample

@noindent
그러면 에러 메시지를 볼 것이다. @code{+}는 숫자 2를 @code{‘hello}에 의해서 
넘겨지는 값과 더하려고 했으나, @code{‘hello}가 넘겨주는 값은 숫자가 아닌 
@code{hello} 기호이다. 오직 숫자들만 더할 수 있다. 그래서 @code{+}는 더하기를 
수행할 수 없었다.

@need 1250
GNU Emacs 22 버전에서는 @file{*Backtrace*} 버퍼에 다음과 같이 나타난다.:

@noindent
@smallexample
@group
---------- Buffer: *Backtrace* ----------
Debugger entered--Lisp error:
         (wrong-type-argument number-or-marker-p hello)
  +(2 hello)
  eval((+ 2 (quote hello)))
  eval-last-sexp-1(nil)
  eval-last-sexp(nil)
  call-interactively(eval-last-sexp)
---------- Buffer: *Backtrace* ----------
@end group
@end smallexample

@need 1250
늘 그렇듯이 에러 메시지를 읽는 방법을 배운 후 에러 메시지는 도움을 주려고 노력하고 
이해시키려고 한다.@footnote{@code{(quote hello)}는 약어 @code{‘hello}의 
확장이다.}

에러 메시지의 첫 부분은 간단하다.; @samp{잘못된 인자}를 말한다. 다음은 이해하기 
힘든 전문 단어 @w{@samp{number-or-marker-p}}가 온다. 이 말은 @code{+}가 
기대하는 인자의 종류가 무엇인지 말하는 것이다.

기호 @code{number-or-maker-p}는 Lisp 해석기가 정보가 표현하고자 하는 것이
( 인자의 값 ) 숫자인지 marker( 버퍼 위치를 나타내는 특별한 객체 ) 인지 결정하고 노력
하는 중이라는 것을 말한다. 이는 더할 숫자가 @code{+}에 주어졌는지 확인하는 것이다.  
또한 이는 인자가 Emacs Lisp의 특별한 특징인 marker라 부르는 것인지도 검사한다. 
( Emacs에서 버퍼의 위치는 marker로서 기록된다. @kbd{C-@@} 또는 @kbd{C-
@key{SPC}} 명령으로 mark가 설정될 때, 그 위치는 marker로 보관된다.  mark는 
숫자로 간주된다. —위치는 버퍼의 시작부터 문자들의 개수이다. ) Emacs Lisp에서 
@code{+}는 숫자로서 marker 위치의 숫자 값을 더할 수 있다.

@code{number-or-marker-p}의 @samp{p}는 Lisp 프로그래밍의 초창기에 시작된 
전형이다.  @samp{p}는 ‘predicate’를 나타낸다. 초기 Lisp 연구자들이 사용한 
용어에서 predicate는 어떤 속성이 참 또는 거짓인지 판단하는 함수를 가리킨다. 그래서 
@samp{p}는 @code{number-or-maker-p}가 제공되는 인자가 숫자 또는 marker
인지 판단하여 참 또는 거짓을 알려주는 함수의 이름이라는 것을 말한다. @samp{p}로 
끝나는 다른 Lisp 기호들로 인자가 0의 값을 가지는지 확인하는 @code{zerop}와 
인자가 list인지 검사하는 @code{listp}가 있다.

마지막으로 에러 메시지의 마지막 부분은 기호 @code{hello}이다. @code{+}에 
전달되는 인자의 값이다. 객체의 올바른 타입이 전달되었다면 @code{hello} 같은 기호가 
아닌 37같은 값은 숫자였을 것이다. 그랬으면 에러 메시지를 받지 않았을 것이다.

@ignore
@need 1250
GNU Emacs 20 버전 이하에서 echo 영역에 다음과 같은 에러 메시지가 출력될 것이다.:

@smallexample
Wrong type argument:@: number-or-marker-p, hello
@end smallexample

다른 단어로 나타나지만 위의 @file{*Backtrace*} 버퍼에 있는 것과 같은 의미이다.
@end ignore


@node message,  , Wrong Type of Argument, 인자들
@comment  node-name,  next,  previous,  up
@subsection@code{message} 함수
@findex message

@code{+} 같이 @code{message} 함수는 여러 개의 인자를 받는다. 사용자에게 
메시지를 보낼 때 사용되고 앞으로 설명할 것처럼 꽤 유용하다.

@need 1250
메시지는 echo 영역에 출력된다. 예를 들면 다음을 평가하면 echo 영역에 메시지를 출력
할 수 있다.

@smallexample
(message "This message appears in the echo area!")
@end smallexample

큰따옴표 사이에 모든 문자열은 하나의 인자이고 @i{in toto} 출력된다. ( 이 예제에서 
메시지 자체는 echo 영역에 큰따옴표와 같이 나타날 것이다.; @code{message} 
함수에서 넘겨 받은 값이기 때문이다. 작성한 프로그램에서 @code{message}의 
대부분의 용도로 부작용으로 echo 영역에 따옴표 없이 글이 출력될 것이다. 
@xref{multiply-by-seven in detail, , @code{multiply-by-seven} in detail}, 
이 것에 대한 예 )

그러나, 따옴표 안의 문자열에 @samp{%s}가 있다면 @code{message} 함수는 
@samp{%s}를 출력하지 않는다. 대신 문자열 뒤에 오는 인자를 본다. 두 번째 인자를
평가하고 @samp{%s} 위치에 그 값을 출력한다.

@need 1250
다음 표현 뒤에 커서를 옮긴 후, @kbd{C-x C-e}를 입력하라.

@smallexample
(message "The name of this buffer is: %s." (buffer-name))
@end smallexample

@noindent
Info에서는 @code{“The name of this buffer is : *info*.”}이 echo 영역에 나타날 
것이다. @code{buffer-name} 함수는 문자열로 현재 버퍼 이름을  넘겨주고 
@code{message} 함수는 이 값을 @code{%s} 위치에 삽입한다.

숫자로 값을 출력하기 위해서는 @samp{%s}와 같은 방법으로 @samp{%d}를 사용하라. 예를 들면 echo 영역에 @code{fill-column} 값을 메시지에 출력하려면 다음을 평가하라.:

@smallexample
(message "The value of fill-column is %d." fill-column)
@end smallexample

@noindent
내 시스템에서 수행해보면 @code{“The value of fill-column is 72.”}이 echo 영역에 나타난다.@footnote{실제로 숫자를 출력하기 위해 @code{%s}를 사용할 수 있다. 일반적이지는 않다. @code{%d}는 소숫점의 왼쪽 부분을 출력하고 숫자가 아닌 것은 출력하지 않는다.} 

만약에 따옴표로 묶인 문자열에 하나 이상의 @samp{%s}가 있다면 따옴표로 묶인 
문자열 다음의 첫 번째 인자의 값은 첫 번째 @samp{%s}의 위치에 출력되고 두 번째 
인자의 값은 두 번째 @samp{%s}의 위치에 출력된다.

@need 1250
예를 위해서 다음을 평가해보면

@smallexample
@group
(message "There are %d %s in the office!"
         (- fill-column 14) "pink elephants")
@end group
@end smallexample

@noindent
다소 기발한 메시지가 echo 영역에 나타날 것이다. 내 시스템에서는 @code{“There a
re 58 pink elephants in the office!”}가 나타난다.

표현 @code{(- fill-column 14)}은 평가되고 결과 숫자는 @samp{%d} 위치에 
삽입된다.; 큰따옴표로 묶인 문자열 @code{“pink elephants”}은 단일 인자로 다뤄지고 
@samp{%s} 위치에 삽입된다. ( 큰따옴표로 묶인 문자열은 숫자와 같이 그 자체로 
평가된다. )

마지막으로 단지 숫자의 계산이 아닌 여기 복잡한 예제가 있다.그리고 @samp{%s}가 
대체된 글을 만들어 내는 표현을 가진 표현을 사용하는 방법도 보여준다.

@smallexample
@group
(message "He saw %d %s"
         (- fill-column 32)
         (concat "red "
                 (substring
                  "The quick brown foxes jumped." 16 21)
                 " leaping."))
@end group
@end smallexample

이 예제에서 @code{message}는 3개의 인자를 가진다.; @code{“He saw %d %s”} 
문자열, 표현식 @code{(- fill-column 32)}  그리고 @code{concat} 함수로 
시작하는 표현식이다. @code{(- fill-column 32)}의 평가의 결과 값은 @samp{%d} 
위치에 삽입된다.; 그리고 @code{concat}로 시작하는 표현식의 결과 값은 
@samp{%s} 위치에 삽입된다.

fill-column이 70이고 표현식을 평가하면 메시지 @code{“He saw 38 red foxes 
leaping.”}가 echo 영역에 나타날 것이다.



@node set & setq, 정리, 인자들, List 처리하기
@comment  node-name,  next,  previous,  up
@section 변수에 값 설정하기
@cindex Variable, setting value
@cindex Setting value of variable

@cindex @samp{bind} defined
변수의 값을 변경하는 것은 여러가지 방법이 있다. 이 방법 중의 하나는 @code{set} 함수 
또는 @code{setq} 함수를 사용하는 것이다. @code{let}(@pxref{let})를 사용하는 
다른 방법도 있다. ( 이런 과정을 변수에 값을 @dfn{bind}한다고 한다. )

다음 절들은 @code{set}과 @code{setq}가 동작하는 것 뿐만 아니라 인자들이 
전달되는 방식도 설명한다.

@menu
* set 사용하기::                  값 설정하기.
* setq 사용하기::                 따옴표 붙은 값 설정하기.
* 숫자 세기::                   숫자 세기에 @code{setq}를 사용하기.
@end menu


@node set 사용하기, setq 사용하기, set & setq, set & setq
@comment  node-name,  next,  previous,  up
@subsection @code{set} 사용하기
@findex set

기호 @code{flowers}의 값을 list @code{‘(rose violet daisy buttercup)}로 
설정하기 위해 표현식 뒤에 커서를 놓고 @kbd{C-x C-e}를 입력해라.

@smallexample
(set 'flowers '(rose violet daisy buttercup))
@end smallexample

@noindent
@code{(rose violet daisy buttercup)} list가 echo 영역에 나타날 것이다. @code{set} 함수의 결과로 
@emph{returned} 된 것이다. 추가 효과로 기호 @code{flowers}는 이 list에 바인딩 되었다.; 기호 
@code{flowers}는 변수로서 볼 수 있고 list가 값이다. ( 그런데 이 과정은 값을 설정하는 해석기의 추가 
효과가 사람들이 관심 있어 하는 주요 효과를 보게 될 수 있다는 것을 보여준다. 모든 Lisp 함수는 에러가 
아니라면 값을 넘겨줘야 한다. 그러나 하나의 부수 효과를 가지게 설계되었다면 오직 하나의 부수 효과를 볼 
것이다. )

@code{set} 표현식을 평가한 후, 기호 @code{flowers}를 평가할 수 있다. 그리고 단지 설정한 값을 넘길 
것이다. 여기 기호가 있다. 그 기호 뒤에 커서를 옮긴 후, @kbd{C-x C-e}를 입력해보라.

@smallexample
flowers
@end smallexample

@noindent
@code{flowers}를 평가할 때, list @code{(rose violet daisy buttercup)}는 echo 영역에 보일 것이다. 

우연히 변수 앞에 작은 따옴표가 있는 @code{‘flowers}를 평가하면 echo 영역에 그 자체  기호 그 자체 
@code{flowers}가 나타날 것이다. 여기 그 기호가 있고, 시험해볼 수 있다.

@smallexample
'flowers
@end smallexample

@code{set}을 사용할 때, 두 인자가 평가되기를 원하지 않는다면 @code{set}에 두 인자들에 작은 따옴표가 
필요하다. 인자가 평가되는 것을 원하지 않기 때문에 변수 @code{flowers} 와 list @code{(rose violet 
daisy buttercup)}는 작은 따옴표가 붙어있다. ( 첫 인자에 작은 따옴표 없이 @code{set}을 사용할 때, 첫 
인자가 먼저 평가된다. 만약 @code{flowers}가 값을 가지지 않은 상태에서 이렇게 한다면 
@samp{Symbol’s value as variable is void}라는 에러 메시지를 볼 것이다.; 반면에 @code{flowers}가 
평가된 후에 값을 넘겨준다면 @code{set}은 넘겨 받은 값에 설정하려고 할 것이다. 이 동작은 제대로 된 
동작이다.; 그러나 매우 드문 상황이다. )


@node setq 사용하기, 숫자 세기, set 사용하기, set & setq
@comment  node-name,  next,  previous,  up
@subsection @code{setq} 사용하기
@findex setq

실제로 @code{set}의 첫 인자를 거의 항상 따옴표를 붙인다. @code{set} 과 따옴표가 붙은 첫 인자의 
조합은 별도의 이름을 가질 정도로 일반적이다.: 특별한 형태의 @code{setq}. 이 특별한 형태는 첫 인자가
자동으로 따옴표가 붙는 것을 제외하고는 @code{set}과 같다. 그래서 따옴표를 붙일 필요가 없다. 또한 추가된
편리함으로 @code{setq}는 하나의 표현식에 여러 개의 변수들에 값들을 설정하는 것을 허용한다.

@code{setq}를 사용하여 @code{carnivores} 변수에 list @code{‘(lion tiger leopard)} 값을 
설정하려면 다음 표현식이 사용된다.:

@smallexample
(setq carnivores '(lion tiger leopard))
@end smallexample

@noindent
@code{setq}에 의해서 첫 인자에 자동으로 따옴표가 붙는 것을 제외하면 @code{set}을 사용하는 것과 
정확히 같다. ( @code{setq}에서 @samp{q}는 @code{quote}를 의미한다. )

@need 1250
@code{set}에서는 다음같은 표현식으로 보일 것이다.

@smallexample
(set 'carnivores '(lion tiger leopard))
@end smallexample

또한 @code{setq}는 다른 변수들에 다른 값들을 설정하는데 사용될 수 있다. 첫 인자는 두 번째 인자의 값이 
바인딩 되고, 세 번째 인자는 네 번째 인자의 값이 바인딩 된다. 예를 들면 @code{trees} 기호에 나무들 list를 
@code{herbivores} 기호에 초식 동물 list를 설정하기 위해 다음처럼 쓸 수 있다.

@smallexample
@group
(setq trees '(pine fir oak maple)
      herbivores '(gazelle antelope zebra))
@end group
@end smallexample

@noindent
(표현식은 한 줄에 쓰여질 수 있지만, 한 페이지에 맞지 않을 수 있다.; 잘 형식화된 list들은 읽는 것은 쉽다. )

`assign` 용어를 사용했지만, @code{set}과 @code{setq}의 동작에 대해서 다른 방식의 생각하는 방법이 
있다.; @code{set}과 @code{setq}는 기호가 list를 @emph{가리키게} 만든다라고 말할 수 있다. 이 뒤의 
방식은 매우 일반적이고 뒤의 장에서 적어도 그 이름의 일부분으로 `pointer`를 가지는 하나의 기호를 접할 
것이다. 기호가 값, 특히 list를 가지고 이름에 붙기때문에 이름은 선택된다.; 또는 다른 방식으로 표현하면 
기호에 list의 “point”가 설정된다.



@node 숫자 세기,  , setq 사용하기, set & setq
@comment  node-name,  next,  previous,  up
@subsection 숫자 세기
@cindex Counting

숫자 세는 것에서 @code{setq}를 사용하는 방법을 보여주는 예가 있다. 프로그램 일 부분이 몇 번 반복했는지 
세기위해 사용할 수 있다. 처음에 변수에 0을 설정한다.; 프로그램이 반복할 때마다 매번 1을 더한다. 이것을 
하기 위해서 숫자를 저장할 계수기 변수와 두 표현식이 필요하다.: 첫 번째 @code{setq} 표현식은 계수기 
변수에 0을 설정한다.; 두 번째 @code{setq} 표현식은 평가될 때마다 계수기에 1을 증가시킨다.

@smallexample
@group
(setq counter 0)                ; @r{Let's call this the initializer.}

(setq counter (+ counter 1))    ; @r{This is the incrementer.}

counter                         ; @r{This is the counter.}
@end group
@end smallexample

@noindent
(@samp{;} 뒤에 오는 글은 주석이다. @xref{Change a defun, , 함수 정의 변경하기}.)

첫 번째 표현식 @code{(setq counter 0)} 평가 후, 세 번째 표현식 @code{counter} 평가하면,  숫자 
@code{0}이 echo 영역에 나타날 것이다. 이 때 두번째 표현식 @code{(setq counter (+ counter 1))}을 
평가하면, counter는 값 1을 가질 것이다. @code{counter}를 다시 평가하면, 숫자 @code{1}이 echo 
영역에 나타날 것이다. 두 번째 표현식을 수행할 때 마다 counter의 값은 증가할 것이다.

@code{(setq counter (+ counter 1))}을 평가할 때, Lisp 해석기는 가장 안쪽의 list를 먼저 평가한다.; 
추가적으로 이 list를 평가하기 위해서는 변수 @code{counter}와 숫자 @code{1}을 평가해야 한다. 변수 
@code{counter}를 평가하면 현재 값을 받는다. 이 값과 숫자 @code{1}을 두 값을 더하는 @code{+}에 
전달한다. 안 쪽 list의 값으로 합이 전달되고 @code{setq}는 변수 @code{counter}에 이 새로운 값을 
설정한다. 그래서 변수 @code{counter}의 값은 변경된다.


@node 정리, Error Message Exercises, set & setq, List 처리하기
@comment  node-name,  next,  previous,  up
@section 정리

Lisp을 배우는 것은 첫 부분이 가파른 언덕을 올라가는 것과 같다. 가장 어려운 부분에 올라갔다.; 남은 부분은 
진행할수록 쉬울 것이다.

@need 1000
요약하면,

@itemize @bullet

@item
Lisp 프로그램은 list또는 단일 atom들인 표현식들로 구성된다.

@item
List는 공백 또는 괄호들에 둘러쌓임으로 구분되어지는 atom들 또는 내부 list로 구성된다. list는 비어있을 수 
있다.

@item
Atom은 @code{foward-paragraph}같이 여러 문자 기호, @code{+}같이 단일 문자 기호, 이중 따옴표 
사이에 있는 문자열, 또는 숫자들이다.

@item
숫자는 그 자체로 평가된다.

@item
이중 따옴표 사이에 있는 문자열 또한 그 자체로 평가된다.

@item
기호 자체를 평가할 때, 그 값이 반환된다.

@item
list를 평가할 때, Lisp 해석기는 List의 첫 번째 기호를 살펴보고 기호에 함수 정의가 바인딩되었을 때, 그 함수 
정의가 해석된다.

@item
단일 다옴표,
@ifinfo
'
@end ifinfo
@ifnotinfo
@code{'}
@end ifnotinfo
, 바로 뒤에 쓰여진 표현식을 따옴표가 없었을 때처럼 평가하는 것이 아닌 그대로 반환한다는 것을 Lisp 
해석기에게 이야기 한다.

@item
인자들은 함수에 전달되는 정보이다. 함수에 전달되는 인자들은 List의 첫 요소는 함수이고 List의 나머지 
요소들의 평가에 의해 계산된다.

@item
함수는 항상 평가된 값을 넘겨준다. ( 에러를 받지 않는다면 ); 게다가 “side effect” 라고 이야기하는 어떤 
행동을 수행할 수도 있다. 대부분의 경우에 함수의  주요 목적은 side effect를 생성하는 것이다.
@end itemize


@node Error Message Exercises,  , 정리, List 처리하기
@comment  node-name,  next,  previous,  up
@section 연습문제

몇 개의 간단한 예제들
A few simple exercises:

@itemize @bullet
@item
괄호가 없는 적절한 기호를 평가하여 에러 메시지를 생성해봐라.

@item
괄호 사이에 있는 적절한 기호를 평가하여 에러 메시지를 생성해봐라.

@item
1인 아닌 2씩 증가하는 카운터를 만들어보아라.

@item
평가될 때, echo 영역에 메시지를 출력하는 표현식을 작성하라.
@end itemize


@node 평가 연습하기, Writing Defuns, List 처리하기, Top
@comment  node-name,  next,  previous,  up
@chapter 평가 연습하기
@cindex Practicing evaluation
@cindex Evaluation practice

Emacs Lisp으로 함수 정의를 작성하는 방법을 배우기 전에, 이미 작성했던 다양한 표현식들을 평가하는 것에 
약간의 시간을 사용하는 것이 유용하다. 이 표현식들은 첫 요소가 함수로 된 list들일 것이다. 몇몇 함수들은 
간단하고 흥미로운 버퍼와 연관되어있다. 이 것들을 먼저 볼 것이다. 이 장에서 이 것들 중 몇 가지를 평가할 
것이다. 다른 장에서 몇 개의 다른 버퍼 관련 함수들의 코드들이 어떻게 작성되었는지 학습할 것이다.

@menu
* How to Evaluate::            Typing editing commands or @kbd{C-x C-e}
                                 causes evaluation.
* 버퍼 이름::               Buffers and files are different.
* 버퍼 얻기::            Getting a buffer itself, not merely its name.
* 버퍼 변경하기::          How to change to another buffer.
* 버퍼 크기와 위치::    Where point is located and the size of
                               the buffer.
* 연습문제 평가::
@end menu

@node How to Evaluate, 버퍼 이름, 평가 연습하기, 평가 연습하기
@ifnottex
@unnumberedsec How to Evaluate
@end ifnottex

커서를 움직이거나, 화면을 스크롤 하는 명령 같이 Emacs Lisp에 @i{편집 명령을 입력할 때마다}, 첫 요소가 
함수인 @i{표현식을 평가하는 것이다.} @i{Emacs가 동작하는 방식이다.}

@cindex @samp{interactive function} defined
@cindex @samp{command} defined
키를 입력할 때, Lisp 해석기는 표현식을 평가하게 되고 그 것은 결과를 얻는 방법이다. 평범한 글을 
입력하더라도 Emacs Lisp 함수를 평가하게 된다. 이 경우에 입력한 문자를 단순히 추가하는 
@code{self-insert-command} 가 사용된다. 키 두드림에 의해서 평가하는 함수는 @dfn{대화형
(interative)} 함수 또는 @dfn{명령(commands)}이라고 불린다.; 대화형 함수를 만드는 방법은 이 장에서 
함수 정의를 작성하는 방법에서 설명할 것이다.  @xref{Interactive, , Making a Function Interactive}.

키보드 명령을 입력하는 것에 추가로 표현식을 평가하는 두 번째 방법을 보았다.: list의 뒤에 커서를 옮긴 후, 
@kbd{C-x C-e}를 입력한다. 이 장의 나머지에서 사용할 것이다. 또한 표현식을 평가하는 다른 방법들도 
있다.; 이 방법들은 다시 접하게 되면 설명될 것이다.

평가 연습하는 것에 더불어 다음 몇 장에서 보여지는 함수들은 그 자체로도 중요하다. 이 함수들의 학습은 버퍼와 
파일 간의 차이, 버퍼를 바꾸는 방법 그리고 그 안의 위치를 정하는 방법들을 명확하게 한다.



@node 버퍼 이름, 버퍼 얻기, How to Evaluate, 평가 연습하기
@comment  node-name,  next,  previous,  up
@section 버퍼 이름
@findex buffer-name
@findex buffer-file-name

@code{buffer-name}과 @code{buffer-file-name} 두 함수는 파일과 버퍼의 다른 점을 보여준다. 
@code{(buffer-name)} 표현식을 평가하면 echo 영역에 버퍼 이름이 나타난다. 
@code{(buffer-file-name)}을 평가하면, 버퍼가 참조하고 있는 파일 이름이 echo 영역에 나타난다. 보통 
@code{(buffer-name)}에서 받은 이름은 버퍼가 참조하고 있는 파일의 이름과 동일하다. 그리고 
@code{(buffer-file-name)}에서 받은 이름은 파일의 전체 경로 이름이다.

파일과 버퍼는 다른 존재이다. 파일은 컴퓨터에 (지우지 않는다면)영구적으로 기록된 정보이다. 반면에 버퍼는 
편집 세션의 끝에서(또는 버퍼를 제거할 때) 사라질 Emacs 안의 정보이다. 보통 버퍼는 파일로부터 복사한 
정보를 가지고 있다.; 버퍼가 파일을 @dfn{방문하고(visiting)} 있다고 말한다. 버퍼를 저장하지 않는다면, 
버퍼의 변경은 파일을 변경하지 않는다. 버퍼를 저장할 때, 버퍼가 파일로 복사되고 영구적으로 저장된다.

@need 1250
GNU Emacs의 info에서 이 문서를 읽고 있다면 다음 표현식들의 끝에 커서를 옮긴 후, @kbd{C-x C-e}를 
입력하여 평가할 수 있다.

@example
@group
(buffer-name)

(buffer-file-name)
@end group
@end example

@noindent
Info에서 이것을 할 때, @code{(buffer-name)} 평가의 값은 @file{"*info*"}이다. 그리고 
@code{(buffer-file-name)}의 결과 값은 @file{nil}이다.

반면에 이 문서를 작성하는 동안 @code{(buffer-name)}의 결과 값은 @file{"introduction.texinfo"} 이고,  
@code{(buffer-file-name)}의 결과 값은 @file{"/gnu/work/intro/introduction.texinfo"} 이다.

@cindex @code{nil}, history of word

전자는 버퍼의 이름이고, 후자는 파일의 이름이다. Info에서 버퍼 이름은 @file{"*info*"}이다. Info는 어떤 
파일도 가리키지 않는다. 그래서 @code{(buffer-file-name)}의 결과는 @file{nil}이다. 기호 @code{nil}은 
‘아무것도 아니다.’는 라틴어에서 유래됐다.; 이 경우에 버퍼는 어떤 파일과도 관련이 없다는 것을 의미한다. 
(Lisp에서 @code{nil}은 ‘false’를 의미하는데 쓰여지고 빈 list @code{()} 와 동의어이다. )

이 글을 작성할 때, 버퍼의 이름은 @file{"indroduction.texinfo"}였다. 파일의 이름은 
@file{"/gnu/work/intro/introduction.texinfo"} 이었다.

( 표현식에서 괄호는 Lisp 해석기에게 @w{@code{buffer-name}}과 @w{@code{buffer-file-name}}을 
함수로서 다루라는 것을 이야기한다.; 괄호가 없다면 해석기는 변수로서 기호를 평가했을 것이다. 
@xref{Variables} )

파일과 버퍼를 구분함에도 파일과 버퍼를 종종 동일하게 취급하는 사람들을 찾을 수 있을 것이다. 정말로 
대부분의 사람들은 “곧 파일에 저장할 버퍼를 편집하고 있습니다.”로 말하는 것 대신 “파일을 편집하고 
있습니다.”로 이야기 한다. 의미하는 문맥은 거의 항상 명확하다. 그러나 컴퓨터는 사람만큼 똑똑하지 않기 
때문에 컴퓨터 프로그램을 다룰 때 마음속에서 차이를 유지하는 것은 중요하다.

@cindex Buffer, history of word
그런데’ 버퍼’ 단어는 충돌의 힘을 줄여주는 쿠션이라는 단어의 뜻에서 유래되었다. 초기 컴퓨터들에서 버퍼는 
파일과 컴퓨터의 중앙 처리 장치 사이에 상호 작용에 대한 완충 작용을 했다. 파일을 저장한 드럼 또는 
테이프들과 중앙 처리 장치는 동작하는 속도에서 서로 매우 다른 장치들이었다. 버퍼가 그 장치들이 효율적으로 
동작하는 것을 가능하게 만들었다. 결국 버퍼는 임시로 저장하는 중재자에서 일이 수행되는 장소로 변했다. 이 
전환은 작은 항구가 큰 도시로 변하는 것과 같은 것이다.: 한 때 단지 화물을 배에 싣기 전에 임시로 창고에 
저장하는 장소였었다.; 그 때 독립적인 비지니스와 문화의 중심지가 되었다.

모든 버퍼들이 파일과 연관된 것은 아니다. 예를들면 @file{*scratch*} 버퍼는 어떤 파일도 방문하지 않는다. 
비슷하게 @file{*Help*} 버퍼도 어떤 파일과도 연관되지 않았다.

예전에는 @file{~/.emacs} 파일이 없고 파일 이름 없이 @code{emacs} 명령만으로 Emacs 세션을 
시작했을 때,  Emacs는 @file{*scratch*} 버퍼가 보이는 상태로 시작했다. 요즘은 splash 화면을 볼 것이다. 
splash 화면에서 제안하는 파일을 방문하거나 @file{*scratch*} 버퍼에 이르는 스페이스바를 누르는 두 명령 
중 하나를 따를 수 있다.

@file{*scratch*} 버퍼로 전환했다면, @code{(buffer-name)}을 입력하고 커서를 그 뒤에 위치시킨 후, 
@kbd{C-x C-e}를 눌러 이 표현식을 평가해보라. 이름 @code{“*scratch*”}이 반환되고 echo 영역에 
나타날 것이다. @file{*scratch*} 버퍼에서 @code{(buffer-file-name)}을 입력하고 이 것을 평가했을 때, 
info에서 @code{(buffer-file-name)}을 평가한 것과 마찬가지로 @code{nil}이 echo 영역에 나타날 
것이다. 

부수적으로, echo 영역이 아닌 @file{*scratch*}에 표현식의 결과 값을 보기를 원한다면 @file{*scratch*} 
버퍼에서 @kbd{C-x C-e} 대신에 @kbd{C-u C-x C-e}를 입력하라. 이 표현식 뒤에 결과 값이 나타날 
것이다. 버퍼는 다음과 같이 보일 것이다.:

@smallexample
(buffer-name)"*scratch*"
@end smallexample

@noindent
버퍼의 내용을 변경하는 것이 허락되지 않는 읽기 전용인 info에서는 이 것을 할 수 없다. 그러나 수정하고 있는 
다른 어떤 버퍼에서는 이 것을 할 수 있다.; 코드 또는 문서를(이 책처럼) 쓰고 있을 때, 이 기능은 매우 유용하다.



@node 버퍼 얻기, 버퍼 변경하기, 버퍼 이름, 평가 연습하기
@comment  node-name,  next,  previous,  up
@section 버퍼 얻기
@findex current-buffer
@findex other-buffer
@cindex Getting a buffer

@code{buffer-name} 함수는 버퍼의 @emph{이름}을 반환한다.; 버퍼 @emph{그 자체}를 얻기 위해서는 
다름 함수가 필요하다.: @code{current-buffer} 함수이다. 코드에서 이 함수를 사용한다면 버퍼 그 자체를 
얻을 것이다. George와 이야기하는 것을 요청했을 때, 누군가 당신에게 @samp{G}, @samp{e}, 
@samp{o}, @samp{r}, @samp{g}, @samp{e}가 쓰인 카드를 준다면 재미있을지 모르지만, 만족스럽지는 
않을 것이다. 이름으로 불리는 사람과 이야기 하기를 원하지 이름과 이야기하는 것을 원하지 않는다. 이름과 
이름이 참조하는 객체 또는 독립체는 서로 다르다. 독자는 독자의 이름이 아니다. 독자는 다른 이들로부터 
이름으로 불리는 사람이다. 버퍼도 비슷하다.: scratch 버퍼의 이름은 @file{*scratch*}이다. 그러나 버퍼는 
아니다. 버퍼 그 자체를 얻기 위해서는 @code{current-buffer} 같은 함수를 사용하는 것이 필요하다.

그러나 약간의 문제가 있다.: 여기서 할 수 있을 것이지만, 표현식에서 @code{current-buffer} 그 자체를 
평가한다면 버퍼의 내용 없이 버퍼 이름의 출력 된 설명을 볼 것이다. Emacs는 두 가지 이유 때문에 이 
방식으로 동작한다.: 버퍼는 수 천 줄 이상으로 길 수 있다. --- 알맞게 출력하기에 너무 길 수 있다.; 그리고 다른 
버퍼는 이름은 다르지만 같은 내용을 가질 수 있다. 그리고 그 둘을 구분하는 것은 중요하다.

@need 800
여기 함수를 포함하는 표현식이 있다.:

@smallexample
(current-buffer)
@end smallexample

@noindent
Emacs의 Info에서 보통 방법으로 이 표현식을 평가한다면, @file{#<buffer *info*>}가 echo 영역에 나타날 
것이다. 특별한 형식은 버퍼의 이름이 아닌 버퍼 자체가 반환 된 것을 가리킨다.

부수적으로, 프로그램에 숫자 또는 기호를 입력할 수 있지만 버퍼의 출력 된 설명을 입력할 수 없다.: 버퍼 그 
자체를 얻는 유일한 방법은 @code{current-buffer} 같은 함수를 통하는 방법 뿐이다.

관련된 함수로 @code{other-buffer}가 있다. 이 함수는 현재 버퍼가 아닌 가장 최근에 선택되었던 버퍼를 
넘겨준다. @file{*scratch*} 버퍼로부터 전환해왔었다면, @code{other-buffer}는 그 버퍼를 넘겨 줄 
것이다.

@need 800
표현식을 평가함으로 볼 수 있다.

@smallexample
(other-buffer)
@end smallexample

@noindent
echo 영역에 @file{#<buffer *scratch*>} 또는 가장 최근에 전환했던 다른 버퍼의 이름을 볼 
것이다.@footnote{ 실제로 최근에 전환했던 버퍼가 다른 창에서 보이고 있다면, 자동적으로 
@code{other-buffer}는 볼 수 없는 버퍼 중 가장 최근에 전환했었던 버퍼를 선택할 것이다.; 이 것은 종종 
잊어먹는 미묘함이다.}



@node 버퍼 변경하기, 버퍼 크기와 위치, 버퍼 얻기, 평가 연습하기
@comment  node-name,  next,  previous,  up
@section 버퍼 변경하기
@findex switch-to-buffer
@findex set-buffer
@cindex Switching to a buffer

버퍼를 요구하는 함수의 인자로서 사용될 때 @code{other-buffer} 함수는 실제로 버퍼를 제공한다. 다른 
버퍼로 변경하기 위해 @code{other-buffer}와 @code{swith-to-buffer}를 사용하는 것을 볼 수 있다.

그러나 먼저 @code{switch-to-buffer} 함수에 대한 짧은 소개. @code{(buffer-name)}을 평가하기 위해 
Info에서 @file{*scratch*} 버퍼로 변경하고자 할 때, @kbd{C-x b}를 입력한 후, 미니 버퍼에서 변경하기를 
원하는 버퍼의 이름을 물어보면 @file{*scratch*}을 입력한다.@footnote{또는 오히려 입력을 줄이기 위해 
기본 버퍼가 @file{*scratch*}일 경우, 단지 @kbd{RET}만을 입력한다. 또는 기본 버퍼가 다르다면 
@code{*sc} 처럼 이름의 일부분을 입력 후, @kbd{TAB} 키를 눌러 전체 이름으로 확장한 후 @kbd{RET} 
키를 입력한다.} 키 입력 @kbd{C-x b}는 Lisp 해석기가 대화형 함수 @code{switch-to-buffer}를 
평가한다. 앞에서 이야기한 것 처럼 Emacs는 다음과 같이 동작한다.: 다른 키 입력은 다른 함수를 호출 또는 
수행한다. 예를 들면 @kbd{C-f}는 @code{forward-char}를 호출하고 @kbd{M-e}는 
@code{forward-sentence}를 호출한다.

표현식에서 변경할 버퍼를 @code{switch-to-buffer}에 주는 것으로 @kbd{C-x b}가 한 방식으로 버퍼를 
변경할 수 있다.

@need 1000
여기 Lisp 표현식이 있다.

@smallexample
(switch-to-buffer (other-buffer))
@end smallexample

@noindent
@code{switch-to-buffer}는 list의 첫 번째 항목이다. 그래서 Lisp 해석기는 이 것을 함수로 다룰 것이고 
이것에 연결된 명령들을 해석할 것이다. 그러나 이 것을 하기 전에 해석기는 괄호 안의 
@code{other-buffer}를 기록하고 이 기호를 먼저 처리할 것이다. @code{other-buffer}는 이 list의 첫 
항목이다. 그래서 Lisp 해석기는 이 함수를 호출하고 수행한다. 이 함수는 다른 버퍼를 반환한다. 그 다음 
해석기는 Emacs가 변경할 다른 버퍼를 @code{switch-to-buffer}의 인자로 받아 이 함수를 수행한다. 
Info에서 이 것을 읽고 있다면, 지금 바로 시도하라. 위 표현식을 평가하라.(다시 @kbd{C-x b @key{RET}}를 
입력하라.)@footnote{ 이 표현식은 볼 수 없는 가장 최근 다른 버퍼로 이동할 것이라는 것을 기억하라. 지금 
볼 수도 하지만, 가장 최근에 선택했던 버퍼로 이동하기 원한다면  더 복잡한 다음 표현식을 평가할 수 있다.

@smallexample
(switch-to-buffer (other-buffer (current-buffer) t))
@end smallexample

@c noindent
이 경우 @code{other-buffer}의 첫 번째 인자는 건너 뛸 버퍼---현재 버퍼--- 를 이야기하고,  
@code{other-buffer}의 두 번째 인자는  보이는 버퍼로 변경도 OK라는 것을 말한다. 다른 보이는 버퍼로 
가기 위해서 @kbd{C-x o}(@code{other-window}) 를 사용하기 때문에 일반적인 사용에서 
@code{switch-to-buffer}는 보이지 않는 창으로 이동한다. }

이 문서의 다음 절의 프로그래밍 예제에서 @code{switch-to-buffer}보다 더 자주 @code{set-buffer} 
함수를 볼 것이다. 컴퓨터 프로그램과 인간 사이의 차이점 때문이다.: 사람은 눈을 가지고 있고 컴퓨터 
터미널에서 동작하는 버퍼를 보기를 기대한다. 이 것은 확실히 말할 필요도 없다. 그러나 프로그램은 눈을 가지고 
있지 않다. 컴퓨터 프로그램이 버퍼에서 동작할 때, 버퍼는 화면에 보여질 필요 없다.

@code{switch-to-buffer}는 사람을 위해 설계되었고 두 가지 다른 것을 한다.: 버퍼를 Emacs의 관심이 
있는 것으로 변경한다.; 그리고 창에 보이는 버퍼를 새로운 버퍼로 변경한다. 반면에 @code{set-buffer}는 
단지 한 가지를 한다.: 컴퓨터 프로그램의 관심을 다른 버퍼로 변경한다. 화면에 있는 버퍼는 변경되지 않는다.
(명령이 끝날 때까지 물론 보통 아무 일도 일어나지 않는다.)

@cindex @samp{call} defined
또한 다른 전문 용어로 @dfn{호출(call)}을 알게 되었다. 첫 기호가 함수인 list를 평가할 때, 함수를 호출하는 
것이다. 이 용어의 사용은 함수를 ‘호출하면’ 무언가를 할 수 있는 독립체인 함수의 개념에서 왔다. --- 호출하면 
누수를 수리할 수 있는 배관공이 독립체인 것 처럼



@node 버퍼 크기와 위치, 연습문제 평가, 버퍼 변경하기, 평가 연습하기
@comment  node-name,  next,  previous,  up
@section 버퍼 크기와 지점
@cindex Size of buffer
@cindex Buffer size
@cindex Point location
@cindex Location of point

마지막으로 몇 종류의 비교적 단순한 함수들을 살펴보자, @code{buffer-size}, @code{point}, 
@code{point-min}, @code{point-max} 이다. 버퍼의 크기와 버퍼 안의 위치에 대한 정보를 준다.

@code{buffer-size} 함수는 현재 버퍼의 크기를 알려준다.; 함수가 넘겨주는 크기는 버퍼 안의 문자들의 
개수이다.

@smallexample
(buffer-size)
@end smallexample

@noindent
표현식 뒤에 커서를 이동 후, @kbd{C-x C-e}를 입력하는 보통 방법으로 평가할 수 있다.

@cindex @samp{point} defined
Emacs에서 커서의 현재 위치를 @dfn{지점(point)}라고 한다. @code{(point)} 표현식은 버퍼의 시작 
지점부터 문자의 개수로 표현되는 커서의 위치를 나타내는 숫자를 반환한다.

@need 1250
보통 방법으로 다음 표현식을 평가하면 현재 버퍼에서 위치를 문자 개수로 볼 수 있다.

@smallexample
(point)
@end smallexample

@noindent
@code{point}의 값은 65724이다. @code{point} 함수는 이 책에서 뒤의 예제들에서 자주 사용된다.

@need 1250
지점의 값은 물론 버퍼의 위치에 따라 다르다. 여기서 point 를 평가한다면 숫자는 더 클 것이다.:

@smallexample
(point)
@end smallexample

@noindent
이 위치에서 지점의 값은 66043이다. 이 값은 두 표현식 사이에 (공백을 포함해서) 319 개의 문자들이 있다는 
것을 나타낸다. (처음 point를 평가한 후, 이 부분의 글을 수정했을 것이기에 분명히 다른 숫자를 볼 것이다.)

@cindex @samp{narrowing} defined
@code{point-min} 함수는 @code{point}와 비슷하지만, 현재 버퍼에서 허용되는 지점의 가장 작은 값을 
반환한다. 효과로 @dfn{줄이지(narrowing)} 않았다면 숫자 1일 것이다. ( 줄이기(narrowing)는 자신 또는 
프로그램에 대해서 버퍼 일부분의 운영을 제한할 수 있는 방법이다. @xref{Narrowing & Widening, , 
Narrowing and Widening}.) 마찬가지로 @code{point-max} 함수도 현재 버퍼에서 허용되는 지점의 가장 
큰 값을 반환한다.



@node 연습문제 평가,  , 버퍼 크기와 위치, 평가 연습하기
@section 연습문제

작업하고 있고 파일을 찾아서 중간 지점으로 이동하라.
버퍼 이름, 파일 이름, 길이, 파일에서 현재 위치를 찾아라.


@node Writing Defuns, Buffer Walk Through, 평가 연습하기, Top
@comment  node-name,  next,  previous,  up
@chapter 함수 정의 작성 방법
@cindex Definition writing
@cindex Function definition writing
@cindex Writing a function definition

Lisp 해석기가 list를 평가할 때, list의 첫 번째 기호에 연결된 함수 정의가 있는지 본다.; 또는 달리 말하면 
기호가 함수 정의를 가리키는지. 만약 그렇다면 컴퓨터는 그 정의에 있는 명령들을 수행한다. 함수 정의를 가지고 
있는 기호, 단순하게 함수는 호출된다.(정확히 이야기하지만 그 정의는 함수이고 기호는 함수를 가리킨다. )

@menu
* Primitive Functions::
* defun::                        특별한 형식 @code{defun}.
* Install::                     함수 정의 설치하기.
* Interactive::                  Making a function interactive.
* Interactive Options::          Different options for @code{interactive}.
* Permanent Installation::       Installing code permanently.
* let::                          Creating and initializing local variables.
* if::                           What if?
* else::                         If--then--else expressions.
* Truth & Falsehood::            What Lisp considers false and true.
* save-excursion::               Keeping track of point, mark, and buffer.
* Review::
* defun Exercises::
@end menu



@node Primitive Functions, defun, Writing Defuns, Writing Defuns
@ifnottex
@unnumberedsec 원시 함수에 관한 이야기
@end ifnottex
@cindex Primitive functions
@cindex Functions, primitive

@cindex C language primitives
@cindex Primitives written in C
모든 함수들은 C 언어로 작성된 몇몇 @dfn{원시(primitive)} 함수들을 제외한 다른 함수들에 의해서 정의된다.  
함수 정의를 작성할 때, Emacs Lisp으로 작성할 것이고 구성 요소로 다른 함수들을 사용할 것이다. 사용할 
일부 함수들은 Emacs Lisp을 작성되었고, 일부는 C 언어로 작성된 원시 함수들이다. 원시 함수들은 Emacs 
Lisp으로 작성된 함수들처럼 사용되고 그들과 똑같이 동작한다. C로 작성되었기에 충분한 성능을 가지고 
C를 수행할 수 있는 어느 컴퓨터든지 GNU Emacs를 쉽게 수행할 수 있다.

다시 한번 강조해본다.: Emacs Lisp에서 코드를 작성할 때, C로 작성된 함수의 사용과 Emacs Lisp으로 
작성된 함수를 구분할 필요가 없다. 그 차이는 아무 상관 없다. 단지 그 차이를 언급한 것은 아는 것이 흥미롭기 
때문이다. 정말로 조사하지 않는다면, 이미 만들어진 함수가 Emacs Lisp 또는 C 둘 중 어떤 것으로 
작성되었는지 알 수 없다.



@node defun, Install, Primitive Functions, Writing Defuns
@comment  node-name,  next,  previous,  up
@section 특별한 형식 @code{defun}
@findex defun
@cindex Special form of @code{defun}

@cindex @samp{function definition} defined
Lisp에서 @code{mark-whole-buffer} 같은 기호는 함수가 호출될 때 컴퓨터가 무엇을 해야 하는지 
쓰여있는 연결된 코드를 가지고 있다. 이 코드는 @dfn{함수 정의(function definition)}이라고 하고 
@code{defun}(@emph{함수 정의(define function)}을 나타낸다.) 기호로 시작하는 Lisp 표현식을 
평가함으로 생성된다. @code{defun}은 보통 방법으로 그 인자들을 평가하지 않기 때문에 @dfn{특별한 형식
(special form)}이라고 부른다.

다음 절에서 Emacs 소스 코드에서 @code{mark-whole-buffer} 같은 함수 정의를 볼 것이다. 이 절에서는 
이해할 수 있게 간단한 함수 정의를 설명할 것이다. 단순한 예제를 만들기 위해서 이 함수 정의는 수식을 
사용한다. 어떤 이들은 수식을 사용한 예제를 싫어한다.; 그러나 독자가 그런 사람이라면 절망하지 말아라. 
앞으로 학습할 이 소개의 나머지 부분의 코드는 수식이나 수학을 거의 포함하지 않을 것이다. 예제들은 대부분 
한 가지 또는 다른 방법으로 글을 포함한다.

함수 정의는 다음 단어 뒤에 최대 다섯 부분을 가진다.
@code{defun}:

@enumerate
@item
함수 정의가 연관될 기호의 이름

@item
함수에 전달될 인자들의 list. 함수에 전달될 인자가 없다면  빈 list @code{()}가 될 것이다.

@item
함수를 설명하는 문서. (기술적으로 선택 사항이지만, 강력하게 권장한다.)

@item
선택 사항으로 함수를 대화형으로 만드는 표현식.  @kbd{M-x} 입력 후 함수의 이름을 입력하거나 적절한 키 
입력으로 함수를 사용할 수 있다.

@cindex @samp{body} defined
@item
컴퓨터가 할 일을 알려주는 코드: 함수 정의의 @dfn{본체(body)}이다.
@end enumerate

함수 정의의 다섯 부분을 각 부분의 자리가 있는 견본으로 구성된 것으로 생각하는 것이 도움이 된다.

@smallexample
@group
(defun @var{function-name} (@var{arguments}@dots{})
  "@var{optional-documentation}@dots{}"
  (interactive @var{argument-passing-info})     ; @r{optional}
  @var{body}@dots{})
@end group
@end smallexample

하나의 예제로 여기 인자에 7을 곱하는 함수를 위한 코드가 있다. (이 예제는 대화형이 아니다. 자세한 정보는 
@xref{Interactive,, Making a Function Interactive} )

@smallexample
@group
(defun multiply-by-seven (number)
  "Multiply NUMBER by seven."
  (* 7 number))
@end group
@end smallexample

이 정의는 괄호와 기호 @code{defun}과 함수 이름으로 시작한다.

@cindex @samp{argument list} defined
함수의 이름 뒤에는 함수에 전달될 인자들을 포함하는 list가 온다. 이 list는 @dfn{인자(argument) list}라고 
한다. 이 예제에서 list는 기호 @code{number}로 하나의 요소만 있다. 함수가 사용될 때 함수의 인자로 
사용되는 기호는 값에 바인딩 될 것이다.

인자의 이름으로 단어 @code{number}를 선택하는 대신 다른 이름을 선택할 수 있다. 예를 들면 단어 
@code{mutiplicand}를 선택할 수 있다. 이 위치에 어떤 종류의 값인지 말하기 때문에 단어 `number'를 
선택했다.; 그러나 함수 동작에서 이 값의 역할을 나타내는 단어 `multiplicand' 역시 선택할 수 있다. 인자를 
@code{foogle}로 쓸 수 도 있으나 이 것이 무엇을 의미하는지 말하지 않기 때문에 나쁜 선택이다. 이름의 선택은 
프로그래머에 달려있고 함수의 의미를 명확하게 만드는 선택을 해야 한다.

정말로 다른 함수에서 사용되는 기호의 이름이라도 인자 list에서 기호에 대해서 원하는 어떤 이름을 선택할 수 있다.: 
인자 list에 사용한 이름은 그 특정 정의 안에서 유효하다. 그 정의에서 이름은 함수 정의 밖에서 같은 이름과는 다른 
개체를 가리킨다. 가족에서 `Shorty'라는 별명을 가지고 있다고 가정해보자.; 가족들에서 `Shorty'는 당신을 
의미한다. 그러나 가족 밖에서 이름 `Shorty'는 다른 누군가를 의미한다. 인자 list에서 이름은 함수 정의 안에서만 
유효하기 때문에 함수 밖에서 그 값의 변화 없이 함수 몸체 안에서 그 기호의 값을 변경할 수 있다. 이 효과는 
@code{let} 표현식이 만드는 것과 비슷하다. (@xref{let, , @code{let}}.)

@ignore
Note also that we discuss the word `number' in two different ways: as a
symbol that appears in the code, and as the name of something that will
be replaced by a something else during the evaluation of the function.
In the first case, @code{number} is a symbol, not a number; it happens
that within the function, it is a variable who value is the number in
question, but our primary interest in it is as a symbol.  On the other
hand, when we are talking about the function, our interest is that we
will substitute a number for the word @var{number}.  To keep this
distinction clear, we use different typography for the two
circumstances.  When we talk about this function, or about how it works,
we refer to this number by writing @var{number}.  In the function
itself, we refer to it by writing @code{number}.
@end ignore

인자 list 뒤에는 함수를 설명하는 문서화가 따라온다. @w{@kbd{C-h f}}와 함수 이름을 입력했을 때, 보는 
내용들이다. 부가적으로 @code{apropos} 같은 명령들은 여러 줄의 문서화 문자열 중 첫 줄만 출력하기 때문에 이
 것처럼 문서를 작성할 때는 첫 줄은 완전한 문장으로 만들어야 한다. 또한 @kbd{C-h f}(
@code{describe-function})을 사용했을 때, 이상하게 보이기 때문에 문서의 두 번째 줄은 들여쓰지 말아야 한다. 
문서 문자열은 선택 사항이지만 꽤 유용하다. 작성하는 대부분의 모든 함수에 포함되어야 할 것이다.

@findex * @r{(multiplication)}
예제의 3번 줄은 함수 정의의 몸체를 구성한다. (물론 대부분의 함수 정의는 이 것 보다는 길다.) 함수에서 몸체는 
list이다. @code{(* 7 number)}는 7에 @var{number}의 값을 곱하는 것을 나타낸다. (Emacs Lisp에서 
@code{+}가 덧셈을 위한 함수인 것처럼 @code{*}은 곱셈을 위한 함수이다.

@code{multiply-by-seven}함수를 사용할 때, 인자 @code{number}는 사용하기를 원하는 실제 숫자로 
평가한다. 여기 @code{multiply-by-seven}이 어떻게 사용되는지 예제가 있다.; 아직 평가하려고 시도하지는
마라!

@smallexample
(multiply-by-seven 3)
@end smallexample

@noindent
다음 절의 함수 정의에서 명시된 기호 @code{number}는 함수의 실제 사용 시 값 3으로 주어지거나 `bound to'' 
된다. @code{number}는 함수 정의에서 괄호 안에 있지만, 인자는 괄호 안에 있지 않은 
@code{multiply-by-seven} 함수에 전달될 수 있다. 괄호는 함수 정의 안에 쓰였다. 그래서 컴퓨터는 인자 list가 
끝나는 위치와 함수 정의의 나머지 부분의 시작 위치를 알 수 있다.

이 예제를 평가한다면 에러 메시지를 얻을 것이다.(어서 시도해보라) 함수 정의를 작성했지만 아직 이 것에 대해서 
컴퓨터에 말하지 않았기 때문이다. --- 아직 Emacs에 함수 정의를 설치 (또는 `loaded') 하지 않았다. 함수를 
설치하는 것은 Lisp 해석기에 함수 정의를 말하는 과정이다. 다음 절에서 설치를 설명할 것이다.



@node Install, Interactive, defun, Writing Defuns
@comment  node-name,  next,  previous,  up
@section함수 정의 설치하기
@cindex Install a Function Definition
@cindex Definition installation
@cindex Function definition installation

Emacs의 Info에서 이 글을 읽고 있다면 함수 정의를 평가한 후에 @code{(multiply-by-seven 3)}을 평가하는 
것으로 @code{multiply-by-seven} 함수를 실험해 볼 수 있다. 함수 정의의 복사본은 뒤에 있다. 함수 정의의 
마지막에 커서를 놓고 @kbd{C-x C-e}를 입력하라. 이 것을 하면 @code{multiply-by-seven}이 echo 영역에 
나타날 것이다. (이 것은 함수 정의가 평가될 때, 정의된 함수의 이름이 넘겨지는 것을 의미한다.) 동시에 이 행동은 
함수 정의를 설치한다.

@smallexample
@group
(defun multiply-by-seven (number)
  "Multiply NUMBER by seven."
  (* 7 number))
@end group
@end smallexample

@noindent
@code{defun}을 평가함으로 Emacs에 @code{multiply-by-seven}을 설치한 것이다. 이제 함수는 
@code{forward-word} 또는 사용하는 다른 편집 함수처럼 Emacs의 일부분이다. 
(@code{multiply-by-seven}은 Emacs를 종료하기 전까지 설치된 상태로 남을 것이다. @ref{Permanent 
Installation, , Installing Code Permanently} 을 보라.)

@menu
* Effect of installation::
* Change a defun::              How to change a function definition.
@end menu

@node Effect of installation, Change a defun, Install, Install
@ifnottex
@unnumberedsubsec 설치의 효과
@end ifnottex

다음 예제를 평가하는 것으로 @code{multiply-by-seven}를 설치한 효과를 볼 수 있다. 다음 표현식 뒤에 커서를 
놓은 후, @kbd{C-x C-e}를 입력하라. 숫자 21이 echo 영역에 나타날 것이다.

@smallexample
(multiply-by-seven 3)
@end smallexample

원한다면 @kbd{C-h f}(@code{describe-function})를 입력 후, 함수의 이름 @code{multiply-by-seven}을 
입력하여 함수에 대한 문서를 읽을 수 있다. 이 것을 할 때, 다음 내용을 가지는 @file{*Help} 창이 나타날 것이다.:

@smallexample
@group
multiply-by-seven is a Lisp function.
(multiply-by-seven NUMBER)

Multiply NUMBER by seven.
@end group
@end smallexample

@noindent
(단일 창으로 돌아가려면 @kbd{C-x 1}을 입력하라.)


@node Change a defun,  , Effect of installation, Install
@comment  node-name,  next,  previous,  up
@subsection 함수 정의 변경하기
@cindex Changing a function definition
@cindex Function definition, how to change
@cindex Definition, how to change

@code{multiply-by-seven}의 코드를 변경하고 싶다면, 단지 그 것을 다시 작성하라. 새로운 버전을 설치하고자 
한다면 함수 정의를 다시 평가하라. Emacs에서 코드를 수정하는 방법이다. 매우 간단하다.

예제처럼 number에 7을 곱하는 것 대신에 number를 7번 더하는 것으로 @code{multiply-by-seven} 함수를 
바꿀 수 있다. 같은 답을 내놓지만, 다른 방식이다. 동시에 코드에 주석을 더할 것이다.; 주석은 Lisp 해석기가 
무시하는 글이다. 그러나 주석을 읽는 사람에게는 유용하거나 정보를 줄 수 있다. ``second version''은 주석이다. 

@smallexample
@group
(defun multiply-by-seven (number)       ; @r{Second version.}
  "Multiply NUMBER by seven."
  (+ number number number number number number number))
@end group
@end smallexample

@cindex Comments in Lisp code
세미콜론 @samp{;} 뒤에 주석이 온다. Lisp에서 한 줄에서 세미콜론 뒤의 모든 것은 주석이다. 줄의 끝은 주석의 
끝이다. 2줄 이상의 주석을 작성하려면 각 줄은 세미콜론으로 시작해야 한다.

주석에 대해서 더 자세한 것은 @xref{Beginning a .emacs File, , Beginning a @file{.emacs} File} 과 
@ref{Comments, , Comments, elisp, The GNU Emacs Lisp Reference Manual}을 참조하라.

이 버전의 @code{multiply-by-seven} 함수를 첫 번째 함수와 같은 방식으로 평가하여 설치할 수 있다.: 커서를 
마지막 괄호 뒤에 놓은 후, @kbd{C-x C-e}를 입력하라.

요약하면 이는 Emacs Lisp에서 코드를 작성하는 방법이다.: 함수를 작성하고; 설치하고; 테스트하고; 고치고 
개선하고 다시 함수를 설치한다.



@node Interactive, Interactive Options, Install, Writing Defuns
@comment  node-name,  next,  previous,  up
@section Make a Function Interactive
@cindex Interactive functions
@findex interactive

You make a function interactive by placing a list that begins with
the special form @code{interactive} immediately after the
documentation.  A user can invoke an interactive function by typing
@kbd{M-x} and then the name of the function; or by typing the keys to
which it is bound, for example, by typing @kbd{C-n} for
@code{next-line} or @kbd{C-x h} for @code{mark-whole-buffer}.

Interestingly, when you call an interactive function interactively,
the value returned is not automatically displayed in the echo area.
This is because you often call an interactive function for its side
effects, such as moving forward by a word or line, and not for the
value returned.  If the returned value were displayed in the echo area
each time you typed a key, it would be very distracting.

@menu
* Interactive multiply-by-seven::  An overview.
* multiply-by-seven in detail::    The interactive version.
@end menu

@node Interactive multiply-by-seven, multiply-by-seven in detail, Interactive, Interactive
@ifnottex
@unnumberedsubsec An Interactive @code{multiply-by-seven}, An Overview
@end ifnottex

Both the use of the special form @code{interactive} and one way to
display a value in the echo area can be illustrated by creating an
interactive version of @code{multiply-by-seven}.

@need 1250
Here is the code:

@smallexample
@group
(defun multiply-by-seven (number)       ; @r{Interactive version.}
  "Multiply NUMBER by seven."
  (interactive "p")
  (message "The result is %d" (* 7 number)))
@end group
@end smallexample

@noindent
You can install this code by placing your cursor after it and typing
@kbd{C-x C-e}.  The name of the function will appear in your echo area.
Then, you can use this code by typing @kbd{C-u} and a number and then
typing @kbd{M-x multiply-by-seven} and pressing @key{RET}.  The phrase
@samp{The result is @dots{}} followed by the product will appear in the
echo area.

Speaking more generally, you invoke a function like this in either of two
ways:

@enumerate
@item
By typing a prefix argument that contains the number to be passed, and
then typing @kbd{M-x} and the name of the function, as with
@kbd{C-u 3 M-x forward-sentence}; or,

@item
By typing whatever key or keychord the function is bound to, as with
@kbd{C-u 3 M-e}.
@end enumerate

@noindent
Both the examples just mentioned work identically to move point forward
three sentences.  (Since @code{multiply-by-seven} is not bound to a key,
it could not be used as an example of key binding.)

(@xref{Keybindings, , Some Keybindings}, to learn how to bind a command
to a key.)

A prefix argument is passed to an interactive function by typing the
@key{META} key followed by a number, for example, @kbd{M-3 M-e}, or by
typing @kbd{C-u} and then a number, for example, @kbd{C-u 3 M-e} (if you
type @kbd{C-u} without a number, it defaults to 4).

@node multiply-by-seven in detail,  , Interactive multiply-by-seven, Interactive
@comment  node-name,  next,  previous,  up
@subsection An Interactive @code{multiply-by-seven}

Let's look at the use of the special form @code{interactive} and then at
the function @code{message} in the interactive version of
@code{multiply-by-seven}.  You will recall that the function definition
looks like this:

@smallexample
@group
(defun multiply-by-seven (number)       ; @r{Interactive version.}
  "Multiply NUMBER by seven."
  (interactive "p")
  (message "The result is %d" (* 7 number)))
@end group
@end smallexample

In this function, the expression, @code{(interactive "p")}, is a list of
two elements.  The @code{"p"} tells Emacs to pass the prefix argument to
the function and use its value for the argument of the function.

@need 1000
The argument will be a number.  This means that the symbol
@code{number} will be bound to a number in the line:

@smallexample
(message "The result is %d" (* 7 number))
@end smallexample

@need 1250
@noindent
For example, if your prefix argument is 5, the Lisp interpreter will
evaluate the line as if it were:

@smallexample
(message "The result is %d" (* 7 5))
@end smallexample

@noindent
(If you are reading this in GNU Emacs, you can evaluate this expression
yourself.)  First, the interpreter will evaluate the inner list, which
is @code{(* 7 5)}.  This returns a value of 35.  Next, it
will evaluate the outer list, passing the values of the second and
subsequent elements of the list to the function @code{message}.

As we have seen, @code{message} is an Emacs Lisp function especially
designed for sending a one line message to a user.  (@xref{message, ,
The @code{message} function}.)  In summary, the @code{message}
function prints its first argument in the echo area as is, except for
occurrences of @samp{%d} or @samp{%s} (and various other %-sequences
which we have not mentioned).  When it sees a control sequence, the
function looks to the second or subsequent arguments and prints the
value of the argument in the location in the string where the control
sequence is located.

In the interactive @code{multiply-by-seven} function, the control string
is @samp{%d}, which requires a number, and the value returned by
evaluating @code{(* 7 5)} is the number 35.  Consequently, the number 35
is printed in place of the @samp{%d} and the message is @samp{The result
is 35}.

(Note that when you call the function @code{multiply-by-seven}, the
message is printed without quotes, but when you call @code{message}, the
text is printed in double quotes.  This is because the value returned by
@code{message} is what appears in the echo area when you evaluate an
expression whose first element is @code{message}; but when embedded in a
function, @code{message} prints the text as a side effect without
quotes.)


@node Interactive Options, Permanent Installation, Interactive, Writing Defuns
@comment  node-name,  next,  previous,  up
@section Different Options for @code{interactive}
@cindex Options for @code{interactive}
@cindex Interactive options

In the example, @code{multiply-by-seven} used @code{"p"} as the
argument to @code{interactive}.  This argument told Emacs to interpret
your typing either @kbd{C-u} followed by a number or @key{META}
followed by a number as a command to pass that number to the function
as its argument.  Emacs has more than twenty characters predefined for
use with @code{interactive}.  In almost every case, one of these
options will enable you to pass the right information interactively to
a function.  (@xref{Interactive Codes, , Code Characters for
@code{interactive}, elisp, The GNU Emacs Lisp Reference Manual}.)

@need 1250
Consider the function @code{zap-to-char}.  Its interactive expression
is

@smallexample
(interactive "p\ncZap to char: ")
@end smallexample

The first part of the argument to @code{interactive} is @samp{p}, with
which you are already familiar.  This argument tells Emacs to
interpret a `prefix', as a number to be passed to the function.  You
can specify a prefix either by typing @kbd{C-u} followed by a number
or by typing @key{META} followed by a number.  The prefix is the
number of specified characters.  Thus, if your prefix is three and the
specified character is @samp{x}, then you will delete all the text up
to and including the third next @samp{x}.  If you do not set a prefix,
then you delete all the text up to and including the specified
character, but no more.

The @samp{c} tells the function the name of the character to which to delete.

More formally, a function with two or more arguments can have
information passed to each argument by adding parts to the string that
follows @code{interactive}.  When you do this, the information is
passed to each argument in the same order it is specified in the
@code{interactive} list.  In the string, each part is separated from
the next part by a @samp{\n}, which is a newline.  For example, you
can follow @samp{p} with a @samp{\n} and an @samp{cZap to char:@: }.
This causes Emacs to pass the value of the prefix argument (if there
is one) and the character.

In this case, the function definition looks like the following, where
@code{arg} and @code{char} are the symbols to which @code{interactive}
binds the prefix argument and the specified character:

@smallexample
@group
(defun @var{name-of-function} (arg char)
  "@var{documentation}@dots{}"
  (interactive "p\ncZap to char: ")
  @var{body-of-function}@dots{})
@end group
@end smallexample

@noindent
(The space after the colon in the prompt makes it look better when you
are prompted.  @xref{copy-to-buffer, , The Definition of
@code{copy-to-buffer}}, for an example.)

When a function does not take arguments, @code{interactive} does not
require any.  Such a function contains the simple expression
@code{(interactive)}.  The @code{mark-whole-buffer} function is like
this.

Alternatively, if the special letter-codes are not right for your
application, you can pass your own arguments to @code{interactive} as
a list.

@xref{append-to-buffer, , The Definition of @code{append-to-buffer}},
for an example.  @xref{Using Interactive, , Using @code{Interactive},
elisp, The GNU Emacs Lisp Reference Manual}, for a more complete
explanation about this technique.


@node Permanent Installation, let, Interactive Options, Writing Defuns
@comment  node-name,  next,  previous,  up
@section Install Code Permanently
@cindex Install code permanently
@cindex Permanent code installation
@cindex Code installation

When you install a function definition by evaluating it, it will stay
installed until you quit Emacs.  The next time you start a new session
of Emacs, the function will not be installed unless you evaluate the
function definition again.

At some point, you may want to have code installed automatically
whenever you start a new session of Emacs.  There are several ways of
doing this:

@itemize @bullet
@item
If you have code that is just for yourself, you can put the code for the
function definition in your @file{.emacs} initialization file.  When you
start Emacs, your @file{.emacs} file is automatically evaluated and all
the function definitions within it are installed.
@xref{Emacs Initialization, , Your @file{.emacs} File}.

@item
Alternatively, you can put the function definitions that you want
installed in one or more files of their own and use the @code{load}
function to cause Emacs to evaluate and thereby install each of the
functions in the files.
@xref{Loading Files, , Loading Files}.

@item
Thirdly, if you have code that your whole site will use, it is usual
to put it in a file called @file{site-init.el} that is loaded when
Emacs is built.  This makes the code available to everyone who uses
your machine.  (See the @file{INSTALL} file that is part of the Emacs
distribution.)
@end itemize

Finally, if you have code that everyone who uses Emacs may want, you
can post it on a computer network or send a copy to the Free Software
Foundation.  (When you do this, please license the code and its
documentation under a license that permits other people to run, copy,
study, modify, and redistribute the code and which protects you from
having your work taken from you.)  If you send a copy of your code to
the Free Software Foundation, and properly protect yourself and
others, it may be included in the next release of Emacs.  In large
part, this is how Emacs has grown over the past years, by donations.


@node let, if, Permanent Installation, Writing Defuns
@comment  node-name,  next,  previous,  up
@section @code{let}
@findex let

The @code{let} expression is a special form in Lisp that you will need
to use in most function definitions.

@code{let} is used to attach or bind a symbol to a value in such a way
that the Lisp interpreter will not confuse the variable with a
variable of the same name that is not part of the function.

To understand why the @code{let} special form is necessary, consider
the situation in which you own a home that you generally refer to as
`the house', as in the sentence, ``The house needs painting.''  If you
are visiting a friend and your host refers to `the house', he is
likely to be referring to @emph{his} house, not yours, that is, to a
different house.

If your friend is referring to his house and you think he is referring
to your house, you may be in for some confusion.  The same thing could
happen in Lisp if a variable that is used inside of one function has
the same name as a variable that is used inside of another function,
and the two are not intended to refer to the same value.  The
@code{let} special form prevents this kind of confusion.

@menu
* Prevent confusion::
* Parts of let Expression::
* Sample let Expression::
* Uninitialized let Variables::
@end menu

@node Prevent confusion, Parts of let Expression, let, let
@ifnottex
@unnumberedsubsec @code{let} Prevents Confusion
@end ifnottex

@cindex @samp{local variable} defined
@cindex @samp{variable, local}, defined
The @code{let} special form prevents confusion.  @code{let} creates a
name for a @dfn{local variable} that overshadows any use of the same
name outside the @code{let} expression.  This is like understanding
that whenever your host refers to `the house', he means his house, not
yours.  (Symbols used in argument lists work the same way.
@xref{defun, , 특별한 형식 @code{defun}}.)

Local variables created by a @code{let} expression retain their value
@emph{only} within the @code{let} expression itself (and within
expressions called within the @code{let} expression); the local
variables have no effect outside the @code{let} expression.

Another way to think about @code{let} is that it is like a @code{setq}
that is temporary and local.  The values set by @code{let} are
automatically undone when the @code{let} is finished.  The setting
only affects expressions that are inside the bounds of the @code{let}
expression.  In computer science jargon, we would say ``the binding of
a symbol is visible only in functions called in the @code{let} form;
in Emacs Lisp, scoping is dynamic, not lexical.''

@code{let} can create more than one variable at once.  Also,
@code{let} gives each variable it creates an initial value, either a
value specified by you, or @code{nil}.  (In the jargon, this is called
`binding the variable to the value'.)  After @code{let} has created
and bound the variables, it executes the code in the body of the
@code{let}, and returns the value of the last expression in the body,
as the value of the whole @code{let} expression.  (`Execute' is a jargon
term that means to evaluate a list; it comes from the use of the word
meaning `to give practical effect to' (@cite{Oxford English
Dictionary}).  Since you evaluate an expression to perform an action,
`execute' has evolved as a synonym to `evaluate'.)

@node Parts of let Expression, Sample let Expression, Prevent confusion, let
@comment  node-name,  next,  previous,  up
@subsection The Parts of a @code{let} Expression
@cindex @code{let} expression, parts of
@cindex Parts of @code{let} expression

@cindex @samp{varlist} defined
A @code{let} expression is a list of three parts.  The first part is
the symbol @code{let}.  The second part is a list, called a
@dfn{varlist}, each element of which is either a symbol by itself or a
two-element list, the first element of which is a symbol.  The third
part of the @code{let} expression is the body of the @code{let}.  The
body usually consists of one or more lists.

@need 800
A template for a @code{let} expression looks like this:

@smallexample
(let @var{varlist} @var{body}@dots{})
@end smallexample

@noindent
The symbols in the varlist are the variables that are given initial
values by the @code{let} special form.  Symbols by themselves are given
the initial value of @code{nil}; and each symbol that is the first
element of a two-element list is bound to the value that is returned
when the Lisp interpreter evaluates the second element.

Thus, a varlist might look like this: @code{(thread (needles 3))}.  In
this case, in a @code{let} expression, Emacs binds the symbol
@code{thread} to an initial value of @code{nil}, and binds the symbol
@code{needles} to an initial value of 3.

When you write a @code{let} expression, what you do is put the
appropriate expressions in the slots of the @code{let} expression
template.

If the varlist is composed of two-element lists, as is often the case,
the template for the @code{let} expression looks like this:

@smallexample
@group
(let ((@var{variable} @var{value})
      (@var{variable} @var{value})
      @dots{})
  @var{body}@dots{})
@end group
@end smallexample

@node Sample let Expression, Uninitialized let Variables, Parts of let Expression, let
@comment  node-name,  next,  previous,  up
@subsection Sample @code{let} Expression
@cindex Sample @code{let} expression
@cindex @code{let} expression sample

The following expression creates and gives initial values
to the two variables @code{zebra} and @code{tiger}.  The body of the
@code{let} expression is a list which calls the @code{message} function.

@smallexample
@group
(let ((zebra 'stripes)
      (tiger 'fierce))
  (message "One kind of animal has %s and another is %s."
           zebra tiger))
@end group
@end smallexample

Here, the varlist is @code{((zebra 'stripes) (tiger 'fierce))}.

The two variables are @code{zebra} and @code{tiger}.  Each variable is
the first element of a two-element list and each value is the second
element of its two-element list.  In the varlist, Emacs binds the
variable @code{zebra} to the value @code{stripes}@footnote{According
to Jared Diamond in @cite{Guns, Germs, and Steel}, ``@dots{} zebras
become impossibly dangerous as they grow older'' but the claim here is
that they do not become fierce like a tiger.  (1997, W. W. Norton and
Co., ISBN 0-393-03894-2, page 171)}, and binds the
variable @code{tiger} to the value @code{fierce}.  In this example,
both values are symbols preceded by a quote.  The values could just as
well have been another list or a string.  The body of the @code{let}
follows after the list holding the variables.  In this example, the
body is a list that uses the @code{message} function to print a string
in the echo area.

@need 1500
You may evaluate the example in the usual fashion, by placing the
cursor after the last parenthesis and typing @kbd{C-x C-e}.  When you do
this, the following will appear in the echo area:

@smallexample
"One kind of animal has stripes and another is fierce."
@end smallexample

As we have seen before, the @code{message} function prints its first
argument, except for @samp{%s}.  In this example, the value of the variable
@code{zebra} is printed at the location of the first @samp{%s} and the
value of the variable @code{tiger} is printed at the location of the
second @samp{%s}.

@node Uninitialized let Variables,  , Sample let Expression, let
@comment  node-name,  next,  previous,  up
@subsection Uninitialized Variables in a @code{let} Statement
@cindex Uninitialized @code{let} variables
@cindex @code{let} variables uninitialized

If you do not bind the variables in a @code{let} statement to specific
initial values, they will automatically be bound to an initial value of
@code{nil}, as in the following expression:

@smallexample
@group
(let ((birch 3)
      pine
      fir
      (oak 'some))
  (message
   "Here are %d variables with %s, %s, and %s value."
   birch pine fir oak))
@end group
@end smallexample

@noindent
Here, the varlist is @code{((birch 3) pine fir (oak 'some))}.

@need 1250
If you evaluate this expression in the usual way, the following will
appear in your echo area:

@smallexample
"Here are 3 variables with nil, nil, and some value."
@end smallexample

@noindent
In this example, Emacs binds the symbol @code{birch} to the number 3,
binds the symbols @code{pine} and @code{fir} to @code{nil}, and binds
the symbol @code{oak} to the value @code{some}.

Note that in the first part of the @code{let}, the variables @code{pine}
and @code{fir} stand alone as atoms that are not surrounded by
parentheses; this is because they are being bound to @code{nil}, the
empty list.  But @code{oak} is bound to @code{some} and so is a part of
the list @code{(oak 'some)}.  Similarly, @code{birch} is bound to the
number 3 and so is in a list with that number.  (Since a number
evaluates to itself, the number does not need to be quoted.  Also, the
number is printed in the message using a @samp{%d} rather than a
@samp{%s}.)  The four variables as a group are put into a list to
delimit them from the body of the @code{let}.


@node if, else, let, Writing Defuns
@comment  node-name,  next,  previous,  up
@section The @code{if} Special Form
@findex if
@cindex Conditional with @code{if}

A third special form, in addition to @code{defun} and @code{let}, is the
conditional @code{if}.  This form is used to instruct the computer to
make decisions.  You can write function definitions without using
@code{if}, but it is used often enough, and is important enough, to be
included here.  It is used, for example, in the code for the
function @code{beginning-of-buffer}.

The basic idea behind an @code{if}, is that ``@emph{if} a test is true,
@emph{then} an expression is evaluated.''  If the test is not true, the
expression is not evaluated.  For example, you might make a decision
such as, ``if it is warm and sunny, then go to the beach!''

@menu
* if in more detail::
* type-of-animal in detail::    An example of an @code{if} expression.
@end menu

@node if in more detail, type-of-animal in detail, if, if
@ifnottex
@unnumberedsubsec @code{if} in more detail
@end ifnottex

@cindex @samp{if-part} defined
@cindex @samp{then-part} defined
An @code{if} expression written in Lisp does not use the word `then';
the test and the action are the second and third elements of the list
whose first element is @code{if}.  Nonetheless, the test part of an
@code{if} expression is often called the @dfn{if-part} and the second
argument is often called the @dfn{then-part}.

Also, when an @code{if} expression is written, the true-or-false-test
is usually written on the same line as the symbol @code{if}, but the
action to carry out if the test is true, the ``then-part'', is written
on the second and subsequent lines.  This makes the @code{if}
expression easier to read.

@smallexample
@group
(if @var{true-or-false-test}
    @var{action-to-carry-out-if-test-is-true})
@end group
@end smallexample

@noindent
The true-or-false-test will be an expression that
is evaluated by the Lisp interpreter.

Here is an example that you can evaluate in the usual manner.  The test
is whether the number 5 is greater than the number 4.  Since it is, the
message @samp{5 is greater than 4!} will be printed.

@smallexample
@group
(if (> 5 4)                             ; @r{if-part}
    (message "5 is greater than 4!"))   ; @r{then-part}
@end group
@end smallexample

@noindent
(The function @code{>} tests whether its first argument is greater than
its second argument and returns true if it is.)
@findex > (greater than)

Of course, in actual use, the test in an @code{if} expression will not
be fixed for all time as it is by the expression @code{(> 5 4)}.
Instead, at least one of the variables used in the test will be bound to
a value that is not known ahead of time.  (If the value were known ahead
of time, we would not need to run the test!)

For example, the value may be bound to an argument of a function
definition.  In the following function definition, the character of the
animal is a value that is passed to the function.  If the value bound to
@code{characteristic} is @code{fierce}, then the message, @samp{It's a
tiger!} will be printed; otherwise, @code{nil} will be returned.

@smallexample
@group
(defun type-of-animal (characteristic)
  "Print message in echo area depending on CHARACTERISTIC.
If the CHARACTERISTIC is the symbol `fierce',
then warn of a tiger."
  (if (equal characteristic 'fierce)
      (message "It's a tiger!")))
@end group
@end smallexample

@need 1500
@noindent
If you are reading this inside of GNU Emacs, you can evaluate the
function definition in the usual way to install it in Emacs, and then you
can evaluate the following two expressions to see the results:

@smallexample
@group
(type-of-animal 'fierce)

(type-of-animal 'zebra)

@end group
@end smallexample

@c Following sentences rewritten to prevent overfull hbox.
@noindent
When you evaluate @code{(type-of-animal 'fierce)}, you will see the
following message printed in the echo area: @code{"It's a tiger!"}; and
when you evaluate @code{(type-of-animal 'zebra)} you will see @code{nil}
printed in the echo area.

@node type-of-animal in detail,  , if in more detail, if
@comment  node-name,  next,  previous,  up
@subsection The @code{type-of-animal} Function in Detail

Let's look at the @code{type-of-animal} function in detail.

The function definition for @code{type-of-animal} was written by filling
the slots of two templates, one for a function definition as a whole, and
a second for an @code{if} expression.

@need 1250
The template for every function that is not interactive is:

@smallexample
@group
(defun @var{name-of-function} (@var{argument-list})
  "@var{documentation}@dots{}"
  @var{body}@dots{})
@end group
@end smallexample

@need 800
The parts of the function that match this template look like this:

@smallexample
@group
(defun type-of-animal (characteristic)
  "Print message in echo area depending on CHARACTERISTIC.
If the CHARACTERISTIC is the symbol `fierce',
then warn of a tiger."
  @var{body: the} @code{if} @var{expression})
@end group
@end smallexample

The name of function is @code{type-of-animal}; it is passed the value
of one argument.  The argument list is followed by a multi-line
documentation string.  The documentation string is included in the
example because it is a good habit to write documentation string for
every function definition.  The body of the function definition
consists of the @code{if} expression.

@need 800
The template for an @code{if} expression looks like this:

@smallexample
@group
(if @var{true-or-false-test}
    @var{action-to-carry-out-if-the-test-returns-true})
@end group
@end smallexample

@need 1250
In the @code{type-of-animal} function, the code for the @code{if}
looks like this:

@smallexample
@group
(if (equal characteristic 'fierce)
    (message "It's a tiger!")))
@end group
@end smallexample

@need 800
Here, the true-or-false-test is the expression:

@smallexample
(equal characteristic 'fierce)
@end smallexample

@noindent
In Lisp, @code{equal} is a function that determines whether its first
argument is equal to its second argument.  The second argument is the
quoted symbol @code{'fierce} and the first argument is the value of the
symbol @code{characteristic}---in other words, the argument passed to
this function.

In the first exercise of @code{type-of-animal}, the argument
@code{fierce} is passed to @code{type-of-animal}.  Since @code{fierce}
is equal to @code{fierce}, the expression, @code{(equal characteristic
'fierce)}, returns a value of true.  When this happens, the @code{if}
evaluates the second argument or then-part of the @code{if}:
@code{(message "It's tiger!")}.

On the other hand, in the second exercise of @code{type-of-animal}, the
argument @code{zebra} is passed to @code{type-of-animal}.  @code{zebra}
is not equal to @code{fierce}, so the then-part is not evaluated and
@code{nil} is returned by the @code{if} expression.


@node else, Truth & Falsehood, if, Writing Defuns
@comment  node-name,  next,  previous,  up
@section If--then--else Expressions
@cindex Else

An @code{if} expression may have an optional third argument, called
the @dfn{else-part}, for the case when the true-or-false-test returns
false.  When this happens, the second argument or then-part of the
overall @code{if} expression is @emph{not} evaluated, but the third or
else-part @emph{is} evaluated.  You might think of this as the cloudy
day alternative for the decision ``if it is warm and sunny, then go to
the beach, else read a book!''.

The word ``else'' is not written in the Lisp code; the else-part of an
@code{if} expression comes after the then-part.  In the written Lisp, the
else-part is usually written to start on a line of its own and is
indented less than the then-part:

@smallexample
@group
(if @var{true-or-false-test}
    @var{action-to-carry-out-if-the-test-returns-true}
  @var{action-to-carry-out-if-the-test-returns-false})
@end group
@end smallexample

For example, the following @code{if} expression prints the message @samp{4
is not greater than 5!} when you evaluate it in the usual way:

@smallexample
@group
(if (> 4 5)                               ; @r{if-part}
    (message "4 falsely greater than 5!") ; @r{then-part}
  (message "4 is not greater than 5!"))   ; @r{else-part}
@end group
@end smallexample

@noindent
Note that the different levels of indentation make it easy to
distinguish the then-part from the else-part.  (GNU Emacs has several
commands that automatically indent @code{if} expressions correctly.
@xref{List 입력하기, , GNU Emacs는 List 입력을 돕는다}.)

We can extend the @code{type-of-animal} function to include an
else-part by simply incorporating an additional part to the @code{if}
expression.

@need 1500
You can see the consequences of doing this if you evaluate the following
version of the @code{type-of-animal} function definition to install it
and then evaluate the two subsequent expressions to pass different
arguments to the function.

@smallexample
@group
(defun type-of-animal (characteristic)  ; @r{Second version.}
  "Print message in echo area depending on CHARACTERISTIC.
If the CHARACTERISTIC is the symbol `fierce',
then warn of a tiger;
else say it's not fierce."
  (if (equal characteristic 'fierce)
      (message "It's a tiger!")
    (message "It's not fierce!")))
@end group
@end smallexample
@sp 1

@smallexample
@group
(type-of-animal 'fierce)

(type-of-animal 'zebra)

@end group
@end smallexample

@c Following sentence rewritten to prevent overfull hbox.
@noindent
When you evaluate @code{(type-of-animal 'fierce)}, you will see the
following message printed in the echo area: @code{"It's a tiger!"}; but
when you evaluate @code{(type-of-animal 'zebra)}, you will see
@code{"It's not fierce!"}.

(Of course, if the @var{characteristic} were @code{ferocious}, the
message @code{"It's not fierce!"} would be printed; and it would be
misleading!  When you write code, you need to take into account the
possibility that some such argument will be tested by the @code{if}
and write your program accordingly.)


@node Truth & Falsehood, save-excursion, else, Writing Defuns
@comment  node-name,  next,  previous,  up
@section Truth and Falsehood in Emacs Lisp
@cindex Truth and falsehood in Emacs Lisp
@cindex Falsehood and truth in Emacs Lisp
@findex nil

There is an important aspect to the truth test in an @code{if}
expression.  So far, we have spoken of `true' and `false' as values of
predicates as if they were new kinds of Emacs Lisp objects.  In fact,
`false' is just our old friend @code{nil}.  Anything else---anything
at all---is `true'.

The expression that tests for truth is interpreted as @dfn{true}
if the result of evaluating it is a value that is not @code{nil}.  In
other words, the result of the test is considered true if the value
returned is a number such as 47, a string such as @code{"hello"}, or a
symbol (other than @code{nil}) such as @code{flowers}, or a list (so
long as it is not empty), or even a buffer!

@menu
* nil explained::               @code{nil} has two meanings.
@end menu

@node nil explained,  , Truth & Falsehood, Truth & Falsehood
@ifnottex
@unnumberedsubsec An explanation of @code{nil}
@end ifnottex

Before illustrating a test for truth, we need an explanation of @code{nil}.

In Emacs Lisp, the symbol @code{nil} has two meanings.  First, it means the
empty list.  Second, it means false and is the value returned when a
true-or-false-test tests false.  @code{nil} can be written as an empty
list, @code{()}, or as @code{nil}.  As far as the Lisp interpreter is
concerned, @code{()} and @code{nil} are the same.  Humans, however, tend
to use @code{nil} for false and @code{()} for the empty list.

In Emacs Lisp, any value that is not @code{nil}---is not the empty
list---is considered true.  This means that if an evaluation returns
something that is not an empty list, an @code{if} expression will test
true.  For example, if a number is put in the slot for the test, it
will be evaluated and will return itself, since that is what numbers
do when evaluated.  In this conditional, the @code{if} expression will
test true.  The expression tests false only when @code{nil}, an empty
list, is returned by evaluating the expression.

You can see this by evaluating the two expressions in the following examples.

In the first example, the number 4 is evaluated as the test in the
@code{if} expression and returns itself; consequently, the then-part
of the expression is evaluated and returned: @samp{true} appears in
the echo area.  In the second example, the @code{nil} indicates false;
consequently, the else-part of the expression is evaluated and
returned: @samp{false} appears in the echo area.

@smallexample
@group
(if 4
    'true
  'false)
@end group

@group
(if nil
    'true
  'false)
@end group
@end smallexample

@need 1250
Incidentally, if some other useful value is not available for a test that
returns true, then the Lisp interpreter will return the symbol @code{t}
for true.  For example, the expression @code{(> 5 4)} returns @code{t}
when evaluated, as you can see by evaluating it in the usual way:

@smallexample
(> 5 4)
@end smallexample

@need 1250
@noindent
On the other hand, this function returns @code{nil} if the test is false.

@smallexample
(> 4 5)
@end smallexample


@node save-excursion, Review, Truth & Falsehood, Writing Defuns
@comment  node-name,  next,  previous,  up
@section @code{save-excursion}
@findex save-excursion
@cindex Region, what it is
@cindex Preserving point, mark, and buffer
@cindex Point, mark, buffer preservation
@findex point
@findex mark

The @code{save-excursion} function is the fourth and final special form
that we will discuss in this chapter.

In Emacs Lisp programs used for editing, the @code{save-excursion}
function is very common.  It saves the location of point and mark,
executes the body of the function, and then restores point and mark to
their previous positions if their locations were changed.  Its primary
purpose is to keep the user from being surprised and disturbed by
unexpected movement of point or mark.

@menu
* Point and mark::              A review of various locations.
* Template for save-excursion::
@end menu

@node Point and mark, Template for save-excursion, save-excursion, save-excursion
@ifnottex
@unnumberedsubsec Point and Mark
@end ifnottex

Before discussing @code{save-excursion}, however, it may be useful
first to review what point and mark are in GNU Emacs.  @dfn{Point} is
the current location of the cursor.  Wherever the cursor
is, that is point.  More precisely, on terminals where the cursor
appears to be on top of a character, point is immediately before the
character.  In Emacs Lisp, point is an integer.  The first character in
a buffer is number one, the second is number two, and so on.  The
function @code{point} returns the current position of the cursor as a
number.  Each buffer has its own value for point.

The @dfn{mark} is another position in the buffer; its value can be set
with a command such as @kbd{C-@key{SPC}} (@code{set-mark-command}).  If
a mark has been set, you can use the command @kbd{C-x C-x}
(@code{exchange-point-and-mark}) to cause the cursor to jump to the mark
and set the mark to be the previous position of point.  In addition, if
you set another mark, the position of the previous mark is saved in the
mark ring.  Many mark positions can be saved this way.  You can jump the
cursor to a saved mark by typing @kbd{C-u C-@key{SPC}} one or more
times.

The part of the buffer between point and mark is called @dfn{the
region}.  Numerous commands work on the region, including
@code{center-region}, @code{count-lines-region}, @code{kill-region}, and
@code{print-region}.

The @code{save-excursion} special form saves the locations of point and
mark and restores those positions after the code within the body of the
special form is evaluated by the Lisp interpreter.  Thus, if point were
in the beginning of a piece of text and some code moved point to the end
of the buffer, the @code{save-excursion} would put point back to where
it was before, after the expressions in the body of the function were
evaluated.

In Emacs, a function frequently moves point as part of its internal
workings even though a user would not expect this.  For example,
@code{count-lines-region} moves point.  To prevent the user from being
bothered by jumps that are both unexpected and (from the user's point of
view) unnecessary, @code{save-excursion} is often used to keep point and
mark in the location expected by the user.  The use of
@code{save-excursion} is good housekeeping.

To make sure the house stays clean, @code{save-excursion} restores the
values of point and mark even if something goes wrong in the code inside
of it (or, to be more precise and to use the proper jargon, ``in case of
abnormal exit'').  This feature is very helpful.

In addition to recording the values of point and mark,
@code{save-excursion} keeps track of the current buffer, and restores
it, too.  This means you can write code that will change the buffer and
have @code{save-excursion} switch you back to the original buffer.
This is how @code{save-excursion} is used in @code{append-to-buffer}.
(@xref{append-to-buffer, , The Definition of @code{append-to-buffer}}.)

@node Template for save-excursion,  , Point and mark, save-excursion
@comment  node-name,  next,  previous,  up
@subsection Template for a @code{save-excursion} Expression

@need 800
The template for code using @code{save-excursion} is simple:

@smallexample
@group
(save-excursion
  @var{body}@dots{})
@end group
@end smallexample

@noindent
The body of the function is one or more expressions that will be
evaluated in sequence by the Lisp interpreter.  If there is more than
one expression in the body, the value of the last one will be returned
as the value of the @code{save-excursion} function.  The other
expressions in the body are evaluated only for their side effects; and
@code{save-excursion} itself is used only for its side effect (which
is restoring the positions of point and mark).

@need 1250
In more detail, the template for a @code{save-excursion} expression
looks like this:

@smallexample
@group
(save-excursion
  @var{first-expression-in-body}
  @var{second-expression-in-body}
  @var{third-expression-in-body}
   @dots{}
  @var{last-expression-in-body})
@end group
@end smallexample

@noindent
An expression, of course, may be a symbol on its own or a list.

In Emacs Lisp code, a @code{save-excursion} expression often occurs
within the body of a @code{let} expression.  It looks like this:

@smallexample
@group
(let @var{varlist}
  (save-excursion
    @var{body}@dots{}))
@end group
@end smallexample


@node Review, defun Exercises, save-excursion, Writing Defuns
@comment  node-name,  next,  previous,  up
@section Review

In the last few chapters we have introduced a fair number of functions
and special forms.  Here they are described in brief, along with a few
similar functions that have not been mentioned yet.

@table @code
@item eval-last-sexp
Evaluate the last symbolic expression before the current location of
point.  The value is printed in the echo area unless the function is
invoked with an argument; in that case, the output is printed in the
current buffer.  This command is normally bound to @kbd{C-x C-e}.

@item defun
Define function.  This special form has up to five parts: the name,
a template for the arguments that will be passed to the function,
documentation, an optional interactive declaration, and the body of the
definition.

@need 1250
For example, in an early version of Emacs, the function definition was
as follows.  (It is slightly more complex now that it seeks the first
non-whitespace character rather than the first visible character.)

@smallexample
@group
(defun back-to-indentation ()
  "Move point to first visible character on line."
  (interactive)
  (beginning-of-line 1)
  (skip-chars-forward " \t"))
@end group
@end smallexample

@ignore
In GNU Emacs 22,

(defun backward-to-indentation (&optional arg)
  "Move backward ARG lines and position at first nonblank character."
  (interactive "p")
  (forward-line (- (or arg 1)))
  (skip-chars-forward " \t"))

(defun back-to-indentation ()
  "Move point to the first non-whitespace character on this line."
  (interactive)
  (beginning-of-line 1)
  (skip-syntax-forward " " (line-end-position))
  ;; Move back over chars that have whitespace syntax but have the p flag.
  (backward-prefix-chars))
@end ignore

@item interactive
Declare to the interpreter that the function can be used
interactively.  This special form may be followed by a string with one
or more parts that pass the information to the arguments of the
function, in sequence.  These parts may also tell the interpreter to
prompt for information.  Parts of the string are separated by
newlines, @samp{\n}.

@need 1000
Common code characters are:

@table @code
@item b
The name of an existing buffer.

@item f
The name of an existing file.

@item p
The numeric prefix argument.  (Note that this `p' is lower case.)

@item r
Point and the mark, as two numeric arguments, smallest first.  This
is the only code letter that specifies two successive arguments
rather than one.
@end table

@xref{Interactive Codes, , Code Characters for @samp{interactive},
elisp, The GNU Emacs Lisp Reference Manual}, for a complete list of
code characters.

@item let
Declare that a list of variables is for use within the body of the
@code{let} and give them an initial value, either @code{nil} or a
specified value; then evaluate the rest of the expressions in the body
of the @code{let} and return the value of the last one.  Inside the
body of the @code{let}, the Lisp interpreter does not see the values of
the variables of the same names that are bound outside of the
@code{let}.

@need 1250
For example,

@smallexample
@group
(let ((foo (buffer-name))
      (bar (buffer-size)))
  (message
   "This buffer is %s and has %d characters."
   foo bar))
@end group
@end smallexample

@item save-excursion
Record the values of point and mark and the current buffer before
evaluating the body of this special form.  Restore the values of point
and mark and buffer afterward.

@need 1250
For example,

@smallexample
@group
(message "We are %d characters into this buffer."
         (- (point)
            (save-excursion
              (goto-char (point-min)) (point))))
@end group
@end smallexample

@item if
Evaluate the first argument to the function; if it is true, evaluate
the second argument; else evaluate the third argument, if there is one.

The @code{if} special form is called a @dfn{conditional}.  There are
other conditionals in Emacs Lisp, but @code{if} is perhaps the most
commonly used.

@need 1250
For example,

@smallexample
@group
(if (= 22 emacs-major-version)
    (message "This is version 22 Emacs")
  (message "This is not version 22 Emacs"))
@end group
@end smallexample

@need 1250
@item <
@itemx >
@itemx <=
@itemx >=
The @code{<} function tests whether its first argument is smaller than
its second argument.  A corresponding function, @code{>}, tests whether
the first argument is greater than the second.  Likewise, @code{<=}
tests whether the first argument is less than or equal to the second and
@code{>=} tests whether the first argument is greater than or equal to
the second.  In all cases, both arguments must be numbers or markers
(markers indicate positions in buffers).

@need 800
@item =
The @code{=} function tests whether two arguments, both numbers or
markers, are equal.

@need 1250
@item equal
@itemx eq
Test whether two objects are the same.  @code{equal} uses one meaning
of the word `same' and @code{eq} uses another:  @code{equal} returns
true if the two objects have a similar structure and contents, such as
two copies of the same book.  On the other hand, @code{eq}, returns
true if both arguments are actually the same object.
@findex equal
@findex eq

@need 1250
@item string<
@itemx string-lessp
@itemx string=
@itemx string-equal
The @code{string-lessp} function tests whether its first argument is
smaller than the second argument.  A shorter, alternative name for the
same function (a @code{defalias}) is @code{string<}.

The arguments to @code{string-lessp} must be strings or symbols; the
ordering is lexicographic, so case is significant.  The print names of
symbols are used instead of the symbols themselves.

@cindex @samp{empty string} defined
An empty string, @samp{""}, a string with no characters in it, is
smaller than any string of characters.

@code{string-equal} provides the corresponding test for equality.  Its
shorter, alternative name is @code{string=}.  There are no string test
functions that correspond to @var{>}, @code{>=}, or @code{<=}.

@item message
Print a message in the echo area. The first argument is a string that
can contain @samp{%s}, @samp{%d}, or @samp{%c} to print the value of
arguments that follow the string.  The argument used by @samp{%s} must
be a string or a symbol; the argument used by @samp{%d} must be a
number.  The argument used by @samp{%c} must be an @sc{ascii} code
number; it will be printed as the character with that @sc{ascii} code.
(Various other %-sequences have not been mentioned.)

@item setq
@itemx set
The @code{setq} function sets the value of its first argument to the
value of the second argument.  The first argument is automatically
quoted by @code{setq}.  It does the same for succeeding pairs of
arguments.  Another function, @code{set}, takes only two arguments and
evaluates both of them before setting the value returned by its first
argument to the value returned by its second argument.

@item buffer-name
Without an argument, return the name of the buffer, as a string.

@itemx buffer-file-name
Without an argument, return the name of the file the buffer is
visiting.

@item current-buffer
Return the buffer in which Emacs is active; it may not be
the buffer that is visible on the screen.

@item other-buffer
Return the most recently selected buffer (other than the buffer passed
to @code{other-buffer} as an argument and other than the current
buffer).

@item switch-to-buffer
Select a buffer for Emacs to be active in and display it in the current
window so users can look at it.  Usually bound to @kbd{C-x b}.

@item set-buffer
Switch Emacs' attention to a buffer on which programs will run.  Don't
alter what the window is showing.

@item buffer-size
Return the number of characters in the current buffer.

@item point
Return the value of the current position of the cursor, as an
integer counting the number of characters from the beginning of the
buffer.

@item point-min
Return the minimum permissible value of point in
the current buffer.  This is 1, unless narrowing is in effect.

@item point-max
Return the value of the maximum permissible value of point in the
current buffer.  This is the end of the buffer, unless narrowing is in
effect.
@end table


@need 1500
@node defun Exercises,  , Review, Writing Defuns
@section Exercises

@itemize @bullet
@item
Write a non-interactive function that doubles the value of its
argument, a number.  Make that function interactive.

@item
Write a function that tests whether the current value of
@code{fill-column} is greater than the argument passed to the function,
and if so, prints an appropriate message.
@end itemize


@node Buffer Walk Through, More Complex, Writing Defuns, Top
@comment  node-name,  next,  previous,  up
@chapter A Few Buffer--Related Functions

In this chapter we study in detail several of the functions used in GNU
Emacs.  This is called a ``walk-through''.  These functions are used as
examples of Lisp code, but are not imaginary examples; with the
exception of the first, simplified function definition, these functions
show the actual code used in GNU Emacs.  You can learn a great deal from
these definitions.  The functions described here are all related to
buffers.  Later, we will study other functions.

@menu
* Finding More::                How to find more information.
* simplified-beginning-of-buffer::  Shows @code{goto-char},
                                @code{point-min}, and @code{push-mark}.
* mark-whole-buffer::           Almost the same as @code{beginning-of-buffer}.
* append-to-buffer::            Uses @code{save-excursion} and
                                @code{insert-buffer-substring}.
* Buffer Related Review::       Review.
* Buffer Exercises::
@end menu


@node Finding More, simplified-beginning-of-buffer, Buffer Walk Through, Buffer Walk Through
@section Finding More Information

@findex describe-function, @r{introduced}
@cindex Find function documentation
In this walk-through, I will describe each new function as we come to
it, sometimes in detail and sometimes briefly.  If you are interested,
you can get the full documentation of any Emacs Lisp function at any
time by typing @kbd{C-h f} and then the name of the function (and then
@key{RET}).  Similarly, you can get the full documentation for a
variable by typing @kbd{C-h v} and then the name of the variable (and
then @key{RET}).

@cindex Find source of function
@c In version 22, tells location both of C and of Emacs Lisp
Also, @code{describe-function} will tell you the location of the
function definition.

Put point into the name of the file that contains the function and
press the @key{RET} key.  In this case, @key{RET} means
@code{push-button} rather than `return' or `enter'.  Emacs will take
you directly to the function definition.

@ignore
Not In version 22

If you move point over the file name and press
the @key{RET} key, which in this case means @code{help-follow} rather
than `return' or `enter', Emacs will take you directly to the function
definition.
@end ignore

More generally, if you want to see a function in its original source
file, you can use the @code{find-tag} function to jump to it.
@code{find-tag} works with a wide variety of languages, not just
Lisp, and C, and it works with non-programming text as well.  For
example, @code{find-tag} will jump to the various nodes in the
Texinfo source file of this document.
The @code{find-tag} function depends on `tags tables' that record
the locations of the functions, variables, and other items to which
@code{find-tag} jumps.

To use the @code{find-tag} command, type @kbd{M-.}  (i.e., press the
period key while holding down the @key{META} key, or else type the
@key{ESC} key and then type the period key), and then, at the prompt,
type in the name of the function whose source code you want to see,
such as @code{mark-whole-buffer}, and then type @key{RET}.  Emacs will
switch buffers and display the source code for the function on your
screen.  To switch back to your current buffer, type @kbd{C-x b
@key{RET}}.  (On some keyboards, the @key{META} key is labelled
@key{ALT}.)

@c !!! 22.1.1 tags table location in this paragraph
@cindex TAGS table, specifying
@findex find-tag
Depending on how the initial default values of your copy of Emacs are
set, you may also need to specify the location of your `tags table',
which is a file called @file{TAGS}.  For example, if you are
interested in Emacs sources, the tags table you will most likely want,
if it has already been created for you, will be in a subdirectory of
the @file{/usr/local/share/emacs/} directory; thus you would use the
@code{M-x visit-tags-table} command and specify a pathname such as
@file{/usr/local/share/emacs/22.1.1/lisp/TAGS}.  If the tags table
has not already been created, you will have to create it yourself.  It
will be in a file such as @file{/usr/local/src/emacs/src/TAGS}.

@need 1250
To create a @file{TAGS} file in a specific directory, switch to that
directory in Emacs using @kbd{M-x cd} command, or list the directory
with @kbd{C-x d} (@code{dired}).  Then run the compile command, with
@w{@code{etags *.el}} as the command to execute:

@smallexample
M-x compile RET etags *.el RET
@end smallexample

For more information, see @ref{etags, , Create Your Own @file{TAGS} File}.

After you become more familiar with Emacs Lisp, you will find that you will
frequently use @code{find-tag} to navigate your way around source code;
and you will create your own @file{TAGS} tables.

@cindex Library, as term for `file'
Incidentally, the files that contain Lisp code are conventionally
called @dfn{libraries}.  The metaphor is derived from that of a
specialized library, such as a law library or an engineering library,
rather than a general library.  Each library, or file, contains
functions that relate to a particular topic or activity, such as
@file{abbrev.el} for handling abbreviations and other typing
shortcuts, and @file{help.el} for on-line help.  (Sometimes several
libraries provide code for a single activity, as the various
@file{rmail@dots{}} files provide code for reading electronic mail.)
In @cite{The GNU Emacs Manual}, you will see sentences such as ``The
@kbd{C-h p} command lets you search the standard Emacs Lisp libraries
by topic keywords.''


@node simplified-beginning-of-buffer, mark-whole-buffer, Finding More, Buffer Walk Through
@comment  node-name,  next,  previous,  up
@section A Simplified @code{beginning-of-buffer} Definition
@findex simplified-beginning-of-buffer

The @code{beginning-of-buffer} command is a good function to start with
since you are likely to be familiar with it and it is easy to
understand.  Used as an interactive command, @code{beginning-of-buffer}
moves the cursor to the beginning of the buffer, leaving the mark at the
previous position.  It is generally bound to @kbd{M-<}.

In this section, we will discuss a shortened version of the function
that shows how it is most frequently used.  This shortened function
works as written, but it does not contain the code for a complex option.
In another section, we will describe the entire function.
(@xref{beginning-of-buffer, , Complete Definition of
@code{beginning-of-buffer}}.)

Before looking at the code, let's consider what the function
definition has to contain: it must include an expression that makes
the function interactive so it can be called by typing @kbd{M-x
beginning-of-buffer} or by typing a keychord such as @kbd{M-<}; it
must include code to leave a mark at the original position in the
buffer; and it must include code to move the cursor to the beginning
of the buffer.

@need 1250
Here is the complete text of the shortened version of the function:

@smallexample
@group
(defun simplified-beginning-of-buffer ()
  "Move point to the beginning of the buffer;
leave mark at previous position."
  (interactive)
  (push-mark)
  (goto-char (point-min)))
@end group
@end smallexample

Like all function definitions, this definition has five parts following
the special form @code{defun}:

@enumerate
@item
The name: in this example, @code{simplified-beginning-of-buffer}.

@item
A list of the arguments: in this example, an empty list, @code{()},

@item
The documentation string.

@item
The interactive expression.

@item
The body.
@end enumerate

@noindent
In this function definition, the argument list is empty; this means that
this function does not require any arguments.  (When we look at the
definition for the complete function, we will see that it may be passed
an optional argument.)

The interactive expression tells Emacs that the function is intended to
be used interactively.  In this example, @code{interactive} does not have
an argument because @code{simplified-beginning-of-buffer} does not
require one.

@need 800
The body of the function consists of the two lines:

@smallexample
@group
(push-mark)
(goto-char (point-min))
@end group
@end smallexample

The first of these lines is the expression, @code{(push-mark)}.  When
this expression is evaluated by the Lisp interpreter, it sets a mark at
the current position of the cursor, wherever that may be.  The position
of this mark is saved in the mark ring.

The next line is @code{(goto-char (point-min))}.  This expression
jumps the cursor to the minimum point in the buffer, that is, to the
beginning of the buffer (or to the beginning of the accessible portion
of the buffer if it is narrowed.  @xref{Narrowing & Widening, ,
Narrowing and Widening}.)

The @code{push-mark} command sets a mark at the place where the cursor
was located before it was moved to the beginning of the buffer by the
@code{(goto-char (point-min))} expression.  Consequently, you can, if
you wish, go back to where you were originally by typing @kbd{C-x C-x}.

That is all there is to the function definition!

@findex describe-function
When you are reading code such as this and come upon an unfamiliar
function, such as @code{goto-char}, you can find out what it does by
using the @code{describe-function} command.  To use this command, type
@kbd{C-h f} and then type in the name of the function and press
@key{RET}.  The @code{describe-function} command will print the
function's documentation string in a @file{*Help*} window.  For
example, the documentation for @code{goto-char} is:

@smallexample
@group
Set point to POSITION, a number or marker.
Beginning of buffer is position (point-min), end is (point-max).
@end group
@end smallexample

@noindent
The function's one argument is the desired position.

@noindent
(The prompt for @code{describe-function} will offer you the symbol
under or preceding the cursor, so you can save typing by positioning
the cursor right over or after the function and then typing @kbd{C-h f
@key{RET}}.)

The @code{end-of-buffer} function definition is written in the same way as
the @code{beginning-of-buffer} definition except that the body of the
function contains the expression @code{(goto-char (point-max))} in place
of @code{(goto-char (point-min))}.


@node mark-whole-buffer, append-to-buffer, simplified-beginning-of-buffer, Buffer Walk Through
@comment  node-name,  next,  previous,  up
@section The Definition of @code{mark-whole-buffer}
@findex mark-whole-buffer

The @code{mark-whole-buffer} function is no harder to understand than the
@code{simplified-beginning-of-buffer} function.  In this case, however,
we will look at the complete function, not a shortened version.

The @code{mark-whole-buffer} function is not as commonly used as the
@code{beginning-of-buffer} function, but is useful nonetheless: it
marks a whole buffer as a region by putting point at the beginning and
a mark at the end of the buffer.  It is generally bound to @kbd{C-x
h}.

@menu
* mark-whole-buffer overview::
* Body of mark-whole-buffer::   Only three lines of code.
@end menu

@node mark-whole-buffer overview, Body of mark-whole-buffer, mark-whole-buffer, mark-whole-buffer
@ifnottex
@unnumberedsubsec An overview of @code{mark-whole-buffer}
@end ifnottex

@need 1250
In GNU Emacs 22, the code for the complete function looks like this:

@smallexample
@group
(defun mark-whole-buffer ()
  "Put point at beginning and mark at end of buffer.
You probably should not use this function in Lisp programs;
it is usually a mistake for a Lisp function to use any subroutine
that uses or sets the mark."
  (interactive)
  (push-mark (point))
  (push-mark (point-max) nil t)
  (goto-char (point-min)))
@end group
@end smallexample

@need 1250
Like all other functions, the @code{mark-whole-buffer} function fits
into the template for a function definition.  The template looks like
this:

@smallexample
@group
(defun @var{name-of-function} (@var{argument-list})
  "@var{documentation}@dots{}"
  (@var{interactive-expression}@dots{})
  @var{body}@dots{})
@end group
@end smallexample

Here is how the function works: the name of the function is
@code{mark-whole-buffer}; it is followed by an empty argument list,
@samp{()}, which means that the function does not require arguments.
The documentation comes next.

The next line is an @code{(interactive)} expression that tells Emacs
that the function will be used interactively.  These details are similar
to the @code{simplified-beginning-of-buffer} function described in the
previous section.

@need 1250
@node Body of mark-whole-buffer,  , mark-whole-buffer overview, mark-whole-buffer
@comment  node-name,  next,  previous,  up
@subsection Body of @code{mark-whole-buffer}

The body of the @code{mark-whole-buffer} function consists of three
lines of code:

@c GNU Emacs 22
@smallexample
@group
(push-mark (point))
(push-mark (point-max) nil t)
(goto-char (point-min))
@end group
@end smallexample

The first of these lines is the expression, @code{(push-mark (point))}.

This line does exactly the same job as the first line of the body of
the @code{simplified-beginning-of-buffer} function, which is written
@code{(push-mark)}.  In both cases, the Lisp interpreter sets a mark
at the current position of the cursor.

I don't know why the expression in @code{mark-whole-buffer} is written
@code{(push-mark (point))} and the expression in
@code{beginning-of-buffer} is written @code{(push-mark)}.  Perhaps
whoever wrote the code did not know that the arguments for
@code{push-mark} are optional and that if @code{push-mark} is not
passed an argument, the function automatically sets mark at the
location of point by default.  Or perhaps the expression was written
so as to parallel the structure of the next line.  In any case, the
line causes Emacs to determine the position of point and set a mark
there.

In earlier versions of GNU Emacs, the next line of
@code{mark-whole-buffer} was @code{(push-mark (point-max))}.  This
expression sets a mark at the point in the buffer that has the highest
number.  This will be the end of the buffer (or, if the buffer is
narrowed, the end of the accessible portion of the buffer.
@xref{Narrowing & Widening, , Narrowing and Widening}, for more about
narrowing.)  After this mark has been set, the previous mark, the one
set at point, is no longer set, but Emacs remembers its position, just
as all other recent marks are always remembered.  This means that you
can, if you wish, go back to that position by typing @kbd{C-u
C-@key{SPC}} twice.

@need 1250
In GNU Emacs 22, the @code{(point-max)} is slightly more complicated.
The line reads

@smallexample
(push-mark (point-max) nil t)
@end smallexample

@noindent
The expression works nearly the same as before.  It sets a mark at the
highest numbered place in the buffer that it can.  However, in this
version, @code{push-mark} has two additional arguments.  The second
argument to @code{push-mark} is @code{nil}.  This tells the function
it @emph{should} display a message that says `Mark set' when it pushes
the mark.  The third argument is @code{t}.  This tells
@code{push-mark} to activate the mark when Transient Mark mode is
turned on.  Transient Mark mode highlights the currently active
region.  It is often turned off.

Finally, the last line of the function is @code{(goto-char
(point-min)))}.  This is written exactly the same way as it is written
in @code{beginning-of-buffer}.  The expression moves the cursor to
the minimum point in the buffer, that is, to the beginning of the buffer
(or to the beginning of the accessible portion of the buffer).  As a
result of this, point is placed at the beginning of the buffer and mark
is set at the end of the buffer.  The whole buffer is, therefore, the
region.


@node append-to-buffer, Buffer Related Review, mark-whole-buffer, Buffer Walk Through
@comment  node-name,  next,  previous,  up
@section The Definition of @code{append-to-buffer}
@findex append-to-buffer

The @code{append-to-buffer} command is more complex than the
@code{mark-whole-buffer} command.  What it does is copy the region
(that is, the part of the buffer between point and mark) from the
current buffer to a specified buffer.

@menu
* append-to-buffer overview::
* append interactive::          A two part interactive expression.
* append-to-buffer body::       Incorporates a @code{let} expression.
* append save-excursion::       How the @code{save-excursion} works.
@end menu

@node append-to-buffer overview, append interactive, append-to-buffer, append-to-buffer
@ifnottex
@unnumberedsubsec An Overview of @code{append-to-buffer}
@end ifnottex

@findex insert-buffer-substring
The @code{append-to-buffer} command uses the
@code{insert-buffer-substring} function to copy the region.
@code{insert-buffer-substring} is described by its name: it takes a
string of characters from part of a buffer, a ``substring'', and
inserts them into another buffer.

Most of @code{append-to-buffer} is
concerned with setting up the conditions for
@code{insert-buffer-substring} to work: the code must specify both the
buffer to which the text will go, the window it comes from and goes
to, and the region that will be copied.

@need 1250
Here is the complete text of the function:

@smallexample
@group
(defun append-to-buffer (buffer start end)
  "Append to specified buffer the text of the region.
It is inserted into that buffer before its point.
@end group

@group
When calling from a program, give three arguments:
BUFFER (or buffer name), START and END.
START and END specify the portion of the current buffer to be copied."
  (interactive
   (list (read-buffer "Append to buffer: " (other-buffer
                                            (current-buffer) t))
         (region-beginning) (region-end)))
@end group
@group
  (let ((oldbuf (current-buffer)))
    (save-excursion
      (let* ((append-to (get-buffer-create buffer))
             (windows (get-buffer-window-list append-to t t))
             point)
        (set-buffer append-to)
        (setq point (point))
        (barf-if-buffer-read-only)
        (insert-buffer-substring oldbuf start end)
        (dolist (window windows)
          (when (= (window-point window) point)
            (set-window-point window (point))))))))
@end group
@end smallexample

The function can be understood by looking at it as a series of
filled-in templates.

The outermost template is for the function definition.  In this
function, it looks like this (with several slots filled in):

@smallexample
@group
(defun append-to-buffer (buffer start end)
  "@var{documentation}@dots{}"
  (interactive @dots{})
  @var{body}@dots{})
@end group
@end smallexample

The first line of the function includes its name and three arguments.
The arguments are the @code{buffer} to which the text will be copied, and
the @code{start} and @code{end} of the region in the current buffer that
will be copied.

The next part of the function is the documentation, which is clear and
complete.  As is conventional, the three arguments are written in
upper case so you will notice them easily.  Even better, they are
described in the same order as in the argument list.

Note that the documentation distinguishes between a buffer and its
name.  (The function can handle either.)

@node append interactive, append-to-buffer body, append-to-buffer overview, append-to-buffer
@comment  node-name,  next,  previous,  up
@subsection The @code{append-to-buffer} Interactive Expression

Since the @code{append-to-buffer} function will be used interactively,
the function must have an @code{interactive} expression.  (For a
review of @code{interactive}, see @ref{Interactive, , Making a
Function Interactive}.)  The expression reads as follows:

@smallexample
@group
(interactive
 (list (read-buffer
        "Append to buffer: "
        (other-buffer (current-buffer) t))
       (region-beginning)
       (region-end)))
@end group
@end smallexample

@noindent
This expression is not one with letters standing for parts, as
described earlier.  Instead, it starts a list with these parts:

The first part of the list is an expression to read the name of a
buffer and return it as a string.  That is @code{read-buffer}.  The
function requires a prompt as its first argument, @samp{"Append to
buffer: "}.  Its second argument tells the command what value to
provide if you don't specify anything.

In this case that second argument is an expression containing the
function @code{other-buffer}, an exception, and a @samp{t}, standing
for true.

The first argument to @code{other-buffer}, the exception, is yet
another function, @code{current-buffer}.  That is not going to be
returned.  The second argument is the symbol for true, @code{t}. that
tells @code{other-buffer} that it may show visible buffers (except in
this case, it will not show the current buffer, which makes sense).

@need 1250
The expression looks like this:

@smallexample
(other-buffer (current-buffer) t)
@end smallexample

The second and third arguments to the @code{list} expression are
@code{(region-beginning)} and @code{(region-end)}.  These two
functions specify the beginning and end of the text to be appended.

@need 1250
Originally, the command used the letters @samp{B} and @samp{r}.
The whole @code{interactive} expression looked like this:

@smallexample
(interactive "BAppend to buffer:@: \nr")
@end smallexample

@noindent
But when that was done, the default value of the buffer switched to
was invisible.  That was not wanted.

(The prompt was separated from the second argument with a newline,
@samp{\n}.  It was followed by an @samp{r} that told Emacs to bind the
two arguments that follow the symbol @code{buffer} in the function's
argument list (that is, @code{start} and @code{end}) to the values of
point and mark.  That argument worked fine.)

@node append-to-buffer body, append save-excursion, append interactive, append-to-buffer
@comment  node-name,  next,  previous,  up
@subsection The Body of @code{append-to-buffer}

@ignore
in GNU Emacs 22   in    /usr/local/src/emacs/lisp/simple.el

(defun append-to-buffer (buffer start end)
  "Append to specified buffer the text of the region.
It is inserted into that buffer before its point.

When calling from a program, give three arguments:
BUFFER (or buffer name), START and END.
START and END specify the portion of the current buffer to be copied."
  (interactive
   (list (read-buffer "Append to buffer: " (other-buffer (current-buffer) t))
         (region-beginning) (region-end)))
  (let ((oldbuf (current-buffer)))
    (save-excursion
      (let* ((append-to (get-buffer-create buffer))
             (windows (get-buffer-window-list append-to t t))
             point)
        (set-buffer append-to)
        (setq point (point))
        (barf-if-buffer-read-only)
        (insert-buffer-substring oldbuf start end)
        (dolist (window windows)
          (when (= (window-point window) point)
            (set-window-point window (point))))))))
@end ignore

The body of the @code{append-to-buffer} function begins with @code{let}.

As we have seen before (@pxref{let, , @code{let}}), the purpose of a
@code{let} expression is to create and give initial values to one or
more variables that will only be used within the body of the
@code{let}.  This means that such a variable will not be confused with
any variable of the same name outside the @code{let} expression.

We can see how the @code{let} expression fits into the function as a
whole by showing a template for @code{append-to-buffer} with the
@code{let} expression in outline:

@smallexample
@group
(defun append-to-buffer (buffer start end)
  "@var{documentation}@dots{}"
  (interactive @dots{})
  (let ((@var{variable} @var{value}))
        @var{body}@dots{})
@end group
@end smallexample

The @code{let} expression has three elements:

@enumerate
@item
The symbol @code{let};

@item
A varlist containing, in this case, a single two-element list,
@code{(@var{variable} @var{value})};

@item
The body of the @code{let} expression.
@end enumerate

@need 800
In the @code{append-to-buffer} function, the varlist looks like this:

@smallexample
(oldbuf (current-buffer))
@end smallexample

@noindent
In this part of the @code{let} expression, the one variable,
@code{oldbuf}, is bound to the value returned by the
@code{(current-buffer)} expression.  The variable, @code{oldbuf}, is
used to keep track of the buffer in which you are working and from
which you will copy.

The element or elements of a varlist are surrounded by a set of
parentheses so the Lisp interpreter can distinguish the varlist from
the body of the @code{let}.  As a consequence, the two-element list
within the varlist is surrounded by a circumscribing set of parentheses.
The line looks like this:

@smallexample
@group
(let ((oldbuf (current-buffer)))
  @dots{} )
@end group
@end smallexample

@noindent
The two parentheses before @code{oldbuf} might surprise you if you did
not realize that the first parenthesis before @code{oldbuf} marks the
boundary of the varlist and the second parenthesis marks the beginning
of the two-element list, @code{(oldbuf (current-buffer))}.

@node append save-excursion,  , append-to-buffer body, append-to-buffer
@comment  node-name,  next,  previous,  up
@subsection @code{save-excursion} in @code{append-to-buffer}

The body of the @code{let} expression in @code{append-to-buffer}
consists of a @code{save-excursion} expression.

The @code{save-excursion} function saves the locations of point and
mark, and restores them to those positions after the expressions in the
body of the @code{save-excursion} complete execution.  In addition,
@code{save-excursion} keeps track of the original buffer, and
restores it.  This is how @code{save-excursion} is used in
@code{append-to-buffer}.

@need 1500
@cindex Indentation for formatting
@cindex Formatting convention
Incidentally, it is worth noting here that a Lisp function is normally
formatted so that everything that is enclosed in a multi-line spread is
indented more to the right than the first symbol.  In this function
definition, the @code{let} is indented more than the @code{defun}, and
the @code{save-excursion} is indented more than the @code{let}, like
this:

@smallexample
@group
(defun @dots{}
  @dots{}
  @dots{}
  (let@dots{}
    (save-excursion
      @dots{}
@end group
@end smallexample

@need 1500
@noindent
This formatting convention makes it easy to see that the lines in
the body of the @code{save-excursion} are enclosed by the parentheses
associated with @code{save-excursion}, just as the
@code{save-excursion} itself is enclosed by the parentheses associated
with the @code{let}:

@smallexample
@group
(let ((oldbuf (current-buffer)))
  (save-excursion
    @dots{}
    (set-buffer @dots{})
    (insert-buffer-substring oldbuf start end)
    @dots{}))
@end group
@end smallexample

@need 1200
The use of the @code{save-excursion} function can be viewed as a process
of filling in the slots of a template:

@smallexample
@group
(save-excursion
  @var{first-expression-in-body}
  @var{second-expression-in-body}
   @dots{}
  @var{last-expression-in-body})
@end group
@end smallexample

@need 1200
@noindent
In this function, the body of the @code{save-excursion} contains only
one expression, the @code{let*} expression.  You know about a
@code{let} function.  The @code{let*} function is different.  It has a
@samp{*} in its name.  It enables Emacs to set each variable in its
varlist in sequence, one after another.

Its critical feature is that variables later in the varlist can make
use of the values to which Emacs set variables earlier in the varlist.
@xref{fwd-para let, , The @code{let*} expression}.

We will skip functions like @code{let*} and focus on two: the
@code{set-buffer} function and the @code{insert-buffer-substring}
function.

@need 1250
In the old days, the @code{set-buffer} expression was simply

@smallexample
(set-buffer (get-buffer-create buffer))
@end smallexample

@need 1250
@noindent
but now it is

@smallexample
(set-buffer append-to)
@end smallexample

@noindent
@code{append-to} is bound to @code{(get-buffer-create buffer)} earlier
on in the @code{let*} expression.  That extra binding would not be
necessary except for that @code{append-to} is used later in the
varlist as an argument to @code{get-buffer-window-list}.

@ignore
in GNU Emacs 22

  (let ((oldbuf (current-buffer)))
    (save-excursion
      (let* ((append-to (get-buffer-create buffer))
             (windows (get-buffer-window-list append-to t t))
             point)
        (set-buffer append-to)
        (setq point (point))
        (barf-if-buffer-read-only)
        (insert-buffer-substring oldbuf start end)
        (dolist (window windows)
          (when (= (window-point window) point)
            (set-window-point window (point))))))))
@end ignore

The @code{append-to-buffer} function definition inserts text from the
buffer in which you are currently to a named buffer.  It happens that
@code{insert-buffer-substring} copies text from another buffer to the
current buffer, just the reverse---that is why the
@code{append-to-buffer} definition starts out with a @code{let} that
binds the local symbol @code{oldbuf} to the value returned by
@code{current-buffer}.

@need 1250
The @code{insert-buffer-substring} expression looks like this:

@smallexample
(insert-buffer-substring oldbuf start end)
@end smallexample

@noindent
The @code{insert-buffer-substring} function copies a string
@emph{from} the buffer specified as its first argument and inserts the
string into the present buffer.  In this case, the argument to
@code{insert-buffer-substring} is the value of the variable created
and bound by the @code{let}, namely the value of @code{oldbuf}, which
was the current buffer when you gave the @code{append-to-buffer}
command.

After @code{insert-buffer-substring} has done its work,
@code{save-excursion} will restore the action to the original buffer
and @code{append-to-buffer} will have done its job.

@need 800
Written in skeletal form, the workings of the body look like this:

@smallexample
@group
(let (@var{bind-}@code{oldbuf}@var{-to-value-of-}@code{current-buffer})
  (save-excursion                       ; @r{Keep track of buffer.}
    @var{change-buffer}
    @var{insert-substring-from-}@code{oldbuf}@var{-into-buffer})

  @var{change-back-to-original-buffer-when-finished}
@var{let-the-local-meaning-of-}@code{oldbuf}@var{-disappear-when-finished}
@end group
@end smallexample

In summary, @code{append-to-buffer} works as follows: it saves the
value of the current buffer in the variable called @code{oldbuf}.  It
gets the new buffer (creating one if need be) and switches Emacs'
attention to it.  Using the value of @code{oldbuf}, it inserts the
region of text from the old buffer into the new buffer; and then using
@code{save-excursion}, it brings you back to your original buffer.

In looking at @code{append-to-buffer}, you have explored a fairly
complex function.  It shows how to use @code{let} and
@code{save-excursion}, and how to change to and come back from another
buffer.  Many function definitions use @code{let},
@code{save-excursion}, and @code{set-buffer} this way.


@node Buffer Related Review, Buffer Exercises, append-to-buffer, Buffer Walk Through
@comment  node-name,  next,  previous,  up
@section Review

Here is a brief summary of the various functions discussed in this chapter.

@table @code
@item describe-function
@itemx describe-variable
Print the documentation for a function or variable.
Conventionally bound to @kbd{C-h f} and @kbd{C-h v}.

@item find-tag
Find the file containing the source for a function or variable and
switch buffers to it, positioning point at the beginning of the item.
Conventionally bound to @kbd{M-.} (that's a period following the
@key{META} key).

@item save-excursion
Save the location of point and mark and restore their values after the
arguments to @code{save-excursion} have been evaluated.  Also, remember
the current buffer and return to it.

@item push-mark
Set mark at a location and record the value of the previous mark on the
mark ring.  The mark is a location in the buffer that will keep its
relative position even if text is added to or removed from the buffer.

@item goto-char
Set point to the location specified by the value of the argument, which
can be a number, a marker,  or an expression that returns the number of
a position, such as @code{(point-min)}.

@item insert-buffer-substring
Copy a region of text from a buffer that is passed to the function as
an argument and insert the region into the current buffer.

@item mark-whole-buffer
Mark the whole buffer as a region.  Normally bound to @kbd{C-x h}.

@item set-buffer
Switch the attention of Emacs to another buffer, but do not change the
window being displayed.  Used when the program rather than a human is
to work on a different buffer.

@item get-buffer-create
@itemx get-buffer
Find a named buffer or create one if a buffer of that name does not
exist.  The @code{get-buffer} function returns @code{nil} if the named
buffer does not exist.
@end table


@need 1500
@node Buffer Exercises,  , Buffer Related Review, Buffer Walk Through
@section Exercises

@itemize @bullet
@item
Write your own @code{simplified-end-of-buffer} function definition;
then test it to see whether it works.

@item
Use @code{if} and @code{get-buffer} to write a function that prints a
message telling you whether a buffer exists.

@item
Using @code{find-tag}, find the source for the @code{copy-to-buffer}
function.
@end itemize


@node More Complex, Narrowing & Widening, Buffer Walk Through, Top
@comment  node-name,  next,  previous,  up
@chapter A Few More Complex Functions

In this chapter, we build on what we have learned in previous chapters
by looking at more complex functions.  The @code{copy-to-buffer}
function illustrates use of two @code{save-excursion} expressions in
one definition, while the @code{insert-buffer} function illustrates
use of an asterisk in an @code{interactive} expression, use of
@code{or}, and the important distinction between a name and the object
to which the name refers.

@menu
* copy-to-buffer::              With @code{set-buffer}, @code{get-buffer-create}.
* insert-buffer::               Read-only, and with @code{or}.
* beginning-of-buffer::         Shows @code{goto-char},
                                @code{point-min}, and @code{push-mark}.
* Second Buffer Related Review::
* optional Exercise::
@end menu


@node copy-to-buffer, insert-buffer, More Complex, More Complex
@comment  node-name,  next,  previous,  up
@section The Definition of @code{copy-to-buffer}
@findex copy-to-buffer

After understanding how @code{append-to-buffer} works, it is easy to
understand @code{copy-to-buffer}.  This function copies text into a
buffer, but instead of adding to the second buffer, it replaces all the
previous text in the second buffer.

@need 800
The body of @code{copy-to-buffer} looks like this,

@smallexample
@group
@dots{}
(interactive "BCopy to buffer: \nr")
(let ((oldbuf (current-buffer)))
  (with-current-buffer (get-buffer-create buffer)
    (barf-if-buffer-read-only)
    (erase-buffer)
    (save-excursion
      (insert-buffer-substring oldbuf start end)))))
@end group
@end smallexample

The @code{copy-to-buffer} function has a simpler @code{interactive}
expression than @code{append-to-buffer}.

@need 800
The definition then says

@smallexample
(with-current-buffer (get-buffer-create buffer) @dots{}
@end smallexample

First, look at the earliest inner expression; that is evaluated first.
That expression starts with @code{get-buffer-create buffer}.  The
function tells the computer to use the buffer with the name specified
as the one to which you are copying, or if such a buffer does not
exist, to create it.  Then, the @code{with-current-buffer} function
evaluates its body with that buffer temporarily current.

(This demonstrates another way to shift the computer's attention but
not the user's.  The @code{append-to-buffer} function showed how to do
the same with @code{save-excursion} and @code{set-buffer}.
@code{with-current-buffer} is a newer, and arguably easier,
mechanism.)

The @code{barf-if-buffer-read-only} function sends you an error
message saying the buffer is read-only if you cannot modify it.

The next line has the @code{erase-buffer} function as its sole
contents.  That function erases the buffer.

Finally, the last two lines contain the @code{save-excursion}
expression with @code{insert-buffer-substring} as its body.
The  @code{insert-buffer-substring} expression copies the text from
the buffer you are in (and you have not seen the computer shift its
attention, so you don't know that that buffer is now called
@code{oldbuf}).

Incidentally, this is what is meant by `replacement'.  To replace text,
Emacs erases the previous text and then inserts new text.

@need 1250
In outline, the body of @code{copy-to-buffer} looks like this:

@smallexample
@group
(let (@var{bind-}@code{oldbuf}@var{-to-value-of-}@code{current-buffer})
    (@var{with-the-buffer-you-are-copying-to}
      (@var{but-do-not-erase-or-copy-to-a-read-only-buffer})
      (erase-buffer)
      (save-excursion
        @var{insert-substring-from-}@code{oldbuf}@var{-into-buffer})))
@end group
@end smallexample


@node insert-buffer, beginning-of-buffer, copy-to-buffer, More Complex
@comment  node-name,  next,  previous,  up
@section The Definition of @code{insert-buffer}
@findex insert-buffer

@code{insert-buffer} is yet another buffer-related function.  This
command copies another buffer @emph{into} the current buffer.  It is the
reverse of @code{append-to-buffer} or @code{copy-to-buffer}, since they
copy a region of text @emph{from} the current buffer to another buffer.

Here is a discussion based on the original code.  The code was
simplified in 2003 and is harder to understand.

(@xref{New insert-buffer, , New Body for @code{insert-buffer}}, to see
a discussion of the new body.)

In addition, this code illustrates the use of @code{interactive} with a
buffer that might be @dfn{read-only} and the important distinction
between the name of an object and the object actually referred to.

@menu
* insert-buffer code::
* insert-buffer interactive::   When you can read, but not write.
* insert-buffer body::          The body has an @code{or} and a @code{let}.
* if & or::                     Using an @code{if} instead of an @code{or}.
* Insert or::                   How the @code{or} expression works.
* Insert let::                  Two @code{save-excursion} expressions.
* New insert-buffer::
@end menu

@node insert-buffer code, insert-buffer interactive, insert-buffer, insert-buffer
@ifnottex
@unnumberedsubsec The Code for @code{insert-buffer}
@end ifnottex

@need 800
Here is the earlier code:

@smallexample
@group
(defun insert-buffer (buffer)
  "Insert after point the contents of BUFFER.
Puts mark after the inserted text.
BUFFER may be a buffer or a buffer name."
  (interactive "*bInsert buffer:@: ")
@end group
@group
  (or (bufferp buffer)
      (setq buffer (get-buffer buffer)))
  (let (start end newmark)
    (save-excursion
      (save-excursion
        (set-buffer buffer)
        (setq start (point-min) end (point-max)))
@end group
@group
      (insert-buffer-substring buffer start end)
      (setq newmark (point)))
    (push-mark newmark)))
@end group
@end smallexample

@need 1200
As with other function definitions, you can use a template to see an
outline of the function:

@smallexample
@group
(defun insert-buffer (buffer)
  "@var{documentation}@dots{}"
  (interactive "*bInsert buffer:@: ")
  @var{body}@dots{})
@end group
@end smallexample

@node insert-buffer interactive, insert-buffer body, insert-buffer code, insert-buffer
@comment  node-name,  next,  previous,  up
@subsection The Interactive Expression in @code{insert-buffer}
@findex interactive, @r{example use of}

In @code{insert-buffer}, the argument to the @code{interactive}
declaration has two parts, an asterisk, @samp{*}, and @samp{bInsert
buffer:@: }.

@menu
* Read-only buffer::            When a buffer cannot be modified.
* b for interactive::           An existing buffer or else its name.
@end menu

@node Read-only buffer, b for interactive, insert-buffer interactive, insert-buffer interactive
@comment  node-name,  next,  previous,  up
@unnumberedsubsubsec A Read-only Buffer
@cindex Read-only buffer
@cindex Asterisk for read-only buffer
@findex * @r{for read-only buffer}

The asterisk is for the situation when the current buffer is a
read-only buffer---a buffer that cannot be modified.  If
@code{insert-buffer} is called when the current buffer is read-only, a
message to this effect is printed in the echo area and the terminal
may beep or blink at you; you will not be permitted to insert anything
into current buffer.  The asterisk does not need to be followed by a
newline to separate it from the next argument.

@node b for interactive,  , Read-only buffer, insert-buffer interactive
@comment  node-name,  next,  previous,  up
@unnumberedsubsubsec @samp{b} in an Interactive Expression

The next argument in the interactive expression starts with a lower
case @samp{b}.  (This is different from the code for
@code{append-to-buffer}, which uses an upper-case @samp{B}.
@xref{append-to-buffer, , The Definition of @code{append-to-buffer}}.)
The lower-case @samp{b} tells the Lisp interpreter that the argument
for @code{insert-buffer} should be an existing buffer or else its
name.  (The upper-case @samp{B} option provides for the possibility
that the buffer does not exist.)  Emacs will prompt you for the name
of the buffer, offering you a default buffer, with name completion
enabled.  If the buffer does not exist, you receive a message that
says ``No match''; your terminal may beep at you as well.

The new and simplified code generates a list for @code{interactive}.
It uses the @code{barf-if-buffer-read-only} and @code{read-buffer}
functions with which we are already familiar and the @code{progn}
special form with which we are not.  (It will be described later.)

@node insert-buffer body, if & or, insert-buffer interactive, insert-buffer
@comment  node-name,  next,  previous,  up
@subsection The Body of the @code{insert-buffer} Function

The body of the @code{insert-buffer} function has two major parts: an
@code{or} expression and a @code{let} expression.  The purpose of the
@code{or} expression is to ensure that the argument @code{buffer} is
bound to a buffer and not just the name of a buffer.  The body of the
@code{let} expression contains the code which copies the other buffer
into the current buffer.

@need 1250
In outline, the two expressions fit into the @code{insert-buffer}
function like this:

@smallexample
@group
(defun insert-buffer (buffer)
  "@var{documentation}@dots{}"
  (interactive "*bInsert buffer:@: ")
  (or @dots{}
      @dots{}
@end group
@group
  (let (@var{varlist})
      @var{body-of-}@code{let}@dots{} )
@end group
@end smallexample

To understand how the @code{or} expression ensures that the argument
@code{buffer} is bound to a buffer and not to the name of a buffer, it
is first necessary to understand the @code{or} function.

Before doing this, let me rewrite this part of the function using
@code{if} so that you can see what is done in a manner that will be familiar.

@node if & or, Insert or, insert-buffer body, insert-buffer
@comment  node-name,  next,  previous,  up
@subsection @code{insert-buffer} With an @code{if} Instead of an @code{or}

The job to be done is to make sure the value of @code{buffer} is a
buffer itself and not the name of a buffer.  If the value is the name,
then the buffer itself must be got.

You can imagine yourself at a conference where an usher is wandering
around holding a list with your name on it and looking for you: the
usher is ``bound'' to your name, not to you; but when the usher finds
you and takes your arm, the usher becomes ``bound'' to you.

@need 800
In Lisp, you might describe this situation like this:

@smallexample
@group
(if (not (holding-on-to-guest))
    (find-and-take-arm-of-guest))
@end group
@end smallexample

We want to do the same thing with a buffer---if we do not have the
buffer itself, we want to get it.

@need 1200
Using a predicate called @code{bufferp} that tells us whether we have a
buffer (rather than its name), we can write the code like this:

@smallexample
@group
(if (not (bufferp buffer))              ; @r{if-part}
    (setq buffer (get-buffer buffer)))  ; @r{then-part}
@end group
@end smallexample

@noindent
Here, the true-or-false-test of the @code{if} expression is
@w{@code{(not (bufferp buffer))}}; and the then-part is the expression
@w{@code{(setq buffer (get-buffer buffer))}}.

In the test, the function @code{bufferp} returns true if its argument is
a buffer---but false if its argument is the name of the buffer.  (The
last character of the function name @code{bufferp} is the character
@samp{p}; as we saw earlier, such use of @samp{p} is a convention that
indicates that the function is a predicate, which is a term that means
that the function will determine whether some property is true or false.
@xref{Wrong Type of Argument, , Using the Wrong Type Object as an
Argument}.)

@need 1200
The function @code{not} precedes the expression @code{(bufferp buffer)},
so the true-or-false-test looks like this:

@smallexample
(not (bufferp buffer))
@end smallexample

@noindent
@code{not} is a function that returns true if its argument is false
and false if its argument is true.  So if @code{(bufferp buffer)}
returns true, the @code{not} expression returns false and vice-verse:
what is ``not true'' is false and what is ``not false'' is true.

Using this test, the @code{if} expression works as follows: when the
value of the variable @code{buffer} is actually a buffer rather than
its name, the true-or-false-test returns false and the @code{if}
expression does not evaluate the then-part.  This is fine, since we do
not need to do anything to the variable @code{buffer} if it really is
a buffer.

On the other hand, when the value of @code{buffer} is not a buffer
itself, but the name of a buffer, the true-or-false-test returns true
and the then-part of the expression is evaluated.  In this case, the
then-part is @code{(setq buffer (get-buffer buffer))}.  This
expression uses the @code{get-buffer} function to return an actual
buffer itself, given its name.  The @code{setq} then sets the variable
@code{buffer} to the value of the buffer itself, replacing its previous
value (which was the name of the buffer).

@node Insert or, Insert let, if & or, insert-buffer
@comment  node-name,  next,  previous,  up
@subsection The @code{or} in the Body

The purpose of the @code{or} expression in the @code{insert-buffer}
function is to ensure that the argument @code{buffer} is bound to a
buffer and not just to the name of a buffer.  The previous section shows
how the job could have been done using an @code{if} expression.
However, the @code{insert-buffer} function actually uses @code{or}.
To understand this, it is necessary to understand how @code{or} works.

@findex or
An @code{or} function can have any number of arguments.  It evaluates
each argument in turn and returns the value of the first of its
arguments that is not @code{nil}.  Also, and this is a crucial feature
of @code{or}, it does not evaluate any subsequent arguments after
returning the first non-@code{nil} value.

@need 800
The @code{or} expression looks like this:

@smallexample
@group
(or (bufferp buffer)
    (setq buffer (get-buffer buffer)))
@end group
@end smallexample

@noindent
The first argument to @code{or} is the expression @code{(bufferp buffer)}.
This expression returns true (a non-@code{nil} value) if the buffer is
actually a buffer, and not just the name of a buffer.  In the @code{or}
expression, if this is the case, the @code{or} expression returns this
true value and does not evaluate the next expression---and this is fine
with us, since we do not want to do anything to the value of
@code{buffer} if it really is a buffer.

On the other hand, if the value of @code{(bufferp buffer)} is @code{nil},
which it will be if the value of @code{buffer} is the name of a buffer,
the Lisp interpreter evaluates the next element of the @code{or}
expression.  This is the expression @code{(setq buffer (get-buffer
buffer))}.  This expression returns a non-@code{nil} value, which
is the value to which it sets the variable @code{buffer}---and this
value is a buffer itself, not the name of a buffer.

The result of all this is that the symbol @code{buffer} is always
bound to a buffer itself rather than to the name of a buffer.  All
this is necessary because the @code{set-buffer} function in a
following line only works with a buffer itself, not with the name to a
buffer.

@need 1250
Incidentally, using @code{or}, the situation with the usher would be
written like this:

@smallexample
(or (holding-on-to-guest) (find-and-take-arm-of-guest))
@end smallexample

@node Insert let, New insert-buffer, Insert or, insert-buffer
@comment  node-name,  next,  previous,  up
@subsection The @code{let} Expression in @code{insert-buffer}

After ensuring that the variable @code{buffer} refers to a buffer itself
and not just to the name of a buffer, the @code{insert-buffer function}
continues with a @code{let} expression.  This specifies three local
variables, @code{start}, @code{end}, and @code{newmark} and binds them
to the initial value @code{nil}.  These variables are used inside the
remainder of the @code{let} and temporarily hide any other occurrence of
variables of the same name in Emacs until the end of the @code{let}.

@need 1200
The body of the @code{let} contains two @code{save-excursion}
expressions.  First, we will look at the inner @code{save-excursion}
expression in detail.  The expression looks like this:

@smallexample
@group
(save-excursion
  (set-buffer buffer)
  (setq start (point-min) end (point-max)))
@end group
@end smallexample

@noindent
The expression @code{(set-buffer buffer)} changes Emacs' attention
from the current buffer to the one from which the text will copied.
In that buffer, the variables @code{start} and @code{end} are set to
the beginning and end of the buffer, using the commands
@code{point-min} and @code{point-max}.  Note that we have here an
illustration of how @code{setq} is able to set two variables in the
same expression.  The first argument of @code{setq} is set to the
value of its second, and its third argument is set to the value of its
fourth.

After the body of the inner @code{save-excursion} is evaluated, the
@code{save-excursion} restores the original buffer, but @code{start} and
@code{end} remain set to the values of the beginning and end of the
buffer from which the text will be copied.

@need 1250
The outer @code{save-excursion} expression looks like this:

@smallexample
@group
(save-excursion
  (@var{inner-}@code{save-excursion}@var{-expression}
     (@var{go-to-new-buffer-and-set-}@code{start}@var{-and-}@code{end})
  (insert-buffer-substring buffer start end)
  (setq newmark (point)))
@end group
@end smallexample

@noindent
The @code{insert-buffer-substring} function copies the text
@emph{into} the current buffer @emph{from} the region indicated by
@code{start} and @code{end} in @code{buffer}.  Since the whole of the
second buffer lies between @code{start} and @code{end}, the whole of
the second buffer is copied into the buffer you are editing.  Next,
the value of point, which will be at the end of the inserted text, is
recorded in the variable @code{newmark}.

After the body of the outer @code{save-excursion} is evaluated, point
and mark are relocated to their original places.

However, it is convenient to locate a mark at the end of the newly
inserted text and locate point at its beginning.  The @code{newmark}
variable records the end of the inserted text.  In the last line of
the @code{let} expression, the @code{(push-mark newmark)} expression
function sets a mark to this location.  (The previous location of the
mark is still accessible; it is recorded on the mark ring and you can
go back to it with @kbd{C-u C-@key{SPC}}.)  Meanwhile, point is
located at the beginning of the inserted text, which is where it was
before you called the insert function, the position of which was saved
by the first @code{save-excursion}.

@need 1250
The whole @code{let} expression looks like this:

@smallexample
@group
(let (start end newmark)
  (save-excursion
    (save-excursion
      (set-buffer buffer)
      (setq start (point-min) end (point-max)))
    (insert-buffer-substring buffer start end)
    (setq newmark (point)))
  (push-mark newmark))
@end group
@end smallexample

Like the @code{append-to-buffer} function, the @code{insert-buffer}
function uses @code{let}, @code{save-excursion}, and
@code{set-buffer}.  In addition, the function illustrates one way to
use @code{or}.  All these functions are building blocks that we will
find and use again and again.

@node New insert-buffer,  , Insert let, insert-buffer
@comment  node-name,  next,  previous,  up
@subsection New Body for @code{insert-buffer}
@findex insert-buffer, new version body
@findex new version body for insert-buffer

The body in the GNU Emacs 22 version is more confusing than the original.

@need 1250
It consists of two expressions,

@smallexample
@group
  (push-mark
   (save-excursion
     (insert-buffer-substring (get-buffer buffer))
     (point)))

   nil
@end group
@end smallexample

@noindent
except, and this is what confuses novices, very important work is done
inside the @code{push-mark} expression.

The @code{get-buffer} function returns a buffer with the name
provided.  You will note that the function is @emph{not} called
@code{get-buffer-create}; it does not create a buffer if one does not
already exist.  The buffer returned by @code{get-buffer}, an existing
buffer, is passed to @code{insert-buffer-substring}, which inserts the
whole of the buffer (since you did not specify anything else).

The location into which the buffer is inserted is recorded by
@code{push-mark}.  Then the function returns @code{nil}, the value of
its last command.  Put another way, the @code{insert-buffer} function
exists only to produce a side effect, inserting another buffer, not to
return any value.


@node beginning-of-buffer, Second Buffer Related Review, insert-buffer, More Complex
@comment  node-name,  next,  previous,  up
@section Complete Definition of @code{beginning-of-buffer}
@findex beginning-of-buffer

The basic structure of the @code{beginning-of-buffer} function has
already been discussed.  (@xref{simplified-beginning-of-buffer, , A
Simplified @code{beginning-of-buffer} Definition}.)
This section describes the complex part of the definition.

As previously described, when invoked without an argument,
@code{beginning-of-buffer} moves the cursor to the beginning of the
buffer (in truth, the beginning of the accessible portion of the
buffer), leaving the mark at the previous position.  However, when the
command is invoked with a number between one and ten, the function
considers that number to be a fraction of the length of the buffer,
measured in tenths, and Emacs moves the cursor that fraction of the
way from the beginning of the buffer.  Thus, you can either call this
function with the key command @kbd{M-<}, which will move the cursor to
the beginning of the buffer, or with a key command such as @kbd{C-u 7
M-<} which will move the cursor to a point 70% of the way through the
buffer.  If a number bigger than ten is used for the argument, it
moves to the end of the buffer.

The @code{beginning-of-buffer} function can be called with or without an
argument.  The use of the argument is optional.

@menu
* Optional Arguments::
* beginning-of-buffer opt arg::  Example with optional argument.
* beginning-of-buffer complete::
@end menu

@node Optional Arguments, beginning-of-buffer opt arg, beginning-of-buffer, beginning-of-buffer
@subsection Optional Arguments

Unless told otherwise, Lisp expects that a function with an argument in
its function definition will be called with a value for that argument.
If that does not happen, you get an error and a message that says
@samp{Wrong number of arguments}.

@cindex Optional arguments
@cindex Keyword
@findex optional
However, optional arguments are a feature of Lisp: a particular
@dfn{keyword} is used to tell the Lisp interpreter that an argument is
optional.  The keyword is @code{&optional}.  (The @samp{&} in front of
@samp{optional} is part of the keyword.)  In a function definition, if
an argument follows the keyword @code{&optional}, no value need be
passed to that argument when the function is called.

@need 1200
The first line of the function definition of @code{beginning-of-buffer}
therefore looks like this:

@smallexample
(defun beginning-of-buffer (&optional arg)
@end smallexample

@need 1250
In outline, the whole function looks like this:

@smallexample
@group
(defun beginning-of-buffer (&optional arg)
  "@var{documentation}@dots{}"
  (interactive "P")
  (or (@var{is-the-argument-a-cons-cell} arg)
      (and @var{are-both-transient-mark-mode-and-mark-active-true})
      (push-mark))
  (let (@var{determine-size-and-set-it})
  (goto-char
    (@var{if-there-is-an-argument}
        @var{figure-out-where-to-go}
      @var{else-go-to}
      (point-min))))
   @var{do-nicety}
@end group
@end smallexample

The function is similar to the @code{simplified-beginning-of-buffer}
function except that the @code{interactive} expression has @code{"P"}
as an argument and the @code{goto-char} function is followed by an
if-then-else expression that figures out where to put the cursor if
there is an argument that is not a cons cell.

(Since I do not explain a cons cell for many more chapters, please
consider ignoring the function @code{consp}.  @xref{List
Implementation, , How Lists are Implemented}, and @ref{Cons Cell Type,
, Cons Cell and List Types, elisp, The GNU Emacs Lisp Reference
Manual}.)

The @code{"P"} in the @code{interactive} expression tells Emacs to
pass a prefix argument, if there is one, to the function in raw form.
A prefix argument is made by typing the @key{META} key followed by a
number, or by typing @kbd{C-u} and then a number.  (If you don't type
a number, @kbd{C-u} defaults to a cons cell with a 4.  A lowercase
@code{"p"} in the @code{interactive} expression causes the function to
convert a prefix arg to a number.)

The true-or-false-test of the @code{if} expression looks complex, but
it is not: it checks whether @code{arg} has a value that is not
@code{nil} and whether it is a cons cell.  (That is what @code{consp}
does; it checks whether its argument is a cons cell.)  If @code{arg}
has a value that is not @code{nil} (and is not a cons cell), which
will be the case if @code{beginning-of-buffer} is called with a
numeric argument, then this true-or-false-test will return true and
the then-part of the @code{if} expression will be evaluated.  On the
other hand, if @code{beginning-of-buffer} is not called with an
argument, the value of @code{arg} will be @code{nil} and the else-part
of the @code{if} expression will be evaluated.  The else-part is
simply @code{point-min}, and when this is the outcome, the whole
@code{goto-char} expression is @code{(goto-char (point-min))}, which
is how we saw the @code{beginning-of-buffer} function in its
simplified form.

@node beginning-of-buffer opt arg, beginning-of-buffer complete, Optional Arguments, beginning-of-buffer
@subsection @code{beginning-of-buffer} with an Argument

When @code{beginning-of-buffer} is called with an argument, an
expression is evaluated which calculates what value to pass to
@code{goto-char}.  This expression is rather complicated at first sight.
It includes an inner @code{if} expression and much arithmetic.  It looks
like this:

@smallexample
@group
(if (> (buffer-size) 10000)
    ;; @r{Avoid overflow for large buffer sizes!}
                          (* (prefix-numeric-value arg)
                             (/ size 10))
  (/
   (+ 10
      (*
       size (prefix-numeric-value arg))) 10)))
@end group
@end smallexample

@menu
* Disentangle beginning-of-buffer::
* Large buffer case::
* Small buffer case::
@end menu

@node Disentangle beginning-of-buffer, Large buffer case, beginning-of-buffer opt arg, beginning-of-buffer opt arg
@ifnottex
@unnumberedsubsubsec Disentangle @code{beginning-of-buffer}
@end ifnottex

Like other complex-looking expressions, the conditional expression
within @code{beginning-of-buffer} can be disentangled by looking at it
as parts of a template, in this case, the template for an if-then-else
expression.  In skeletal form, the expression looks like this:

@smallexample
@group
(if (@var{buffer-is-large}
    @var{divide-buffer-size-by-10-and-multiply-by-arg}
  @var{else-use-alternate-calculation}
@end group
@end smallexample

The true-or-false-test of this inner @code{if} expression checks the
size of the buffer.  The reason for this is that the old version 18
Emacs used numbers that are no bigger than eight million or so and in
the computation that followed, the programmer feared that Emacs might
try to use over-large numbers if the buffer were large.  The term
`overflow', mentioned in the comment, means numbers that are over
large.  More recent versions of Emacs use larger numbers, but this
code has not been touched, if only because people now look at buffers
that are far, far larger than ever before.

There are two cases:  if the buffer is large and if it is not.

@node Large buffer case, Small buffer case, Disentangle beginning-of-buffer, beginning-of-buffer opt arg
@comment  node-name,  next,  previous,  up
@unnumberedsubsubsec What happens in a large buffer

In @code{beginning-of-buffer}, the inner @code{if} expression tests
whether the size of the buffer is greater than 10,000 characters.  To do
this, it uses the @code{>} function and the computation of @code{size}
that comes from the let expression.

In the old days, the function @code{buffer-size} was used.  Not only
was that function called several times, it gave the size of the whole
buffer, not the accessible part.  The computation makes much more
sense when it handles just the accessible part.  (@xref{Narrowing &
Widening, , Narrowing and Widening}, for more information on focusing
attention to an `accessible' part.)

@need 800
The line looks like this:

@smallexample
(if (> size 10000)
@end smallexample

@need 1200
@noindent
When the buffer is large, the then-part of the @code{if} expression is
evaluated.  It reads like this (after formatting for easy reading):

@smallexample
@group
(*
  (prefix-numeric-value arg)
  (/ size 10))
@end group
@end smallexample

@noindent
This expression is a multiplication, with two arguments to the function
@code{*}.

The first argument is @code{(prefix-numeric-value arg)}.  When
@code{"P"} is used as the argument for @code{interactive}, the value
passed to the function as its argument is passed a ``raw prefix
argument'', and not a number.  (It is a number in a list.)  To perform
the arithmetic, a conversion is necessary, and
@code{prefix-numeric-value} does the job.

@findex / @r{(division)}
@cindex Division
The second argument is @code{(/ size 10)}.  This expression divides
the numeric value by ten --- the numeric value of the size of the
accessible portion of the buffer.  This produces a number that tells
how many characters make up one tenth of the buffer size.  (In Lisp,
@code{/} is used for division, just as @code{*} is used for
multiplication.)

@need 1200
In the multiplication expression as a whole, this amount is multiplied
by the value of the prefix argument---the multiplication looks like this:

@smallexample
@group
(* @var{numeric-value-of-prefix-arg}
   @var{number-of-characters-in-one-tenth-of-the-accessible-buffer})
@end group
@end smallexample

@noindent
If, for example, the prefix argument is @samp{7}, the one-tenth value
will be multiplied by 7 to give a position 70% of the way through.

@need 1200
The result of all this is that if the accessible portion of the buffer
is large, the @code{goto-char} expression reads like this:

@smallexample
@group
(goto-char (* (prefix-numeric-value arg)
              (/ size 10)))
@end group
@end smallexample

This puts the cursor where we want it.

@node Small buffer case,  , Large buffer case, beginning-of-buffer opt arg
@comment  node-name,  next,  previous,  up
@unnumberedsubsubsec What happens in a small buffer

If the buffer contains fewer than 10,000 characters, a slightly
different computation is performed.  You might think this is not
necessary, since the first computation could do the job.  However, in
a small buffer, the first method may not put the cursor on exactly the
desired line; the second method does a better job.

@need 800
The code looks like this:

@c Keep this on one line.
@smallexample
(/ (+ 10 (* size (prefix-numeric-value arg))) 10))
@end smallexample

@need 1200
@noindent
This is code in which you figure out what happens by discovering how the
functions are embedded in parentheses.  It is easier to read if you
reformat it with each expression indented more deeply than its
enclosing expression:

@smallexample
@group
  (/
   (+ 10
      (*
       size
       (prefix-numeric-value arg)))
   10))
@end group
@end smallexample

@need 1200
@noindent
Looking at parentheses, we see that the innermost operation is
@code{(prefix-numeric-value arg)}, which converts the raw argument to
a number.  In the following expression, this number is multiplied by
the size of the accessible portion of the buffer:

@smallexample
(* size (prefix-numeric-value arg))
@end smallexample

@noindent
This multiplication creates a number that may be larger than the size of
the buffer---seven times larger if the argument is 7, for example.  Ten
is then added to this number and finally the large number is divided by
ten to provide a value that is one character larger than the percentage
position in the buffer.

The number that results from all this is passed to @code{goto-char} and
the cursor is moved to that point.

@need 1500
@node beginning-of-buffer complete,  , beginning-of-buffer opt arg, beginning-of-buffer
@comment  node-name,  next,  previous,  up
@subsection The Complete @code{beginning-of-buffer}

@need 1000
Here is the complete text of the @code{beginning-of-buffer} function:
@sp 1

@c In GNU Emacs 22
@smallexample
@group
(defun beginning-of-buffer (&optional arg)
  "Move point to the beginning of the buffer;
leave mark at previous position.
With \\[universal-argument] prefix,
do not set mark at previous position.
With numeric arg N,
put point N/10 of the way from the beginning.

If the buffer is narrowed,
this command uses the beginning and size
of the accessible part of the buffer.
@end group

@group
Don't use this command in Lisp programs!
\(goto-char (point-min)) is faster
and avoids clobbering the mark."
  (interactive "P")
  (or (consp arg)
      (and transient-mark-mode mark-active)
      (push-mark))
@end group
@group
  (let ((size (- (point-max) (point-min))))
    (goto-char (if (and arg (not (consp arg)))
                   (+ (point-min)
                      (if (> size 10000)
                          ;; Avoid overflow for large buffer sizes!
                          (* (prefix-numeric-value arg)
                             (/ size 10))
                        (/ (+ 10 (* size (prefix-numeric-value arg)))
                           10)))
                 (point-min))))
  (if arg (forward-line 1)))
@end group
@end smallexample

@ignore
From before GNU Emacs 22
@smallexample
@group
(defun beginning-of-buffer (&optional arg)
  "Move point to the beginning of the buffer;
leave mark at previous position.
With arg N, put point N/10 of the way
from the true beginning.
@end group
@group
Don't use this in Lisp programs!
\(goto-char (point-min)) is faster
and does not set the mark."
  (interactive "P")
  (push-mark)
@end group
@group
  (goto-char
   (if arg
       (if (> (buffer-size) 10000)
           ;; @r{Avoid overflow for large buffer sizes!}
           (* (prefix-numeric-value arg)
              (/ (buffer-size) 10))
@end group
@group
         (/ (+ 10 (* (buffer-size)
                     (prefix-numeric-value arg)))
            10))
     (point-min)))
  (if arg (forward-line 1)))
@end group
@end smallexample
@end ignore

@noindent
Except for two small points, the previous discussion shows how this
function works.  The first point deals with a detail in the
documentation string, and the second point concerns the last line of
the function.

@need 800
In the documentation string, there is reference to an expression:

@smallexample
\\[universal-argument]
@end smallexample

@noindent
A @samp{\\} is used before the first square bracket of this
expression.  This @samp{\\} tells the Lisp interpreter to substitute
whatever key is currently bound to the @samp{[@dots{}]}.  In the case
of @code{universal-argument}, that is usually @kbd{C-u}, but it might
be different.  (@xref{Documentation Tips, , Tips for Documentation
Strings, elisp, The GNU Emacs Lisp Reference Manual}, for more
information.)

@need 1200
Finally, the last line of the @code{beginning-of-buffer} command says
to move point to the beginning of the next line if the command is
invoked with an argument:

@smallexample
(if arg (forward-line 1)))
@end smallexample

@noindent
This puts the cursor at the beginning of the first line after the
appropriate tenths position in the buffer.  This is a flourish that
means that the cursor is always located @emph{at least} the requested
tenths of the way through the buffer, which is a nicety that is,
perhaps, not necessary, but which, if it did not occur, would be sure
to draw complaints.

On the other hand, it also means that if you specify the command with
a @kbd{C-u}, but without a number, that is to say, if the `raw prefix
argument' is simply a cons cell, then the command puts you at the
beginning of the second line @dots{}  I don't know whether this is
intended or whether no one has dealt with the code to avoid this
happening.


@node Second Buffer Related Review, optional Exercise, beginning-of-buffer, More Complex
@comment  node-name,  next,  previous,  up
@section Review

Here is a brief summary of some of the topics covered in this chapter.

@table @code
@item or
Evaluate each argument in sequence, and return the value of the first
argument that is not @code{nil}; if none return a value that is not
@code{nil}, return @code{nil}.  In brief, return the first true value
of the arguments; return a true value if one @emph{or} any of the
others are true.

@item and
Evaluate each argument in sequence, and if any are @code{nil}, return
@code{nil}; if none are @code{nil}, return the value of the last
argument.  In brief, return a true value only if all the arguments are
true; return a true value if one @emph{and} each of the others is
true.

@item &optional
A keyword used to indicate that an argument to a function definition
is optional; this means that the function can be evaluated without the
argument, if desired.

@item prefix-numeric-value
Convert the `raw prefix argument' produced by @code{(interactive
"P")} to a numeric value.

@item forward-line
Move point forward to the beginning of the next line, or if the argument
is greater than one, forward that many lines.  If it can't move as far
forward as it is supposed to, @code{forward-line} goes forward as far as
it can and then returns a count of the number of additional lines it was
supposed to move but couldn't.

@item erase-buffer
Delete the entire contents of the current buffer.

@item bufferp
Return @code{t} if its argument is a buffer; otherwise return @code{nil}.
@end table


@node optional Exercise,  , Second Buffer Related Review, More Complex
@section @code{optional} Argument Exercise

Write an interactive function with an optional argument that tests
whether its argument, a number, is greater than or equal to, or else,
less than the value of @code{fill-column}, and tells you which, in a
message.  However, if you do not pass an argument to the function, use
56 as a default value.


@node Narrowing & Widening, car cdr & cons, More Complex, Top
@comment  node-name,  next,  previous,  up
@chapter Narrowing and Widening
@cindex Focusing attention (narrowing)
@cindex Narrowing
@cindex Widening

Narrowing is a feature of Emacs that makes it possible for you to focus
on a specific part of a buffer, and work without accidentally changing
other parts.  Narrowing is normally disabled since it can confuse
novices.

@menu
* Narrowing advantages::        The advantages of narrowing
* save-restriction::            The @code{save-restriction} special form.
* what-line::                   The number of the line that point is on.
* narrow Exercise::
@end menu

@node Narrowing advantages, save-restriction, Narrowing & Widening, Narrowing & Widening
@ifnottex
@unnumberedsec The Advantages of Narrowing
@end ifnottex

With narrowing, the rest of a buffer is made invisible, as if it weren't
there.  This is an advantage if, for example, you want to replace a word
in one part of a buffer but not in another: you narrow to the part you want
and the replacement is carried out only in that section, not in the rest
of the buffer.  Searches will only work within a narrowed region, not
outside of one, so if you are fixing a part of a document, you can keep
yourself from accidentally finding parts you do not need to fix by
narrowing just to the region you want.
(The key binding for @code{narrow-to-region} is @kbd{C-x n n}.)

However, narrowing does make the rest of the buffer invisible, which
can scare people who inadvertently invoke narrowing and think they
have deleted a part of their file.  Moreover, the @code{undo} command
(which is usually bound to @kbd{C-x u}) does not turn off narrowing
(nor should it), so people can become quite desperate if they do not
know that they can return the rest of a buffer to visibility with the
@code{widen} command.
(The key binding for @code{widen} is @kbd{C-x n w}.)

Narrowing is just as useful to the Lisp interpreter as to a human.
Often, an Emacs Lisp function is designed to work on just part of a
buffer; or conversely, an Emacs Lisp function needs to work on all of a
buffer that has been narrowed.  The @code{what-line} function, for
example, removes the narrowing from a buffer, if it has any narrowing
and when it has finished its job, restores the narrowing to what it was.
On the other hand, the @code{count-lines} function, which is called by
@code{what-line}, uses narrowing to restrict itself to just that portion
of the buffer in which it is interested and then restores the previous
situation.


@node save-restriction, what-line, Narrowing advantages, Narrowing & Widening
@comment  node-name,  next,  previous,  up
@section The @code{save-restriction} Special Form
@findex save-restriction

In Emacs Lisp, you can use the @code{save-restriction} special form to
keep track of whatever narrowing is in effect, if any.  When the Lisp
interpreter meets with @code{save-restriction}, it executes the code
in the body of the @code{save-restriction} expression, and then undoes
any changes to narrowing that the code caused.  If, for example, the
buffer is narrowed and the code that follows @code{save-restriction}
gets rid of the narrowing, @code{save-restriction} returns the buffer
to its narrowed region afterwards.  In the @code{what-line} command,
any narrowing the buffer may have is undone by the @code{widen}
command that immediately follows the @code{save-restriction} command.
Any original narrowing is restored just before the completion of the
function.

@need 1250
The template for a @code{save-restriction} expression is simple:

@smallexample
@group
(save-restriction
  @var{body}@dots{} )
@end group
@end smallexample

@noindent
The body of the @code{save-restriction} is one or more expressions that
will be evaluated in sequence by the Lisp interpreter.

Finally, a point to note: when you use both @code{save-excursion} and
@code{save-restriction}, one right after the other, you should use
@code{save-excursion} outermost.  If you write them in reverse order,
you may fail to record narrowing in the buffer to which Emacs switches
after calling @code{save-excursion}.  Thus, when written together,
@code{save-excursion} and @code{save-restriction} should be written
like this:

@smallexample
@group
(save-excursion
  (save-restriction
    @var{body}@dots{}))
@end group
@end smallexample

In other circumstances, when not written together, the
@code{save-excursion} and @code{save-restriction} special forms must
be written in the order appropriate to the function.

@need 1250
For example,

@smallexample
@group
  (save-restriction
    (widen)
    (save-excursion
    @var{body}@dots{}))
@end group
@end smallexample

@ignore
Emacs 22
/usr/local/src/emacs/lisp/simple.el

(defun what-line ()
  "Print the current buffer line number and narrowed line number of point."
  (interactive)
  (let ((start (point-min))
        (n (line-number-at-pos)))
    (if (= start 1)
        (message "Line %d" n)
      (save-excursion
        (save-restriction
          (widen)
          (message "line %d (narrowed line %d)"
                   (+ n (line-number-at-pos start) -1) n))))))

(defun line-number-at-pos (&optional pos)
  "Return (narrowed) buffer line number at position POS.
If POS is nil, use current buffer location.
Counting starts at (point-min), so the value refers
to the contents of the accessible portion of the buffer."
  (let ((opoint (or pos (point))) start)
    (save-excursion
      (goto-char (point-min))
      (setq start (point))
      (goto-char opoint)
      (forward-line 0)
      (1+ (count-lines start (point))))))

(defun count-lines (start end)
  "Return number of lines between START and END.
This is usually the number of newlines between them,
but can be one more if START is not equal to END
and the greater of them is not at the start of a line."
  (save-excursion
    (save-restriction
      (narrow-to-region start end)
      (goto-char (point-min))
      (if (eq selective-display t)
          (save-match-data
            (let ((done 0))
              (while (re-search-forward "[\n\C-m]" nil t 40)
                (setq done (+ 40 done)))
              (while (re-search-forward "[\n\C-m]" nil t 1)
                (setq done (+ 1 done)))
              (goto-char (point-max))
              (if (and (/= start end)
                       (not (bolp)))
                  (1+ done)
                done)))
        (- (buffer-size) (forward-line (buffer-size)))))))
@end ignore


@node what-line, narrow Exercise, save-restriction, Narrowing & Widening
@comment  node-name,  next,  previous,  up
@section @code{what-line}
@findex what-line
@cindex Widening, example of

The @code{what-line} command tells you the number of the line in which
the cursor is located.  The function illustrates the use of the
@code{save-restriction} and @code{save-excursion} commands.  Here is the
original text of the function:

@smallexample
@group
(defun what-line ()
  "Print the current line number (in the buffer) of point."
  (interactive)
  (save-restriction
    (widen)
    (save-excursion
      (beginning-of-line)
      (message "Line %d"
               (1+ (count-lines 1 (point)))))))
@end group
@end smallexample

(In recent versions of GNU Emacs, the @code{what-line} function has
been expanded to tell you your line number in a narrowed buffer as
well as your line number in a widened buffer.  The recent version is
more complex than the version shown here.  If you feel adventurous,
you might want to look at it after figuring out how this version
works.  You will probably need to use @kbd{C-h f}
(@code{describe-function}).  The newer version uses a conditional to
determine whether the buffer has been narrowed.

(Also, it uses @code{line-number-at-pos}, which among other simple
expressions, such as @code{(goto-char (point-min))}, moves point to
the beginning of the current line with @code{(forward-line 0)} rather
than @code{beginning-of-line}.)

The @code{what-line} function as shown here has a documentation line
and is interactive, as you would expect.  The next two lines use the
functions @code{save-restriction} and @code{widen}.

The @code{save-restriction} special form notes whatever narrowing is in
effect, if any, in the current buffer and restores that narrowing after
the code in the body of the @code{save-restriction} has been evaluated.

The @code{save-restriction} special form is followed by @code{widen}.
This function undoes any narrowing the current buffer may have had
when @code{what-line} was called.  (The narrowing that was there is
the narrowing that @code{save-restriction} remembers.)  This widening
makes it possible for the line counting commands to count from the
beginning of the buffer.  Otherwise, they would have been limited to
counting within the accessible region.  Any original narrowing is
restored just before the completion of the function by the
@code{save-restriction} special form.

The call to @code{widen} is followed by @code{save-excursion}, which
saves the location of the cursor (i.e., of point) and of the mark, and
restores them after the code in the body of the @code{save-excursion}
uses the @code{beginning-of-line} function to move point.

(Note that the @code{(widen)} expression comes between the
@code{save-restriction} and @code{save-excursion} special forms.  When
you write the two @code{save- @dots{}} expressions in sequence, write
@code{save-excursion} outermost.)

@need 1200
The last two lines of the @code{what-line} function are functions to
count the number of lines in the buffer and then print the number in the
echo area.

@smallexample
@group
(message "Line %d"
         (1+ (count-lines 1 (point)))))))
@end group
@end smallexample

The @code{message} function prints a one-line message at the bottom of
the Emacs screen.  The first argument is inside of quotation marks and
is printed as a string of characters.  However, it may contain a
@samp{%d} expression to print a following argument.  @samp{%d} prints
the argument as a decimal, so the message will say something such as
@samp{Line 243}.

@need 1200
The number that is printed in place of the @samp{%d} is computed by the
last line of the function:

@smallexample
(1+ (count-lines 1 (point)))
@end smallexample

@ignore
GNU Emacs 22

(defun count-lines (start end)
  "Return number of lines between START and END.
This is usually the number of newlines between them,
but can be one more if START is not equal to END
and the greater of them is not at the start of a line."
  (save-excursion
    (save-restriction
      (narrow-to-region start end)
      (goto-char (point-min))
      (if (eq selective-display t)
          (save-match-data
            (let ((done 0))
              (while (re-search-forward "[\n\C-m]" nil t 40)
                (setq done (+ 40 done)))
              (while (re-search-forward "[\n\C-m]" nil t 1)
                (setq done (+ 1 done)))
              (goto-char (point-max))
              (if (and (/= start end)
                       (not (bolp)))
                  (1+ done)
                done)))
        (- (buffer-size) (forward-line (buffer-size)))))))
@end ignore

@noindent
What this does is count the lines from the first position of the
buffer, indicated by the @code{1}, up to @code{(point)}, and then add
one to that number.  (The @code{1+} function adds one to its
argument.)  We add one to it because line 2 has only one line before
it, and @code{count-lines} counts only the lines @emph{before} the
current line.

After @code{count-lines} has done its job, and the message has been
printed in the echo area, the @code{save-excursion} restores point and
mark to their original positions; and @code{save-restriction} restores
the original narrowing, if any.


@node narrow Exercise,  , what-line, Narrowing & Widening
@section Exercise with Narrowing

Write a function that will display the first 60 characters of the
current buffer, even if you have narrowed the buffer to its latter
half so that the first line is inaccessible.  Restore point, mark, and
narrowing.  For this exercise, you need to use a whole potpourri of
functions, including @code{save-restriction}, @code{widen},
@code{goto-char}, @code{point-min}, @code{message}, and
@code{buffer-substring}.

@cindex Properties, mention of @code{buffer-substring-no-properties}
(@code{buffer-substring} is a previously unmentioned function you will
have to investigate yourself; or perhaps you will have to use
@code{buffer-substring-no-properties} or
@code{filter-buffer-substring} @dots{}, yet other functions.  Text
properties are a feature otherwise not discussed here.  @xref{Text
Properties, , Text Properties, elisp, The GNU Emacs Lisp Reference
Manual}.)

Additionally, do you really need @code{goto-char} or @code{point-min}?
Or can you write the function without them?


@node car cdr & cons, Cutting & Storing Text, Narrowing & Widening, Top
@comment  node-name,  next,  previous,  up
@chapter @code{car}, @code{cdr}, @code{cons}: Fundamental Functions
@findex car, @r{introduced}
@findex cdr, @r{introduced}

In Lisp, @code{car}, @code{cdr}, and @code{cons} are fundamental
functions.  The @code{cons} function is used to construct lists, and
the @code{car} and @code{cdr} functions are used to take them apart.

In the walk through of the @code{copy-region-as-kill} function, we
will see @code{cons} as well as two variants on @code{cdr},
namely, @code{setcdr} and @code{nthcdr}.  (@xref{copy-region-as-kill}.)

@menu
* Strange Names::               An historical aside: why the strange names?
* car & cdr::                   Functions for extracting part of a list.
* cons::                        Constructing a list.
* nthcdr::                      Calling @code{cdr} repeatedly.
* nth::
* setcar::                      Changing the first element of a list.
* setcdr::                      Changing the rest of a list.
* cons Exercise::
@end menu

@node Strange Names, car & cdr, car cdr & cons, car cdr & cons
@ifnottex
@unnumberedsec Strange Names
@end ifnottex

The name of the @code{cons} function is not unreasonable: it is an
abbreviation of the word `construct'.  The origins of the names for
@code{car} and @code{cdr}, on the other hand, are esoteric: @code{car}
is an acronym from the phrase `Contents of the Address part of the
Register'; and @code{cdr} (pronounced `could-er') is an acronym from
the phrase `Contents of the Decrement part of the Register'.  These
phrases refer to specific pieces of hardware on the very early
computer on which the original Lisp was developed.  Besides being
obsolete, the phrases have been completely irrelevant for more than 25
years to anyone thinking about Lisp.  Nonetheless, although a few
brave scholars have begun to use more reasonable names for these
functions, the old terms are still in use.  In particular, since the
terms are used in the Emacs Lisp source code, we will use them in this
introduction.


@node car & cdr, cons, Strange Names, car cdr & cons
@comment  node-name,  next,  previous,  up
@section @code{car} and @code{cdr}

The @sc{car} of a list is, quite simply, the first item in the list.
Thus the @sc{car} of the list @code{(rose violet daisy buttercup)} is
@code{rose}.

@need 1200
If you are reading this in Info in GNU Emacs, you can see this by
evaluating the following:

@smallexample
(car '(rose violet daisy buttercup))
@end smallexample

@noindent
After evaluating the expression, @code{rose} will appear in the echo
area.

Clearly, a more reasonable name for the @code{car} function would be
@code{first} and this is often suggested.

@code{car} does not remove the first item from the list; it only reports
what it is.  After @code{car} has been applied to a list, the list is
still the same as it was.  In the jargon, @code{car} is
`non-destructive'.  This feature turns out to be important.

The @sc{cdr} of a list is the rest of the list, that is, the
@code{cdr} function returns the part of the list that follows the
first item.  Thus, while the @sc{car} of the list @code{'(rose violet
daisy buttercup)} is @code{rose}, the rest of the list, the value
returned by the @code{cdr} function, is @code{(violet daisy
buttercup)}.

@need 800
You can see this by evaluating the following in the usual way:

@smallexample
(cdr '(rose violet daisy buttercup))
@end smallexample

@noindent
When you evaluate this, @code{(violet daisy buttercup)} will appear in
the echo area.

Like @code{car}, @code{cdr} does not remove any elements from the
list---it just returns a report of what the second and subsequent
elements are.

Incidentally, in the example, the list of flowers is quoted.  If it were
not, the Lisp interpreter would try to evaluate the list by calling
@code{rose} as a function.  In this example, we do not want to do that.

Clearly, a more reasonable name for @code{cdr} would be @code{rest}.

(There is a lesson here: when you name new functions, consider very
carefully what you are doing, since you may be stuck with the names
for far longer than you expect.  The reason this document perpetuates
these names is that the Emacs Lisp source code uses them, and if I did
not use them, you would have a hard time reading the code; but do,
please, try to avoid using these terms yourself.  The people who come
after you will be grateful to you.)

When @code{car} and @code{cdr} are applied to a list made up of symbols,
such as the list @code{(pine fir oak maple)}, the element of the list
returned by the function @code{car} is the symbol @code{pine} without
any parentheses around it.  @code{pine} is the first element in the
list.  However, the @sc{cdr} of the list is a list itself, @code{(fir
oak maple)}, as you can see by evaluating the following expressions in
the usual way:

@smallexample
@group
(car '(pine fir oak maple))

(cdr '(pine fir oak maple))
@end group
@end smallexample

On the other hand, in a list of lists, the first element is itself a
list.  @code{car} returns this first element as a list.  For example,
the following list contains three sub-lists, a list of carnivores, a
list of herbivores and a list of sea mammals:

@smallexample
@group
(car '((lion tiger cheetah)
       (gazelle antelope zebra)
       (whale dolphin seal)))
@end group
@end smallexample

@noindent
In this example, the first element or @sc{car} of the list is the list of
carnivores, @code{(lion tiger cheetah)}, and the rest of the list is
@code{((gazelle antelope zebra) (whale dolphin seal))}.

@smallexample
@group
(cdr '((lion tiger cheetah)
       (gazelle antelope zebra)
       (whale dolphin seal)))
@end group
@end smallexample

It is worth saying again that @code{car} and @code{cdr} are
non-destructive---that is, they do not modify or change lists to which
they are applied.  This is very important for how they are used.

Also, in the first chapter, in the discussion about atoms, I said that
in Lisp, ``certain kinds of atom, such as an array, can be separated
into parts; but the mechanism for doing this is different from the
mechanism for splitting a list.  As far as Lisp is concerned, the
atoms of a list are unsplittable.''  (@xref{Lisp Atoms}.)  The
@code{car} and @code{cdr} functions are used for splitting lists and
are considered fundamental to Lisp.  Since they cannot split or gain
access to the parts of an array, an array is considered an atom.
Conversely, the other fundamental function, @code{cons}, can put
together or construct a list, but not an array.  (Arrays are handled
by array-specific functions.  @xref{Arrays, , Arrays, elisp, The GNU
Emacs Lisp Reference Manual}.)


@node cons, nthcdr, car & cdr, car cdr & cons
@comment  node-name,  next,  previous,  up
@section @code{cons}
@findex cons, @r{introduced}

The @code{cons} function constructs lists; it is the inverse of
@code{car} and @code{cdr}.  For example, @code{cons} can be used to make
a four element list from the three element list, @code{(fir oak maple)}:

@smallexample
(cons 'pine '(fir oak maple))
@end smallexample

@need 800
@noindent
After evaluating this list, you will see

@smallexample
(pine fir oak maple)
@end smallexample

@noindent
appear in the echo area.  @code{cons} causes the creation of a new
list in which the element is followed by the elements of the original
list.

We often say that `@code{cons} puts a new element at the beginning of
a list; it attaches or pushes elements onto the list', but this
phrasing can be misleading, since @code{cons} does not change an
existing list, but creates a new one.

Like @code{car} and @code{cdr}, @code{cons} is non-destructive.

@menu
* Build a list::
* length::                      How to find the length of a list.
@end menu

@node Build a list, length, cons, cons
@ifnottex
@unnumberedsubsec Build a list
@end ifnottex

@code{cons} must have a list to attach to.@footnote{Actually, you can
@code{cons} an element to an atom to produce a dotted pair.  Dotted
pairs are not discussed here; see @ref{Dotted Pair Notation, , Dotted
Pair Notation, elisp, The GNU Emacs Lisp Reference Manual}.}  You
cannot start from absolutely nothing.  If you are building a list, you
need to provide at least an empty list at the beginning.  Here is a
series of @code{cons} expressions that build up a list of flowers.  If
you are reading this in Info in GNU Emacs, you can evaluate each of
the expressions in the usual way; the value is printed in this text
after @samp{@result{}}, which you may read as `evaluates to'.

@smallexample
@group
(cons 'buttercup ())
     @result{} (buttercup)
@end group

@group
(cons 'daisy '(buttercup))
     @result{} (daisy buttercup)
@end group

@group
(cons 'violet '(daisy buttercup))
     @result{} (violet daisy buttercup)
@end group

@group
(cons 'rose '(violet daisy buttercup))
     @result{} (rose violet daisy buttercup)
@end group
@end smallexample

@noindent
In the first example, the empty list is shown as @code{()} and a list
made up of @code{buttercup} followed by the empty list is constructed.
As you can see, the empty list is not shown in the list that was
constructed.  All that you see is @code{(buttercup)}.  The empty list is
not counted as an element of a list because there is nothing in an empty
list.  Generally speaking, an empty list is invisible.

The second example, @code{(cons 'daisy '(buttercup))} constructs a new,
two element list by putting @code{daisy} in front of @code{buttercup};
and the third example constructs a three element list by putting
@code{violet} in front of @code{daisy} and @code{buttercup}.

@node length,  , Build a list, cons
@comment  node-name,  next,  previous,  up
@subsection Find the Length of a List: @code{length}
@findex length

You can find out how many elements there are in a list by using the Lisp
function @code{length}, as in the following examples:

@smallexample
@group
(length '(buttercup))
     @result{} 1
@end group

@group
(length '(daisy buttercup))
     @result{} 2
@end group

@group
(length (cons 'violet '(daisy buttercup)))
     @result{} 3
@end group
@end smallexample

@noindent
In the third example, the @code{cons} function is used to construct a
three element list which is then passed to the @code{length} function as
its argument.

@need 1200
We can also use @code{length} to count the number of elements in an
empty list:

@smallexample
@group
(length ())
     @result{} 0
@end group
@end smallexample

@noindent
As you would expect, the number of elements in an empty list is zero.

An interesting experiment is to find out what happens if you try to find
the length of no list at all; that is, if you try to call @code{length}
without giving it an argument, not even an empty list:

@smallexample
(length )
@end smallexample

@need 800
@noindent
What you see, if you evaluate this, is the error message

@smallexample
Lisp error: (wrong-number-of-arguments length 0)
@end smallexample

@noindent
This means that the function receives the wrong number of
arguments, zero, when it expects some other number of arguments.  In
this case, one argument is expected, the argument being a list whose
length the function is measuring.  (Note that @emph{one} list is
@emph{one} argument, even if the list has many elements inside it.)

The part of the error message that says @samp{length} is the name of
the function.

@ignore
@code{length} is still a subroutine, but you need C-h f to discover that.

In an earlier version:
    This is written with a special notation, @samp{#<subr},
    that indicates that the function @code{length} is one of the primitive
    functions written in C rather than in Emacs Lisp.  (@samp{subr} is an
    abbreviation for `subroutine'.)  @xref{What Is a Function, , What Is a
    Function?, elisp , The GNU Emacs Lisp Reference Manual}, for more
    about subroutines.
@end ignore


@node nthcdr, nth, cons, car cdr & cons
@comment  node-name,  next,  previous,  up
@section @code{nthcdr}
@findex nthcdr

The @code{nthcdr} function is associated with the @code{cdr} function.
What it does is take the @sc{cdr} of a list repeatedly.

If you take the @sc{cdr} of the list @code{(pine fir
oak maple)}, you will be returned the list @code{(fir oak maple)}.  If you
repeat this on what was returned, you will be returned the list
@code{(oak maple)}.  (Of course, repeated @sc{cdr}ing on the original
list will just give you the original @sc{cdr} since the function does
not change the list.  You need to evaluate the @sc{cdr} of the
@sc{cdr} and so on.)  If you continue this, eventually you will be
returned an empty list, which in this case, instead of being shown as
@code{()} is shown as @code{nil}.

@need 1200
For review, here is a series of repeated @sc{cdr}s, the text following
the @samp{@result{}} shows what is returned.

@smallexample
@group
(cdr '(pine fir oak maple))
     @result{}(fir oak maple)
@end group

@group
(cdr '(fir oak maple))
     @result{} (oak maple)
@end group

@group
(cdr '(oak maple))
     @result{}(maple)
@end group

@group
(cdr '(maple))
     @result{} nil
@end group

@group
(cdr 'nil)
     @result{} nil
@end group

@group
(cdr ())
     @result{} nil
@end group
@end smallexample

@need 1200
You can also do several @sc{cdr}s without printing the values in
between, like this:

@smallexample
@group
(cdr (cdr '(pine fir oak maple)))
     @result{} (oak maple)
@end group
@end smallexample

@noindent
In this example, the Lisp interpreter evaluates the innermost list first.
The innermost list is quoted, so it just passes the list as it is to the
innermost @code{cdr}.  This @code{cdr} passes a list made up of the
second and subsequent elements of the list to the outermost @code{cdr},
which produces a list composed of the third and subsequent elements of
the original list.  In this example, the @code{cdr} function is repeated
and returns a list that consists of the original list without its
first two elements.

The @code{nthcdr} function does the same as repeating the call to
@code{cdr}.  In the following example, the argument 2 is passed to the
function @code{nthcdr}, along with the list, and the value returned is
the list without its first two items, which is exactly the same
as repeating @code{cdr} twice on the list:

@smallexample
@group
(nthcdr 2 '(pine fir oak maple))
     @result{} (oak maple)
@end group
@end smallexample

@need 1200
Using the original four element list, we can see what happens when
various numeric arguments are passed to @code{nthcdr}, including 0, 1,
and 5:

@smallexample
@group
;; @r{Leave the list as it was.}
(nthcdr 0 '(pine fir oak maple))
     @result{} (pine fir oak maple)
@end group

@group
;; @r{Return a copy without the first element.}
(nthcdr 1 '(pine fir oak maple))
     @result{} (fir oak maple)
@end group

@group
;; @r{Return a copy of the list without three elements.}
(nthcdr 3 '(pine fir oak maple))
     @result{} (maple)
@end group

@group
;; @r{Return a copy lacking all four elements.}
(nthcdr 4 '(pine fir oak maple))
     @result{} nil
@end group

@group
;; @r{Return a copy lacking all elements.}
(nthcdr 5 '(pine fir oak maple))
     @result{} nil
@end group
@end smallexample


@node nth, setcar, nthcdr, car cdr & cons
@comment  node-name,  next,  previous,  up
@section @code{nth}
@findex nth

The @code{nthcdr} function takes the @sc{cdr} of a list repeatedly.
The @code{nth} function takes the @sc{car} of the result returned by
@code{nthcdr}.  It returns the Nth element of the list.

@need 1500
Thus, if it were not defined in C for speed, the definition of
@code{nth} would be:

@smallexample
@group
(defun nth (n list)
  "Returns the Nth element of LIST.
N counts from zero.  If LIST is not that long, nil is returned."
  (car (nthcdr n list)))
@end group
@end smallexample

@noindent
(Originally, @code{nth} was defined in Emacs Lisp in @file{subr.el},
but its definition was redone in C in the 1980s.)

The @code{nth} function returns a single element of a list.
This can be very convenient.

Note that the elements are numbered from zero, not one.  That is to
say, the first element of a list, its @sc{car} is the zeroth element.
This is called `zero-based' counting and often bothers people who
are accustomed to the first element in a list being number one, which
is `one-based'.

@need 1250
For example:

@smallexample
@group
(nth 0 '("one" "two" "three"))
    @result{} "one"

(nth 1 '("one" "two" "three"))
    @result{} "two"
@end group
@end smallexample

It is worth mentioning that @code{nth}, like @code{nthcdr} and
@code{cdr}, does not change the original list---the function is
non-destructive.  This is in sharp contrast to the @code{setcar} and
@code{setcdr} functions.


@node setcar, setcdr, nth, car cdr & cons
@comment  node-name,  next,  previous,  up
@section @code{setcar}
@findex setcar

As you might guess from their names, the @code{setcar} and @code{setcdr}
functions set the @sc{car} or the @sc{cdr} of a list to a new value.
They actually change the original list, unlike @code{car} and @code{cdr}
which leave the original list as it was.  One way to find out how this
works is to experiment.  We will start with the @code{setcar} function.

@need 1200
First, we can make a list and then set the value of a variable to the
list, using the @code{setq} function.  Here is a list of animals:

@smallexample
(setq animals '(antelope giraffe lion tiger))
@end smallexample

@noindent
If you are reading this in Info inside of GNU Emacs, you can evaluate
this expression in the usual fashion, by positioning the cursor after
the expression and typing @kbd{C-x C-e}.  (I'm doing this right here
as I write this.  This is one of the advantages of having the
interpreter built into the computing environment.  Incidentally, when
there is nothing on the line after the final parentheses, such as a
comment, point can be on the next line.  Thus, if your cursor is in
the first column of the next line, you do not need to move it.
Indeed, Emacs permits any amount of white space after the final
parenthesis.)

@need 1200
When we evaluate the variable @code{animals}, we see that it is bound to
the list @code{(antelope giraffe lion tiger)}:

@smallexample
@group
animals
     @result{} (antelope giraffe lion tiger)
@end group
@end smallexample

@noindent
Put another way, the variable @code{animals} points to the list
@code{(antelope giraffe lion tiger)}.

Next, evaluate the function @code{setcar} while passing it two
arguments, the variable @code{animals} and the quoted symbol
@code{hippopotamus}; this is done by writing the three element list
@code{(setcar animals 'hippopotamus)} and then evaluating it in the
usual fashion:

@smallexample
(setcar animals 'hippopotamus)
@end smallexample

@need 1200
@noindent
After evaluating this expression, evaluate the variable @code{animals}
again.  You will see that the list of animals has changed:

@smallexample
@group
animals
     @result{} (hippopotamus giraffe lion tiger)
@end group
@end smallexample

@noindent
The first element on the list, @code{antelope} is replaced by
@code{hippopotamus}.

So we can see that @code{setcar} did not add a new element to the list
as @code{cons} would have; it replaced @code{antelope} with
@code{hippopotamus}; it @emph{changed} the list.


@node setcdr, cons Exercise, setcar, car cdr & cons
@comment  node-name,  next,  previous,  up
@section @code{setcdr}
@findex setcdr

The @code{setcdr} function is similar to the @code{setcar} function,
except that the function replaces the second and subsequent elements of
a list rather than the first element.

(To see how to change the last element of a list, look ahead to
@ref{kill-new function, , The @code{kill-new} function}, which uses
the @code{nthcdr} and @code{setcdr} functions.)

@need 1200
To see how this works, set the value of the variable to a list of
domesticated animals by evaluating the following expression:

@smallexample
(setq domesticated-animals '(horse cow sheep goat))
@end smallexample

@need 1200
@noindent
If you now evaluate the list, you will be returned the list
@code{(horse cow sheep goat)}:

@smallexample
@group
domesticated-animals
     @result{} (horse cow sheep goat)
@end group
@end smallexample

@need 1200
Next, evaluate @code{setcdr} with two arguments, the name of the
variable which has a list as its value, and the list to which the
@sc{cdr} of the first list will be set;

@smallexample
(setcdr domesticated-animals '(cat dog))
@end smallexample

@noindent
If you evaluate this expression, the list @code{(cat dog)} will appear
in the echo area.  This is the value returned by the function.  The
result we are interested in is the ``side effect'', which we can see by
evaluating the variable @code{domesticated-animals}:

@smallexample
@group
domesticated-animals
     @result{} (horse cat dog)
@end group
@end smallexample

@noindent
Indeed, the list is changed from @code{(horse cow sheep goat)} to
@code{(horse cat dog)}.  The @sc{cdr} of the list is changed from
@code{(cow sheep goat)} to @code{(cat dog)}.


@node cons Exercise,  , setcdr, car cdr & cons
@section Exercise

Construct a list of four birds by evaluating several expressions with
@code{cons}.  Find out what happens when you @code{cons} a list onto
itself.  Replace the first element of the list of four birds with a
fish.  Replace the rest of that list with a list of other fish.


@node Cutting & Storing Text, List Implementation, car cdr & cons, Top
@comment  node-name,  next,  previous,  up
@chapter Cutting and Storing Text
@cindex Cutting and storing text
@cindex Storing and cutting text
@cindex Killing text
@cindex Clipping text
@cindex Erasing text
@cindex Deleting text

Whenever you cut or clip text out of a buffer with a `kill' command in
GNU Emacs, it is stored in a list and you can bring it back with a
`yank' command.

(The use of the word `kill' in Emacs for processes which specifically
@emph{do not} destroy the values of the entities is an unfortunate
historical accident.  A much more appropriate word would be `clip' since
that is what the kill commands do; they clip text out of a buffer and
put it into storage from which it can be brought back.  I have often
been tempted to replace globally all occurrences of `kill' in the Emacs
sources with `clip' and all occurrences of `killed' with `clipped'.)

@menu
* Storing Text::                Text is stored in a list.
* zap-to-char::                 Cutting out text up to a character.
* kill-region::                 Cutting text out of a region.
* copy-region-as-kill::         A definition for copying text.
* Digression into C::           Minor note on C programming language macros.
* defvar::                      How to give a variable an initial value.
* cons & search-fwd Review::
* search Exercises::
@end menu

@node Storing Text, zap-to-char, Cutting & Storing Text, Cutting & Storing Text
@ifnottex
@unnumberedsec Storing Text in a List
@end ifnottex

When text is cut out of a buffer, it is stored on a list.  Successive
pieces of text are stored on the list successively, so the list might
look like this:

@smallexample
("a piece of text" "previous piece")
@end smallexample

@need 1200
@noindent
The function @code{cons} can be used to create a new list from a piece
of text (an `atom', to use the jargon) and an existing list, like
this:

@smallexample
@group
(cons "another piece"
      '("a piece of text" "previous piece"))
@end group
@end smallexample

@need 1200
@noindent
If you evaluate this expression, a list of three elements will appear in
the echo area:

@smallexample
("another piece" "a piece of text" "previous piece")
@end smallexample

With the @code{car} and @code{nthcdr} functions, you can retrieve
whichever piece of text you want.  For example, in the following code,
@code{nthcdr 1 @dots{}} returns the list with the first item removed;
and the @code{car} returns the first element of that remainder---the
second element of the original list:

@smallexample
@group
(car (nthcdr 1 '("another piece"
                 "a piece of text"
                 "previous piece")))
     @result{} "a piece of text"
@end group
@end smallexample

The actual functions in Emacs are more complex than this, of course.
The code for cutting and retrieving text has to be written so that
Emacs can figure out which element in the list you want---the first,
second, third, or whatever.  In addition, when you get to the end of
the list, Emacs should give you the first element of the list, rather
than nothing at all.

The list that holds the pieces of text is called the @dfn{kill ring}.
This chapter leads up to a description of the kill ring and how it is
used by first tracing how the @code{zap-to-char} function works.  This
function uses (or `calls') a function that invokes a function that
manipulates the kill ring.  Thus, before reaching the mountains, we
climb the foothills.

A subsequent chapter describes how text that is cut from the buffer is
retrieved.  @xref{Yanking, , Yanking Text Back}.


@node zap-to-char, kill-region, Storing Text, Cutting & Storing Text
@comment  node-name,  next,  previous,  up
@section @code{zap-to-char}
@findex zap-to-char

The @code{zap-to-char} function changed little between GNU Emacs
version 19 and GNU Emacs version 22.  However, @code{zap-to-char}
calls another function, @code{kill-region}, which enjoyed a major
rewrite.

The @code{kill-region} function in Emacs 19 is complex, but does not
use code that is important at this time.  We will skip it.

The @code{kill-region} function in Emacs 22 is easier to read than the
same function in Emacs 19 and introduces a very important concept,
that of error handling.  We will walk through the function.

But first, let us look at the interactive @code{zap-to-char} function.

@menu
* Complete zap-to-char::        The complete implementation.
* zap-to-char interactive::     A three part interactive expression.
* zap-to-char body::            A short overview.
* search-forward::              How to search for a string.
* progn::                       The @code{progn} special form.
* Summing up zap-to-char::      Using @code{point} and @code{search-forward}.
@end menu

@node Complete zap-to-char, zap-to-char interactive, zap-to-char, zap-to-char
@ifnottex
@unnumberedsubsec The Complete @code{zap-to-char} Implementation
@end ifnottex

The @code{zap-to-char} function removes the text in the region between
the location of the cursor (i.e., of point) up to and including the
next occurrence of a specified character.  The text that
@code{zap-to-char} removes is put in the kill ring; and it can be
retrieved from the kill ring by typing @kbd{C-y} (@code{yank}).  If
the command is given an argument, it removes text through that number
of occurrences.  Thus, if the cursor were at the beginning of this
sentence and the character were @samp{s}, @samp{Thus} would be
removed.  If the argument were two, @samp{Thus, if the curs} would be
removed, up to and including the @samp{s} in @samp{cursor}.

If the specified character is not found, @code{zap-to-char} will say
``Search failed'', tell you the character you typed, and not remove
any text.

In order to determine how much text to remove, @code{zap-to-char} uses
a search function.  Searches are used extensively in code that
manipulates text, and we will focus attention on them as well as on the
deletion command.

@ignore
@c GNU Emacs version 19
(defun zap-to-char (arg char)  ; version 19 implementation
  "Kill up to and including ARG'th occurrence of CHAR.
Goes backward if ARG is negative; error if CHAR not found."
  (interactive "*p\ncZap to char: ")
  (kill-region (point)
               (progn
                 (search-forward
                  (char-to-string char) nil nil arg)
                 (point))))
@end ignore

@need 1250
Here is the complete text of the version 22 implementation of the function:

@c GNU Emacs 22
@smallexample
@group
(defun zap-to-char (arg char)
  "Kill up to and including ARG'th occurrence of CHAR.
Case is ignored if `case-fold-search' is non-nil in the current buffer.
Goes backward if ARG is negative; error if CHAR not found."
  (interactive "p\ncZap to char: ")
  (if (char-table-p translation-table-for-input)
      (setq char (or (aref translation-table-for-input char) char)))
  (kill-region (point) (progn
                         (search-forward (char-to-string char)
                                         nil nil arg)
                         (point))))
@end group
@end smallexample

The documentation is thorough.  You do need to know the jargon meaning
of the word `kill'.

@node zap-to-char interactive, zap-to-char body, Complete zap-to-char, zap-to-char
@comment  node-name,  next,  previous,  up
@subsection The @code{interactive} Expression

@need 800
The interactive expression in the @code{zap-to-char} command looks like
this:

@smallexample
(interactive "p\ncZap to char: ")
@end smallexample

The part within quotation marks, @code{"p\ncZap to char:@: "}, specifies
two different things.  First, and most simply, is the @samp{p}.
This part is separated from the next part by a newline, @samp{\n}.
The @samp{p} means that the first argument to the function will be
passed the value of a `processed prefix'.  The prefix argument is
passed by typing @kbd{C-u} and a number, or @kbd{M-} and a number.  If
the function is called interactively without a prefix, 1 is passed to
this argument.

The second part of @code{"p\ncZap to char:@: "} is
@samp{cZap to char:@:  }.  In this part, the lower case @samp{c}
indicates that @code{interactive} expects a prompt and that the
argument will be a character.  The prompt follows the @samp{c} and is
the string @samp{Zap to char:@: } (with a space after the colon to
make it look good).

What all this does is prepare the arguments to @code{zap-to-char} so they
are of the right type, and give the user a prompt.

In a read-only buffer, the @code{zap-to-char} function copies the text
to the kill ring, but does not remove it.  The echo area displays a
message saying that the buffer is read-only.  Also, the terminal may
beep or blink at you.

@node zap-to-char body, search-forward, zap-to-char interactive, zap-to-char
@comment  node-name,  next,  previous,  up
@subsection The Body of @code{zap-to-char}

The body of the @code{zap-to-char} function contains the code that
kills (that is, removes) the text in the region from the current
position of the cursor up to and including the specified character.

The first part of the code looks like this:

@smallexample
(if (char-table-p translation-table-for-input)
    (setq char (or (aref translation-table-for-input char) char)))
(kill-region (point) (progn
                       (search-forward (char-to-string char) nil nil arg)
                       (point)))
@end smallexample

@noindent
@code{char-table-p} is an hitherto unseen function.  It determines
whether its argument is a character table.  When it is, it sets the
character passed to @code{zap-to-char} to one of them, if that
character exists, or to the character itself.  (This becomes important
for certain characters in non-European languages.  The @code{aref}
function extracts an element from an array.  It is an array-specific
function that is not described in this document.  @xref{Arrays, ,
Arrays, elisp, The GNU Emacs Lisp Reference Manual}.)

@noindent
@code{(point)} is the current position of the cursor.

The next part of the code is an expression using @code{progn}.  The body
of the @code{progn} consists of calls to @code{search-forward} and
@code{point}.

It is easier to understand how @code{progn} works after learning about
@code{search-forward}, so we will look at @code{search-forward} and
then at @code{progn}.

@node search-forward, progn, zap-to-char body, zap-to-char
@comment  node-name,  next,  previous,  up
@subsection The @code{search-forward} Function
@findex search-forward

The @code{search-forward} function is used to locate the
zapped-for-character in @code{zap-to-char}.  If the search is
successful, @code{search-forward} leaves point immediately after the
last character in the target string.  (In @code{zap-to-char}, the
target string is just one character long.  @code{zap-to-char} uses the
function @code{char-to-string} to ensure that the computer treats that
character as a string.)  If the search is backwards,
@code{search-forward} leaves point just before the first character in
the target.  Also, @code{search-forward} returns @code{t} for true.
(Moving point is therefore a `side effect'.)

@need 1250
In @code{zap-to-char}, the @code{search-forward} function looks like this:

@smallexample
(search-forward (char-to-string char) nil nil arg)
@end smallexample

The @code{search-forward} function takes four arguments:

@enumerate
@item
The first argument is the target, what is searched for.  This must be a
string, such as @samp{"z"}.

As it happens, the argument passed to @code{zap-to-char} is a single
character.  Because of the way computers are built, the Lisp
interpreter may treat a single character as being different from a
string of characters.  Inside the computer, a single character has a
different electronic format than a string of one character.  (A single
character can often be recorded in the computer using exactly one
byte; but a string may be longer, and the computer needs to be ready
for this.)  Since the @code{search-forward} function searches for a
string, the character that the @code{zap-to-char} function receives as
its argument must be converted inside the computer from one format to
the other; otherwise the @code{search-forward} function will fail.
The @code{char-to-string} function is used to make this conversion.

@item
The second argument bounds the search; it is specified as a position in
the buffer.  In this case, the search can go to the end of the buffer,
so no bound is set and the second argument is @code{nil}.

@item
The third argument tells the function what it should do if the search
fails---it can signal an error (and print a message) or it can return
@code{nil}.  A @code{nil} as the third argument causes the function to
signal an error when the search fails.

@item
The fourth argument to @code{search-forward} is the repeat count---how
many occurrences of the string to look for.  This argument is optional
and if the function is called without a repeat count, this argument is
passed the value 1.  If this argument is negative, the search goes
backwards.
@end enumerate

@need 800
In template form, a @code{search-forward} expression looks like this:

@smallexample
@group
(search-forward "@var{target-string}"
                @var{limit-of-search}
                @var{what-to-do-if-search-fails}
                @var{repeat-count})
@end group
@end smallexample

We will look at @code{progn} next.

@node progn, Summing up zap-to-char, search-forward, zap-to-char
@comment  node-name,  next,  previous,  up
@subsection The @code{progn} Special Form
@findex progn

@code{progn} is a special form that causes each of its arguments to be
evaluated in sequence and then returns the value of the last one.  The
preceding expressions are evaluated only for the side effects they
perform.  The values produced by them are discarded.

@need 800
The template for a @code{progn} expression is very simple:

@smallexample
@group
(progn
  @var{body}@dots{})
@end group
@end smallexample

In @code{zap-to-char}, the @code{progn} expression has to do two things:
put point in exactly the right position; and return the location of
point so that @code{kill-region} will know how far to kill to.

The first argument to the @code{progn} is @code{search-forward}.  When
@code{search-forward} finds the string, the function leaves point
immediately after the last character in the target string.  (In this
case the target string is just one character long.)  If the search is
backwards, @code{search-forward} leaves point just before the first
character in the target.  The movement of point is a side effect.

The second and last argument to @code{progn} is the expression
@code{(point)}.  This expression returns the value of point, which in
this case will be the location to which it has been moved by
@code{search-forward}.  (In the source, a line that tells the function
to go to the previous character, if it is going forward, was commented
out in 1999; I don't remember whether that feature or mis-feature was
ever a part of the distributed source.)  The value of @code{point} is
returned by the @code{progn} expression and is passed to
@code{kill-region} as @code{kill-region}'s second argument.

@node Summing up zap-to-char,  , progn, zap-to-char
@comment  node-name,  next,  previous,  up
@subsection Summing up @code{zap-to-char}

Now that we have seen how @code{search-forward} and @code{progn} work,
we can see how the @code{zap-to-char} function works as a whole.

The first argument to @code{kill-region} is the position of the cursor
when the @code{zap-to-char} command is given---the value of point at
that time.  Within the @code{progn}, the search function then moves
point to just after the zapped-to-character and @code{point} returns the
value of this location.  The @code{kill-region} function puts together
these two values of point, the first one as the beginning of the region
and the second one as the end of the region, and removes the region.

The @code{progn} special form is necessary because the
@code{kill-region} command takes two arguments; and it would fail if
@code{search-forward} and @code{point} expressions were written in
sequence as two additional arguments.  The @code{progn} expression is
a single argument to @code{kill-region} and returns the one value that
@code{kill-region} needs for its second argument.


@node kill-region, copy-region-as-kill, zap-to-char, Cutting & Storing Text
@comment  node-name,  next,  previous,  up
@section @code{kill-region}
@findex kill-region

The @code{zap-to-char} function uses the @code{kill-region} function.
This function clips text from a region and copies that text to
the kill ring, from which it may be retrieved.

@ignore
GNU Emacs 22:

(defun kill-region (beg end &optional yank-handler)
  "Kill (\"cut\") text between point and mark.
This deletes the text from the buffer and saves it in the kill ring.
The command \\[yank] can retrieve it from there.
\(If you want to kill and then yank immediately, use \\[kill-ring-save].)

If you want to append the killed region to the last killed text,
use \\[append-next-kill] before \\[kill-region].

If the buffer is read-only, Emacs will beep and refrain from deleting
the text, but put the text in the kill ring anyway.  This means that
you can use the killing commands to copy text from a read-only buffer.

This is the primitive for programs to kill text (as opposed to deleting it).
Supply two arguments, character positions indicating the stretch of text
 to be killed.
Any command that calls this function is a \"kill command\".
If the previous command was also a kill command,
the text killed this time appends to the text killed last time
to make one entry in the kill ring.

In Lisp code, optional third arg YANK-HANDLER, if non-nil,
specifies the yank-handler text property to be set on the killed
text.  See `insert-for-yank'."
  ;; Pass point first, then mark, because the order matters
  ;; when calling kill-append.
  (interactive (list (point) (mark)))
  (unless (and beg end)
    (error "The mark is not set now, so there is no region"))
  (condition-case nil
      (let ((string (filter-buffer-substring beg end t)))
        (when string                        ;STRING is nil if BEG = END
          ;; Add that string to the kill ring, one way or another.
          (if (eq last-command 'kill-region)
              (kill-append string (< end beg) yank-handler)
            (kill-new string nil yank-handler)))
        (when (or string (eq last-command 'kill-region))
          (setq this-command 'kill-region))
        nil)
    ((buffer-read-only text-read-only)
     ;; The code above failed because the buffer, or some of the characters
     ;; in the region, are read-only.
     ;; We should beep, in case the user just isn't aware of this.
     ;; However, there's no harm in putting
     ;; the region's text in the kill ring, anyway.
     (copy-region-as-kill beg end)
     ;; Set this-command now, so it will be set even if we get an error.
     (setq this-command 'kill-region)
     ;; This should barf, if appropriate, and give us the correct error.
     (if kill-read-only-ok
         (progn (message "Read only text copied to kill ring") nil)
       ;; Signal an error if the buffer is read-only.
       (barf-if-buffer-read-only)
       ;; If the buffer isn't read-only, the text is.
       (signal 'text-read-only (list (current-buffer)))))))
@end ignore

The Emacs 22 version of that function uses @code{condition-case} and
@code{copy-region-as-kill}, both of which we will explain.
@code{condition-case} is an important special form.

In essence, the @code{kill-region} function calls
@code{condition-case}, which takes three arguments.  In this function,
the first argument does nothing.  The second argument contains the
code that does the work when all goes well.  The third argument
contains the code that is called in the event of an error.

@menu
* Complete kill-region::        The function definition.
* condition-case::              Dealing with a problem.
* Lisp macro::
@end menu

@node Complete kill-region, condition-case, kill-region, kill-region
@ifnottex
@unnumberedsubsec The Complete @code{kill-region} Definition
@end ifnottex

@need 1200
We will go through the @code{condition-case} code in a moment.  First,
let us look at the definition of @code{kill-region}, with comments
added:

@c GNU Emacs 22:
@smallexample
@group
(defun kill-region (beg end)
  "Kill (\"cut\") text between point and mark.
This deletes the text from the buffer and saves it in the kill ring.
The command \\[yank] can retrieve it from there. @dots{} "
@end group

@group
  ;; @bullet{} Since order matters, pass point first.
  (interactive (list (point) (mark)))
  ;; @bullet{} And tell us if we cannot cut the text.
  ;; `unless' is an `if' without a then-part.
  (unless (and beg end)
    (error "The mark is not set now, so there is no region"))
@end group

@group
  ;; @bullet{} `condition-case' takes three arguments.
  ;;    If the first argument is nil, as it is here,
  ;;    information about the error signal is not
  ;;    stored for use by another function.
  (condition-case nil
@end group

@group
      ;; @bullet{} The second argument to `condition-case' tells the
      ;;    Lisp interpreter what to do when all goes well.
@end group

@group
      ;;    It starts with a `let' function that extracts the string
      ;;    and tests whether it exists.  If so (that is what the
      ;;    `when' checks), it calls an `if' function that determines
      ;;    whether the previous command was another call to
      ;;    `kill-region'; if it was, then the new text is appended to
      ;;    the previous text; if not, then a different function,
      ;;    `kill-new', is called.
@end group

@group
      ;;    The `kill-append' function concatenates the new string and
      ;;    the old.  The `kill-new' function inserts text into a new
      ;;    item in the kill ring.
@end group

@group
      ;;    `when' is an `if' without an else-part.  The second `when'
      ;;    again checks whether the current string exists; in
      ;;    addition, it checks whether the previous command was
      ;;    another call to `kill-region'.  If one or the other
      ;;    condition is true, then it sets the current command to
      ;;    be `kill-region'.
@end group
@group
      (let ((string (filter-buffer-substring beg end t)))
        (when string                    ;STRING is nil if BEG = END
          ;; Add that string to the kill ring, one way or another.
          (if (eq last-command 'kill-region)
@end group
@group
              ;;    @minus{} `yank-handler' is an optional argument to
              ;;    `kill-region' that tells the `kill-append' and
              ;;    `kill-new' functions how deal with properties
              ;;    added to the text, such as `bold' or `italics'.
              (kill-append string (< end beg) yank-handler)
            (kill-new string nil yank-handler)))
        (when (or string (eq last-command 'kill-region))
          (setq this-command 'kill-region))
        nil)
@end group

@group
    ;;  @bullet{} The third argument to `condition-case' tells the interpreter
    ;;    what to do with an error.
@end group
@group
    ;;    The third argument has a conditions part and a body part.
    ;;    If the conditions are met (in this case,
    ;;             if text or buffer are read-only)
    ;;    then the body is executed.
@end group
@group
    ;;    The first part of the third argument is the following:
    ((buffer-read-only text-read-only) ;; the if-part
     ;; @dots{}  the then-part
     (copy-region-as-kill beg end)
@end group
@group
     ;;    Next, also as part of the then-part, set this-command, so
     ;;    it will be set in an error
     (setq this-command 'kill-region)
     ;;    Finally, in the then-part, send a message if you may copy
     ;;    the text to the kill ring without signally an error, but
     ;;    don't if you may not.
@end group
@group
     (if kill-read-only-ok
         (progn (message "Read only text copied to kill ring") nil)
       (barf-if-buffer-read-only)
       ;; If the buffer isn't read-only, the text is.
       (signal 'text-read-only (list (current-buffer)))))
@end group
@end smallexample

@ignore
@c v 21
@smallexample
@group
(defun kill-region (beg end)
  "Kill between point and mark.
The text is deleted but saved in the kill ring."
  (interactive "r")
@end group

@group
  ;; 1. `condition-case' takes three arguments.
  ;;    If the first argument is nil, as it is here,
  ;;    information about the error signal is not
  ;;    stored for use by another function.
  (condition-case nil
@end group

@group
      ;; 2. The second argument to `condition-case'
      ;;    tells the Lisp interpreter what to do when all goes well.
@end group

@group
      ;;    The `delete-and-extract-region' function usually does the
      ;;    work.  If the beginning and ending of the region are both
      ;;    the same, then the variable `string' will be empty, or nil
      (let ((string (delete-and-extract-region beg end)))
@end group

@group
        ;; `when' is an `if' clause that cannot take an `else-part'.
        ;; Emacs normally sets the value of `last-command' to the
        ;; previous command.
@end group
@group
        ;; `kill-append' concatenates the new string and the old.
        ;; `kill-new' inserts text into a new item in the kill ring.
        (when string
          (if (eq last-command 'kill-region)
              ;; if true, prepend string
              (kill-append string (< end beg))
            (kill-new string)))
        (setq this-command 'kill-region))
@end group

@group
    ;; 3. The third argument to `condition-case' tells the interpreter
    ;;    what to do with an error.
@end group
@group
    ;;    The third argument has a conditions part and a body part.
    ;;    If the conditions are met (in this case,
    ;;             if text or buffer are read-only)
    ;;    then the body is executed.
@end group
@group
    ((buffer-read-only text-read-only) ;; this is the if-part
     ;; then...
     (copy-region-as-kill beg end)
@end group
@group
     (if kill-read-only-ok            ;; usually this variable is nil
         (message "Read only text copied to kill ring")
       ;; or else, signal an error if the buffer is read-only;
       (barf-if-buffer-read-only)
       ;; and, in any case, signal that the text is read-only.
       (signal 'text-read-only (list (current-buffer)))))))
@end group
@end smallexample
@end ignore

@node condition-case, Lisp macro, Complete kill-region, kill-region
@comment  node-name,  next,  previous,  up
@subsection @code{condition-case}
@findex condition-case

As we have seen earlier (@pxref{에러 만들기, , Generate an Error
Message}), when the Emacs Lisp interpreter has trouble evaluating an
expression, it provides you with help; in the jargon, this is called
``signaling an error''.  Usually, the computer stops the program and
shows you a message.

However, some programs undertake complicated actions.  They should not
simply stop on an error.  In the @code{kill-region} function, the most
likely error is that you will try to kill text that is read-only and
cannot be removed.  So the @code{kill-region} function contains code
to handle this circumstance.  This code, which makes up the body of
the @code{kill-region} function, is inside of a @code{condition-case}
special form.

@need 800
The template for @code{condition-case} looks like this:

@smallexample
@group
(condition-case
  @var{var}
  @var{bodyform}
  @var{error-handler}@dots{})
@end group
@end smallexample

The second argument, @var{bodyform}, is straightforward.  The
@code{condition-case} special form causes the Lisp interpreter to
evaluate the code in @var{bodyform}.  If no error occurs, the special
form returns the code's value and produces the side-effects, if any.

In short, the @var{bodyform} part of a @code{condition-case}
expression determines what should happen when everything works
correctly.

However, if an error occurs, among its other actions, the function
generating the error signal will define one or more error condition
names.

An error handler is the third argument to @code{condition case}.
An error handler has two parts, a @var{condition-name} and a
@var{body}.  If the @var{condition-name} part of an error handler
matches a condition name generated by an error, then the @var{body}
part of the error handler is run.

As you will expect, the @var{condition-name} part of an error handler
may be either a single condition name or a list of condition names.

Also, a complete @code{condition-case} expression may contain more
than one error handler.  When an error occurs, the first applicable
handler is run.

Lastly, the first argument to the @code{condition-case} expression,
the @var{var} argument, is sometimes bound to a variable that
contains information about the error.  However, if that argument is
nil, as is the case in @code{kill-region}, that information is
discarded.

@need 1200
In brief, in the @code{kill-region} function, the code
@code{condition-case} works like this:

@smallexample
@group
@var{If no errors}, @var{run only this code}
    @var{but}, @var{if errors}, @var{run this other code}.
@end group
@end smallexample

@ignore
2006 Oct 24
In Emacs 22,
copy-region-as-kill is short, 12 lines, and uses
filter-buffer-substring, which is longer, 39 lines
and has delete-and-extract-region in it.
delete-and-extract-region is written in C.

see Initializing a Variable with @code{defvar}
this is line 8054
Initializing a Variable with @code{defvar} includes line 8350
@end ignore

@node Lisp macro,  , condition-case, kill-region
@comment  node-name,  next,  previous,  up
@subsection Lisp macro
@cindex Macro, lisp
@cindex Lisp macro

The part of the @code{condition-case} expression that is evaluated in
the expectation that all goes well has a @code{when}.  The code uses
@code{when} to determine whether the @code{string} variable points to
text that exists.

A @code{when} expression is simply a programmers' convenience.  It is
an @code{if} without the possibility of an else clause.  In your mind,
you can replace @code{when} with @code{if} and understand what goes
on.  That is what the Lisp interpreter does.

Technically speaking, @code{when} is a Lisp macro.  A Lisp @dfn{macro}
enables you to define new control constructs and other language
features.  It tells the interpreter how to compute another Lisp
expression which will in turn compute the value.  In this case, the
`other expression' is an @code{if} expression.

The @code{kill-region} function definition also has an @code{unless}
macro; it is the converse of @code{when}.  The @code{unless} macro is
an @code{if} without a then clause

For more about Lisp macros, see @ref{Macros, , Macros, elisp, The GNU
Emacs Lisp Reference Manual}.  The C programming language also
provides macros.  These are different, but also useful.

@ignore
We will briefly look at C macros in
@ref{Digression into C}.
@end ignore

@need 1200
Regarding the @code{when} macro, in the @code{condition-case}
expression, when the string has content, then another conditional
expression is executed.  This is an @code{if} with both a then-part
and an else-part.

@smallexample
@group
(if (eq last-command 'kill-region)
    (kill-append string (< end beg) yank-handler)
  (kill-new string nil yank-handler))
@end group
@end smallexample

The then-part is evaluated if the previous command was another call to
@code{kill-region}; if not, the else-part is evaluated.

@code{yank-handler} is an optional argument to @code{kill-region} that
tells the @code{kill-append} and @code{kill-new} functions how deal
with properties added to the text, such as `bold' or `italics'.

@code{last-command} is a variable that comes with Emacs that we have
not seen before.  Normally, whenever a function is executed, Emacs
sets the value of @code{last-command} to the previous command.

@need 1200
In this segment of the definition, the @code{if} expression checks
whether the previous command was @code{kill-region}.  If it was,

@smallexample
(kill-append string (< end beg) yank-handler)
@end smallexample

@noindent
concatenates a copy of the newly clipped text to the just previously
clipped text in the kill ring.


@node copy-region-as-kill, Digression into C, kill-region, Cutting & Storing Text
@comment  node-name,  next,  previous,  up
@section @code{copy-region-as-kill}
@findex copy-region-as-kill
@findex nthcdr

The @code{copy-region-as-kill} function copies a region of text from a
buffer and (via either @code{kill-append} or @code{kill-new}) saves it
in the @code{kill-ring}.

If you call @code{copy-region-as-kill} immediately after a
@code{kill-region} command, Emacs appends the newly copied text to the
previously copied text.  This means that if you yank back the text, you
get it all, from both this and the previous operation.  On the other
hand, if some other command precedes the @code{copy-region-as-kill},
the function copies the text into a separate entry in the kill ring.

@menu
* Complete copy-region-as-kill::  The complete function definition.
* copy-region-as-kill body::      The body of @code{copy-region-as-kill}.
@end menu

@node Complete copy-region-as-kill, copy-region-as-kill body, copy-region-as-kill, copy-region-as-kill
@ifnottex
@unnumberedsubsec The complete @code{copy-region-as-kill} function definition
@end ifnottex

@need 1200
Here is the complete text of the version 22 @code{copy-region-as-kill}
function:

@smallexample
@group
(defun copy-region-as-kill (beg end)
  "Save the region as if killed, but don't kill it.
In Transient Mark mode, deactivate the mark.
If `interprogram-cut-function' is non-nil, also save the text for a window
system cut and paste."
  (interactive "r")
@end group
@group
  (if (eq last-command 'kill-region)
      (kill-append (filter-buffer-substring beg end) (< end beg))
    (kill-new (filter-buffer-substring beg end)))
@end group
@group
  (if transient-mark-mode
      (setq deactivate-mark t))
  nil)
@end group
@end smallexample

@need 800
As usual, this function can be divided into its component parts:

@smallexample
@group
(defun copy-region-as-kill (@var{argument-list})
  "@var{documentation}@dots{}"
  (interactive "r")
  @var{body}@dots{})
@end group
@end smallexample

The arguments are @code{beg} and @code{end} and the function is
interactive with @code{"r"}, so the two arguments must refer to the
beginning and end of the region.  If you have been reading though this
document from the beginning, understanding these parts of a function is
almost becoming routine.

The documentation is somewhat confusing unless you remember that the
word `kill' has a meaning different from usual.  The `Transient Mark'
and @code{interprogram-cut-function} comments explain certain
side-effects.

After you once set a mark, a buffer always contains a region.  If you
wish, you can use Transient Mark mode to highlight the region
temporarily.  (No one wants to highlight the region all the time, so
Transient Mark mode highlights it only at appropriate times.  Many
people turn off Transient Mark mode, so the region is never
highlighted.)

Also, a windowing system allows you to copy, cut, and paste among
different programs.  In the X windowing system, for example, the
@code{interprogram-cut-function} function is @code{x-select-text},
which works with the windowing system's equivalent of the Emacs kill
ring.

The body of the @code{copy-region-as-kill} function starts with an
@code{if} clause.  What this clause does is distinguish between two
different situations: whether or not this command is executed
immediately after a previous @code{kill-region} command.  In the first
case, the new region is appended to the previously copied text.
Otherwise, it is inserted into the beginning of the kill ring as a
separate piece of text from the previous piece.

The last two lines of the function prevent the region from lighting up
if Transient Mark mode is turned on.

The body of @code{copy-region-as-kill} merits discussion in detail.

@node copy-region-as-kill body,  , Complete copy-region-as-kill, copy-region-as-kill
@comment  node-name,  next,  previous,  up
@subsection The Body of @code{copy-region-as-kill}

The @code{copy-region-as-kill} function works in much the same way as
the @code{kill-region} function.  Both are written so that two or more
kills in a row combine their text into a single entry.  If you yank
back the text from the kill ring, you get it all in one piece.
Moreover, kills that kill forward from the current position of the
cursor are added to the end of the previously copied text and commands
that copy text backwards add it to the beginning of the previously
copied text.  This way, the words in the text stay in the proper
order.

Like @code{kill-region}, the @code{copy-region-as-kill} function makes
use of the @code{last-command} variable that keeps track of the
previous Emacs command.

@menu
* last-command & this-command::
* kill-append function::
* kill-new function::
@end menu

@node last-command & this-command, kill-append function, copy-region-as-kill body, copy-region-as-kill body
@ifnottex
@unnumberedsubsubsec @code{last-command} and @code{this-command}
@end ifnottex

Normally, whenever a function is executed, Emacs sets the value of
@code{this-command} to the function being executed (which in this case
would be @code{copy-region-as-kill}).  At the same time, Emacs sets
the value of @code{last-command} to the previous value of
@code{this-command}.

In the first part of the body of the @code{copy-region-as-kill}
function, an @code{if} expression determines whether the value of
@code{last-command} is @code{kill-region}.  If so, the then-part of
the @code{if} expression is evaluated; it uses the @code{kill-append}
function to concatenate the text copied at this call to the function
with the text already in the first element (the @sc{car}) of the kill
ring.  On the other hand, if the value of @code{last-command} is not
@code{kill-region}, then the @code{copy-region-as-kill} function
attaches a new element to the kill ring using the @code{kill-new}
function.

@need 1250
The @code{if} expression reads as follows; it uses @code{eq}:

@smallexample
@group
  (if (eq last-command 'kill-region)
      ;; @r{then-part}
      (kill-append  (filter-buffer-substring beg end) (< end beg))
    ;; @r{else-part}
    (kill-new  (filter-buffer-substring beg end)))
@end group
@end smallexample

@findex filter-buffer-substring
(The @code{filter-buffer-substring} function returns a filtered
substring of the buffer, if any.  Optionally---the arguments are not
here, so neither is done---the function may delete the initial text or
return the text without its properties; this function is a replacement
for the older @code{buffer-substring} function, which came before text
properties were implemented.)

@findex eq @r{(example of use)}
@noindent
The @code{eq} function tests whether its first argument is the same Lisp
object as its second argument.  The @code{eq} function is similar to the
@code{equal} function in that it is used to test for equality, but
differs in that it determines whether two representations are actually
the same object inside the computer, but with different names.
@code{equal} determines whether the structure and contents of two
expressions are the same.

If the previous command was @code{kill-region}, then the Emacs Lisp
interpreter calls the @code{kill-append} function

@node kill-append function, kill-new function, last-command & this-command, copy-region-as-kill body
@unnumberedsubsubsec The @code{kill-append} function
@findex kill-append

@need 800
The @code{kill-append} function looks like this:

@c in GNU Emacs 22
@smallexample
@group
(defun kill-append (string before-p &optional yank-handler)
  "Append STRING to the end of the latest kill in the kill ring.
If BEFORE-P is non-nil, prepend STRING to the kill.
@dots{} "
  (let* ((cur (car kill-ring)))
    (kill-new (if before-p (concat string cur) (concat cur string))
              (or (= (length cur) 0)
                  (equal yank-handler
                         (get-text-property 0 'yank-handler cur)))
              yank-handler)))
@end group
@end smallexample

@ignore
was:
(defun kill-append (string before-p)
  "Append STRING to the end of the latest kill in the kill ring.
If BEFORE-P is non-nil, prepend STRING to the kill.
If `interprogram-cut-function' is set, pass the resulting kill to
it."
  (kill-new (if before-p
                (concat string (car kill-ring))
              (concat (car kill-ring) string))
            t))
@end ignore

@noindent
The @code{kill-append} function is fairly straightforward.  It uses
the @code{kill-new} function, which we will discuss in more detail in
a moment.

(Also, the function provides an optional argument called
@code{yank-handler}; when invoked, this argument tells the function
how to deal with properties added to the text, such as `bold' or
`italics'.)

@c !!! bug in GNU Emacs 22 version of  kill-append ?
It has a @code{let*} function to set the value of the first element of
the kill ring to @code{cur}.  (I do not know why the function does not
use @code{let} instead; only one value is set in the expression.
Perhaps this is a bug that produces no problems?)

Consider the conditional that is one of the two arguments to
@code{kill-new}.  It uses @code{concat} to concatenate the new text to
the @sc{car} of the kill ring.  Whether it prepends or appends the
text depends on the results of an @code{if} expression:

@smallexample
@group
(if before-p                            ; @r{if-part}
    (concat string cur)                 ; @r{then-part}
  (concat cur string))                  ; @r{else-part}
@end group
@end smallexample

@noindent
If the region being killed is before the region that was killed in the
last command, then it should be prepended before the material that was
saved in the previous kill; and conversely, if the killed text follows
what was just killed, it should be appended after the previous text.
The @code{if} expression depends on the predicate @code{before-p} to
decide whether the newly saved text should be put before or after the
previously saved text.

The symbol @code{before-p} is the name of one of the arguments to
@code{kill-append}.  When the @code{kill-append} function is
evaluated, it is bound to the value returned by evaluating the actual
argument.  In this case, this is the expression @code{(< end beg)}.
This expression does not directly determine whether the killed text in
this command is located before or after the kill text of the last
command; what it does is determine whether the value of the variable
@code{end} is less than the value of the variable @code{beg}.  If it
is, it means that the user is most likely heading towards the
beginning of the buffer.  Also, the result of evaluating the predicate
expression, @code{(< end beg)}, will be true and the text will be
prepended before the previous text.  On the other hand, if the value of
the variable @code{end} is greater than the value of the variable
@code{beg}, the text will be appended after the previous text.

@need 800
When the newly saved text will be prepended, then the string with the new
text will be concatenated before the old text:

@smallexample
(concat string cur)
@end smallexample

@need 1200
@noindent
But if the text will be appended, it will be concatenated
after the old text:

@smallexample
(concat cur string))
@end smallexample

To understand how this works, we first need to review the
@code{concat} function.  The @code{concat} function links together or
unites two strings of text.  The result is a string.  For example:

@smallexample
@group
(concat "abc" "def")
     @result{} "abcdef"
@end group

@group
(concat "new "
        (car '("first element" "second element")))
     @result{} "new first element"

(concat (car
        '("first element" "second element")) " modified")
     @result{} "first element modified"
@end group
@end smallexample

We can now make sense of @code{kill-append}: it modifies the contents
of the kill ring.  The kill ring is a list, each element of which is
saved text.  The @code{kill-append} function uses the @code{kill-new}
function which in turn uses the @code{setcar} function.

@node kill-new function,  , kill-append function, copy-region-as-kill body
@unnumberedsubsubsec The @code{kill-new} function
@findex kill-new

@c in GNU Emacs 22, additional documentation to kill-new:
@ignore
Optional third arguments YANK-HANDLER controls how the STRING is later
inserted into a buffer; see `insert-for-yank' for details.
When a yank handler is specified, STRING must be non-empty (the yank
handler, if non-nil, is stored as a `yank-handler' text property on STRING).

When the yank handler has a non-nil PARAM element, the original STRING
argument is not used by `insert-for-yank'.  However, since Lisp code
may access and use elements from the kill ring directly, the STRING
argument should still be a \"useful\" string for such uses."
@end ignore
@need 1200
The @code{kill-new} function looks like this:

@smallexample
@group
(defun kill-new (string &optional replace yank-handler)
  "Make STRING the latest kill in the kill ring.
Set `kill-ring-yank-pointer' to point to it.

If `interprogram-cut-function' is non-nil, apply it to STRING.
Optional second argument REPLACE non-nil means that STRING will replace
the front of the kill ring, rather than being added to the list.
@dots{}"
@end group
@group
  (if (> (length string) 0)
      (if yank-handler
          (put-text-property 0 (length string)
                             'yank-handler yank-handler string))
    (if yank-handler
        (signal 'args-out-of-range
                (list string "yank-handler specified for empty string"))))
@end group
@group
  (if (fboundp 'menu-bar-update-yank-menu)
      (menu-bar-update-yank-menu string (and replace (car kill-ring))))
@end group
@group
  (if (and replace kill-ring)
      (setcar kill-ring string)
    (push string kill-ring)
    (if (> (length kill-ring) kill-ring-max)
        (setcdr (nthcdr (1- kill-ring-max) kill-ring) nil)))
@end group
@group
  (setq kill-ring-yank-pointer kill-ring)
  (if interprogram-cut-function
      (funcall interprogram-cut-function string (not replace))))
@end group
@end smallexample
@ignore
was:
(defun kill-new (string &optional replace)
  "Make STRING the latest kill in the kill ring.
Set the kill-ring-yank pointer to point to it.
If `interprogram-cut-function' is non-nil, apply it to STRING.
Optional second argument REPLACE non-nil means that STRING will replace
the front of the kill ring, rather than being added to the list."
  (and (fboundp 'menu-bar-update-yank-menu)
       (menu-bar-update-yank-menu string (and replace (car kill-ring))))
  (if (and replace kill-ring)
      (setcar kill-ring string)
    (setq kill-ring (cons string kill-ring))
    (if (> (length kill-ring) kill-ring-max)
        (setcdr (nthcdr (1- kill-ring-max) kill-ring) nil)))
  (setq kill-ring-yank-pointer kill-ring)
  (if interprogram-cut-function
      (funcall interprogram-cut-function string (not replace))))
@end ignore

(Notice that the function is not interactive.)

As usual, we can look at this function in parts.

The function definition has an optional @code{yank-handler} argument,
which when invoked tells the function how to deal with properties
added to the text, such as `bold' or `italics'.  We will skip that.

@need 1200
The first line of the documentation makes sense:

@smallexample
Make STRING the latest kill in the kill ring.
@end smallexample

@noindent
Let's skip over the rest of the documentation for the moment.

@noindent
Also, let's skip over the initial @code{if} expression and those lines
of code involving @code{menu-bar-update-yank-menu}.  We will explain
them below.

@need 1200
The critical lines are these:

@smallexample
@group
  (if (and replace kill-ring)
      ;; @r{then}
      (setcar kill-ring string)
@end group
@group
    ;; @r{else}
  (push string kill-ring)
@end group
@group
    (setq kill-ring (cons string kill-ring))
    (if (> (length kill-ring) kill-ring-max)
        ;; @r{avoid overly long kill ring}
        (setcdr (nthcdr (1- kill-ring-max) kill-ring) nil)))
@end group
@group
  (setq kill-ring-yank-pointer kill-ring)
  (if interprogram-cut-function
      (funcall interprogram-cut-function string (not replace))))
@end group
@end smallexample

The conditional test is @w{@code{(and replace kill-ring)}}.
This will be true when two conditions are met:  the kill ring has
something in it, and the @code{replace} variable is true.

@need 1250
When the @code{kill-append} function sets @code{replace} to be true
and when the kill ring has at least one item in it, the @code{setcar}
expression is executed:

@smallexample
(setcar kill-ring string)
@end smallexample

The @code{setcar} function actually changes the first element of the
@code{kill-ring} list to the value of @code{string}.  It replaces the
first element.

@need 1250
On the other hand, if the kill ring is empty, or replace is false, the
else-part of the condition is executed:

@smallexample
(push string kill-ring)
@end smallexample

@noindent
@need 1250
@code{push} puts its first argument onto the second.  It is similar to
the older

@smallexample
(setq kill-ring (cons string kill-ring))
@end smallexample

@noindent
@need 1250
or the newer

@smallexample
(add-to-list kill-ring string)
@end smallexample

@noindent
When it is false, the expression first constructs a new version of the
kill ring by prepending @code{string} to the existing kill ring as a
new element (that is what the @code{push} does).  Then it executes a
second @code{if} clause.  This second @code{if} clause keeps the kill
ring from growing too long.

Let's look at these two expressions in order.

The @code{push} line of the else-part sets the new value of the kill
ring to what results from adding the string being killed to the old
kill ring.

We can see how this works with an example.

@need 800
First,

@smallexample
(setq example-list '("here is a clause" "another clause"))
@end smallexample

@need 1200
@noindent
After evaluating this expression with @kbd{C-x C-e}, you can evaluate
@code{example-list} and see what it returns:

@smallexample
@group
example-list
     @result{} ("here is a clause" "another clause")
@end group
@end smallexample

@need 1200
@noindent
Now, we can add a new element on to this list by evaluating the
following expression:
@findex push, @r{example}

@smallexample
(push "a third clause" example-list)
@end smallexample

@need 800
@noindent
When we evaluate @code{example-list}, we find its value is:

@smallexample
@group
example-list
     @result{} ("a third clause" "here is a clause" "another clause")
@end group
@end smallexample

@noindent
Thus, the third clause is added to the list by @code{push}.

@need 1200
Now for the second part of the @code{if} clause.  This expression
keeps the kill ring from growing too long.  It looks like this:

@smallexample
@group
(if (> (length kill-ring) kill-ring-max)
    (setcdr (nthcdr (1- kill-ring-max) kill-ring) nil))
@end group
@end smallexample

The code checks whether the length of the kill ring is greater than
the maximum permitted length.  This is the value of
@code{kill-ring-max} (which is 60, by default).  If the length of the
kill ring is too long, then this code sets the last element of the
kill ring to @code{nil}.  It does this by using two functions,
@code{nthcdr} and @code{setcdr}.

We looked at @code{setcdr} earlier (@pxref{setcdr, , @code{setcdr}}).
It sets the @sc{cdr} of a list, just as @code{setcar} sets the
@sc{car} of a list.  In this case, however, @code{setcdr} will not be
setting the @sc{cdr} of the whole kill ring; the @code{nthcdr}
function is used to cause it to set the @sc{cdr} of the next to last
element of the kill ring---this means that since the @sc{cdr} of the
next to last element is the last element of the kill ring, it will set
the last element of the kill ring.

@findex nthcdr, @r{example}
The @code{nthcdr} function works by repeatedly taking the @sc{cdr} of a
list---it takes the @sc{cdr} of the @sc{cdr} of the @sc{cdr}
@dots{}  It does this @var{N} times and returns the results.
(@xref{nthcdr, , @code{nthcdr}}.)

@findex setcdr, @r{example}
Thus, if we had a four element list that was supposed to be three
elements long, we could set the @sc{cdr} of the next to last element
to @code{nil}, and thereby shorten the list.  (If you set the last
element to some other value than @code{nil}, which you could do, then
you would not have shortened the list.  @xref{setcdr, ,
@code{setcdr}}.)

You can see shortening by evaluating the following three expressions
in turn.  First set the value of @code{trees} to @code{(maple oak pine
birch)}, then set the @sc{cdr} of its second @sc{cdr} to @code{nil}
and then find the value of @code{trees}:

@smallexample
@group
(setq trees '(maple oak pine birch))
     @result{} (maple oak pine birch)
@end group

@group
(setcdr (nthcdr 2 trees) nil)
     @result{} nil

trees
     @result{} (maple oak pine)
@end group
@end smallexample

@noindent
(The value returned by the @code{setcdr} expression is @code{nil} since
that is what the @sc{cdr} is set to.)

To repeat, in @code{kill-new}, the @code{nthcdr} function takes the
@sc{cdr} a number of times that is one less than the maximum permitted
size of the kill ring and @code{setcdr} sets the @sc{cdr} of that
element (which will be the rest of the elements in the kill ring) to
@code{nil}.  This prevents the kill ring from growing too long.

@need 800
The next to last expression in the @code{kill-new} function is

@smallexample
(setq kill-ring-yank-pointer kill-ring)
@end smallexample

The @code{kill-ring-yank-pointer} is a global variable that is set to be
the @code{kill-ring}.

Even though the @code{kill-ring-yank-pointer} is called a
@samp{pointer}, it is a variable just like the kill ring.  However, the
name has been chosen to help humans understand how the variable is used.

@need 1200
Now, to return to an early expression in the body of the function:

@smallexample
@group
  (if (fboundp 'menu-bar-update-yank-menu)
       (menu-bar-update-yank-menu string (and replace (car kill-ring))))
@end group
@end smallexample

@noindent
It starts with an @code{if} expression

In this case, the expression tests first to see whether
@code{menu-bar-update-yank-menu} exists as a function, and if so,
calls it.  The @code{fboundp} function returns true if the symbol it
is testing has a function definition that `is not void'.  If the
symbol's function definition were void, we would receive an error
message, as we did when we created errors intentionally (@pxref{Making
Errors, , 에러 메시지 만들기}).

@noindent
The then-part contains an expression whose first element is the
function @code{and}.

@findex and
The @code{and} special form evaluates each of its arguments until one
of the arguments returns a value of @code{nil}, in which case the
@code{and} expression returns @code{nil}; however, if none of the
arguments returns a value of @code{nil}, the value resulting from
evaluating the last argument is returned.  (Since such a value is not
@code{nil}, it is considered true in Emacs Lisp.)  In other words, an
@code{and} expression returns a true value only if all its arguments
are true.  (@xref{Second Buffer Related Review}.)

The expression determines whether the second argument to
@code{menu-bar-update-yank-menu} is true or not.
@ignore
    ;; If we're supposed to be extending an existing string, and that
    ;; string really is at the front of the menu, then update it in place.
@end ignore

@code{menu-bar-update-yank-menu} is one of the functions that make it
possible to use the `Select and Paste' menu in the Edit item of a menu
bar; using a mouse, you can look at the various pieces of text you
have saved and select one piece to paste.

The last expression in the @code{kill-new} function adds the newly
copied string to whatever facility exists for copying and pasting
among different programs running in a windowing system.  In the X
Windowing system, for example, the @code{x-select-text} function takes
the string and stores it in memory operated by X.  You can paste the
string in another program, such as an Xterm.

@need 1200
The expression looks like this:

@smallexample
@group
  (if interprogram-cut-function
      (funcall interprogram-cut-function string (not replace))))
@end group
@end smallexample

If an @code{interprogram-cut-function} exists, then Emacs executes
@code{funcall}, which in turn calls its first argument as a function
and passes the remaining arguments to it.  (Incidentally, as far as I
can see, this @code{if} expression could be replaced by an @code{and}
expression similar to the one in the first part of the function.)

We are not going to discuss windowing systems and other programs
further, but merely note that this is a mechanism that enables GNU
Emacs to work easily and well with other programs.

This code for placing text in the kill ring, either concatenated with
an existing element or as a new element, leads us to the code for
bringing back text that has been cut out of the buffer---the yank
commands.  However, before discussing the yank commands, it is better
to learn how lists are implemented in a computer.  This will make
clear such mysteries as the use of the term `pointer'.  But before
that, we will digress into C.

@ignore
@c is this true in Emacs 22?   Does not seems to be

  (If the @w{@code{(< end beg))}}
expression is true, @code{kill-append} prepends the string to the just
previously clipped text.  For a detailed discussion, see
@ref{kill-append function, , The @code{kill-append} function}.)

If you then yank back the text, i.e., `paste' it, you get both
pieces of text at once.  That way, if you delete two words in a row,
and then yank them back, you get both words, in their proper order,
with one yank.  (The @w{@code{(< end beg))}} expression makes sure the
order is correct.)

On the other hand, if the previous command is not @code{kill-region},
then the @code{kill-new} function is called, which adds the text to
the kill ring as the latest item, and sets the
@code{kill-ring-yank-pointer} variable to point to it.
@end ignore
@ignore

@c Evidently, changed for Emacs 22. The zap-to-char command does not
@c use the delete-and-extract-region function

2006 Oct 26, the Digression into C is now OK but should come after
copy-region-as-kill and filter-buffer-substring

2006 Oct 24
In Emacs 22,
copy-region-as-kill is short, 12 lines, and uses
filter-buffer-substring, which is longer, 39 lines
and has delete-and-extract-region in it.
delete-and-extract-region is written in C.

see Initializing a Variable with @code{defvar}
@end ignore


@node Digression into C, defvar, copy-region-as-kill, Cutting & Storing Text
@comment  node-name,  next,  previous,  up
@section Digression into C
@findex delete-and-extract-region
@cindex C, a digression into
@cindex Digression into C

The @code{copy-region-as-kill} function (@pxref{copy-region-as-kill, ,
@code{copy-region-as-kill}}) uses the @code{filter-buffer-substring}
function, which in turn uses the @code{delete-and-extract-region}
function.  It removes the contents of a region and you cannot get them
back.

Unlike the other code discussed here, the
@code{delete-and-extract-region} function is not written in Emacs
Lisp; it is written in C and is one of the primitives of the GNU Emacs
system.  Since it is very simple, I will digress briefly from Lisp and
describe it here.

@c GNU Emacs 22  in /usr/local/src/emacs/src/editfns.c
@c the DEFUN for  buffer-substring-no-properties

@need 1500
Like many of the other Emacs primitives,
@code{delete-and-extract-region} is written as an instance of a C
macro, a macro being a template for code.  The complete macro looks
like this:

@smallexample
@group
DEFUN ("buffer-substring-no-properties", Fbuffer_substring_no_properties,
       Sbuffer_substring_no_properties, 2, 2, 0,
       doc: /* Return the characters of part of the buffer,
without the text properties.
The two arguments START and END are character positions;
they can be in either order.  */)
     (start, end)
     Lisp_Object start, end;
@{
  register int b, e;

  validate_region (&start, &end);
  b = XINT (start);
  e = XINT (end);

  return make_buffer_string (b, e, 0);
@}
@end group
@end smallexample

Without going into the details of the macro writing process, let me
point out that this macro starts with the word @code{DEFUN}.  The word
@code{DEFUN} was chosen since the code serves the same purpose as
@code{defun} does in Lisp.  (The @code{DEFUN} C macro is defined in
@file{emacs/src/lisp.h}.)

The word @code{DEFUN} is followed by seven parts inside of
parentheses:

@itemize @bullet
@item
The first part is the name given to the function in Lisp,
@code{delete-and-extract-region}.

@item
The second part is the name of the function in C,
@code{Fdelete_and_extract_region}.  By convention, it starts with
@samp{F}.  Since C does not use hyphens in names, underscores are used
instead.

@item
The third part is the name for the C constant structure that records
information on this function for internal use.  It is the name of the
function in C but begins with an @samp{S} instead of an @samp{F}.

@item
The fourth and fifth parts specify the minimum and maximum number of
arguments the function can have.  This function demands exactly 2
arguments.

@item
The sixth part is nearly like the argument that follows the
@code{interactive} declaration in a function written in Lisp: a letter
followed, perhaps, by a prompt.  The only difference from the Lisp is
when the macro is called with no arguments.  Then you write a @code{0}
(which is a `null string'), as in this macro.

If you were to specify arguments, you would place them between
quotation marks.  The C macro for @code{goto-char} includes
@code{"NGoto char: "} in this position to indicate that the function
expects a raw prefix, in this case, a numerical location in a buffer,
and provides a prompt.

@item
The seventh part is a documentation string, just like the one for a
function written in Emacs Lisp, except that every newline must be
written explicitly as @samp{\n} followed by a backslash and carriage
return.

@need 1000
Thus, the first two lines of documentation for  @code{goto-char} are
written like this:

@smallexample
@group
  "Set point to POSITION, a number or marker.\n\
Beginning of buffer is position (point-min), end is (point-max)."
@end group
@end smallexample
@end itemize

@need 1200
In a C macro, the formal parameters come next, with a statement of
what kind of object they are, followed by what might be called the `body'
of the macro.  For @code{delete-and-extract-region} the `body'
consists of the following four lines:

@smallexample
@group
validate_region (&start, &end);
if (XINT (start) == XINT (end))
  return build_string ("");
return del_range_1 (XINT (start), XINT (end), 1, 1);
@end group
@end smallexample

The   @code{validate_region} function checks whether the values
passed as the beginning and end of the region are the proper type and
are within range.  If the beginning and end positions are the same,
then return and empty string.

The @code{del_range_1} function actually deletes the text.  It is a
complex function we will not look into.  It updates the buffer and
does other things.  However, it is worth looking at the two arguments
passed to @code{del_range}.  These are @w{@code{XINT (start)}} and
@w{@code{XINT (end)}}.

As far as the C language is concerned, @code{start} and @code{end} are
two integers that mark the beginning and end of the region to be
deleted@footnote{More precisely, and requiring more expert knowledge
to understand, the two integers are of type `Lisp_Object', which can
also be a C union instead of an integer type.}.

In early versions of Emacs, these two numbers were thirty-two bits
long, but the code is slowly being generalized to handle other
lengths.  Three of the available bits are used to specify the type of
information; the remaining bits are used as `content'.

@samp{XINT} is a C macro that extracts the relevant number from the
longer collection of bits; the three other bits are discarded.

@need 800
The command in @code{delete-and-extract-region} looks like this:

@smallexample
del_range_1 (XINT (start), XINT (end), 1, 1);
@end smallexample

@noindent
It deletes the region between the beginning position, @code{start},
and the ending position, @code{end}.

From the point of view of the person writing Lisp, Emacs is all very
simple; but hidden underneath is a great deal of complexity to make it
all work.


@node defvar, cons & search-fwd Review, Digression into C, Cutting & Storing Text
@comment  node-name,  next,  previous,  up
@section Initializing a Variable with @code{defvar}
@findex defvar
@cindex Initializing a variable
@cindex Variable initialization

@ignore
2006 Oct 24
In Emacs 22,
copy-region-as-kill is short, 12 lines, and uses
filter-buffer-substring, which is longer, 39 lines
and has delete-and-extract-region in it.
delete-and-extract-region is written in C.

see Initializing a Variable with @code{defvar}

@end ignore

The @code{copy-region-as-kill} function is written in Emacs Lisp.  Two
functions within it, @code{kill-append} and @code{kill-new}, copy a
region in a buffer and save it in a variable called the
@code{kill-ring}.  This section describes how the @code{kill-ring}
variable is created and initialized using the @code{defvar} special
form.

(Again we note that the term @code{kill-ring} is a misnomer.  The text
that is clipped out of the buffer can be brought back; it is not a ring
of corpses, but a ring of resurrectable text.)

In Emacs Lisp, a variable such as the @code{kill-ring} is created and
given an initial value by using the @code{defvar} special form.  The
name comes from ``define variable''.

The @code{defvar} special form is similar to @code{setq} in that it sets
the value of a variable.  It is unlike @code{setq} in two ways: first,
it only sets the value of the variable if the variable does not already
have a value.  If the variable already has a value, @code{defvar} does
not override the existing value.  Second, @code{defvar} has a
documentation string.

(Another special form, @code{defcustom}, is designed for variables
that people customize.  It has more features than @code{defvar}.
(@xref{defcustom, , Setting Variables with @code{defcustom}}.)

@menu
* See variable current value::
* defvar and asterisk::
@end menu

@node See variable current value, defvar and asterisk, defvar, defvar
@ifnottex
@unnumberedsubsec Seeing the Current Value of a Variable
@end ifnottex

You can see the current value of a variable, any variable, by using
the @code{describe-variable} function, which is usually invoked by
typing @kbd{C-h v}.  If you type @kbd{C-h v} and then @code{kill-ring}
(followed by @key{RET}) when prompted, you will see what is in your
current kill ring---this may be quite a lot!  Conversely, if you have
been doing nothing this Emacs session except read this document, you
may have nothing in it.  Also, you will see the documentation for
@code{kill-ring}:

@smallexample
@group
Documentation:
List of killed text sequences.
Since the kill ring is supposed to interact nicely with cut-and-paste
facilities offered by window systems, use of this variable should
@end group
@group
interact nicely with `interprogram-cut-function' and
`interprogram-paste-function'.  The functions `kill-new',
`kill-append', and `current-kill' are supposed to implement this
interaction; you may want to use them instead of manipulating the kill
ring directly.
@end group
@end smallexample

@need 800
The kill ring is defined by a @code{defvar} in the following way:

@smallexample
@group
(defvar kill-ring nil
  "List of killed text sequences.
@dots{}")
@end group
@end smallexample

@noindent
In this variable definition, the variable is given an initial value of
@code{nil}, which makes sense, since if you have saved nothing, you want
nothing back if you give a @code{yank} command.  The documentation
string is written just like the documentation string of a @code{defun}.
As with the documentation string of the @code{defun}, the first line of
the documentation should be a complete sentence, since some commands,
like @code{apropos}, print only the first line of documentation.
Succeeding lines should not be indented; otherwise they look odd when
you use @kbd{C-h v} (@code{describe-variable}).

@node defvar and asterisk,  , See variable current value, defvar
@subsection @code{defvar} and an asterisk
@findex defvar @r{for a user customizable variable}
@findex defvar @r{with an asterisk}

In the past, Emacs used the @code{defvar} special form both for
internal variables that you would not expect a user to change and for
variables that you do expect a user to change.  Although you can still
use @code{defvar} for user customizable variables, please use
@code{defcustom} instead, since that special form provides a path into
the Customization commands.  (@xref{defcustom, , Specifying Variables
using @code{defcustom}}.)

When you specified a variable using the @code{defvar} special form,
you could distinguish a variable that a user might want to change from
others by typing an asterisk, @samp{*}, in the first column of its
documentation string.  For example:

@smallexample
@group
(defvar shell-command-default-error-buffer nil
  "*Buffer name for `shell-command' @dots{} error output.
@dots{} ")
@end group
@end smallexample

@findex set-variable
@noindent
You could (and still can) use the @code{set-variable} command to
change the value of @code{shell-command-default-error-buffer}
temporarily.  However, options set using @code{set-variable} are set
only for the duration of your editing session.  The new values are not
saved between sessions.  Each time Emacs starts, it reads the original
value, unless you change the value within your @file{.emacs} file,
either by setting it manually or by using @code{customize}.
@xref{Emacs Initialization, , Your @file{.emacs} File}.

For me, the major use of the @code{set-variable} command is to suggest
variables that I might want to set in my @file{.emacs} file.  There
are now more than 700 such variables --- far too many to remember
readily.  Fortunately, you can press @key{TAB} after calling the
@code{M-x set-variable} command to see the list of variables.
(@xref{Examining, , Examining and Setting Variables, emacs,
The GNU Emacs Manual}.)


@need 1250
@node cons & search-fwd Review, search Exercises, defvar, Cutting & Storing Text
@comment  node-name,  next,  previous,  up
@section Review

Here is a brief summary of some recently introduced functions.

@table @code
@item car
@itemx cdr
@code{car} returns the first element of a list; @code{cdr} returns the
second and subsequent elements of a list.

@need 1250
For example:

@smallexample
@group
(car '(1 2 3 4 5 6 7))
     @result{} 1
(cdr '(1 2 3 4 5 6 7))
     @result{} (2 3 4 5 6 7)
@end group
@end smallexample

@item cons
@code{cons} constructs a list by prepending its first argument to its
second argument.

@need 1250
For example:

@smallexample
@group
(cons 1 '(2 3 4))
     @result{} (1 2 3 4)
@end group
@end smallexample

@item funcall
@code{funcall} evaluates its first argument as a function.  It passes
its remaining arguments to its first argument.

@item nthcdr
Return the result of taking @sc{cdr} `n' times on a list.
@iftex
The
@tex
$n^{th}$
@end tex
@code{cdr}.
@end iftex
The `rest of the rest', as it were.

@need 1250
For example:

@smallexample
@group
(nthcdr 3 '(1 2 3 4 5 6 7))
     @result{} (4 5 6 7)
@end group
@end smallexample

@item setcar
@itemx setcdr
@code{setcar} changes the first element of a list; @code{setcdr}
changes the second and subsequent elements of a list.

@need 1250
For example:

@smallexample
@group
(setq triple '(1 2 3))

(setcar triple '37)

triple
     @result{} (37 2 3)

(setcdr triple '("foo" "bar"))

triple
     @result{} (37 "foo" "bar")
@end group
@end smallexample

@item progn
Evaluate each argument in sequence and then return the value of the
last.

@need 1250
For example:

@smallexample
@group
(progn 1 2 3 4)
     @result{} 4
@end group
@end smallexample

@item save-restriction
Record whatever narrowing is in effect in the current buffer, if any,
and restore that narrowing after evaluating the arguments.

@item search-forward
Search for a string, and if the string is found, move point.  With a
regular expression, use the similar @code{re-search-forward}.
(@xref{Regexp Search, , Regular Expression Searches}, for an
explanation of regular expression patterns and searches.)

@need 1250
@noindent
@code{search-forward} and @code{re-search-forward} take four
arguments:

@enumerate
@item
The string or regular expression to search for.

@item
Optionally, the limit of the search.

@item
Optionally, what to do if the search fails, return @code{nil} or an
error message.

@item
Optionally, how many times to repeat the search; if negative, the
search goes backwards.
@end enumerate

@item kill-region
@itemx delete-and-extract-region
@itemx copy-region-as-kill

@code{kill-region} cuts the text between point and mark from the
buffer and stores that text in the kill ring, so you can get it back
by yanking.

@code{copy-region-as-kill} copies the text between point and mark into
the kill ring, from which you can get it by yanking.  The function
does not cut or remove the text from the buffer.
@end table

@code{delete-and-extract-region} removes the text between point and
mark from the buffer and throws it away.  You cannot get it back.
(This is not an interactive command.)


@need 1500
@node search Exercises,  , cons & search-fwd Review, Cutting & Storing Text
@section Searching Exercises

@itemize @bullet
@item
Write an interactive function that searches for a string.  If the
search finds the string, leave point after it and display a message
that says ``Found!''.  (Do not use @code{search-forward} for the name
of this function; if you do, you will overwrite the existing version of
@code{search-forward} that comes with Emacs.  Use a name such as
@code{test-search} instead.)

@item
Write a function that prints the third element of the kill ring in the
echo area, if any; if the kill ring does not contain a third element,
print an appropriate message.
@end itemize


@node List Implementation, Yanking, Cutting & Storing Text, Top
@comment  node-name,  next,  previous,  up
@chapter How Lists are Implemented
@cindex Lists in a computer

In Lisp, atoms are recorded in a straightforward fashion; if the
implementation is not straightforward in practice, it is, nonetheless,
straightforward in theory.  The atom @samp{rose}, for example, is
recorded as the four contiguous letters @samp{r}, @samp{o}, @samp{s},
@samp{e}.  A list, on the other hand, is kept differently.  The mechanism
is equally simple, but it takes a moment to get used to the idea.  A
list is kept using a series of pairs of pointers.  In the series, the
first pointer in each pair points to an atom or to another list, and the
second pointer in each pair points to the next pair, or to the symbol
@code{nil}, which marks the end of the list.

A pointer itself is quite simply the electronic address of what is
pointed to.  Hence, a list is kept as a series of electronic addresses.

@menu
* Lists diagrammed::
* Symbols as Chest::            Exploring a powerful metaphor.
* List Exercise::
@end menu

@node Lists diagrammed, Symbols as Chest, List Implementation, List Implementation
@ifnottex
@unnumberedsec Lists diagrammed
@end ifnottex

For example, the list @code{(rose violet buttercup)} has three elements,
@samp{rose}, @samp{violet}, and @samp{buttercup}.  In the computer, the
electronic address of @samp{rose} is recorded in a segment of computer
memory along with the address that gives the electronic address of where
the atom @samp{violet} is located; and that address (the one that tells
where @samp{violet} is located) is kept along with an address that tells
where the address for the atom @samp{buttercup} is located.

@need 1200
This sounds more complicated than it is and is easier seen in a diagram:

@c clear print-postscript-figures
@c !!! cons-cell-diagram #1
@ifnottex
@smallexample
@group
    ___ ___      ___ ___      ___ ___
   |___|___|--> |___|___|--> |___|___|--> nil
     |            |            |
     |            |            |
      --> rose     --> violet   --> buttercup
@end group
@end smallexample
@end ifnottex
@ifset print-postscript-figures
@sp 1
@tex
@center @image{cons-1}
%%%% old method of including an image
% \input /usr/local/lib/tex/inputs/psfig.tex
% \centerline{\psfig{figure=/usr/local/lib/emacs/man/cons-1.eps}}
% \catcode`\@=0 %
@end tex
@sp 1
@end ifset
@ifclear print-postscript-figures
@iftex
@smallexample
@group
    ___ ___      ___ ___      ___ ___
   |___|___|--> |___|___|--> |___|___|--> nil
     |            |            |
     |            |            |
      --> rose     --> violet   --> buttercup
@end group
@end smallexample
@end iftex
@end ifclear

@noindent
In the diagram, each box represents a word of computer memory that
holds a Lisp object, usually in the form of a memory address.  The boxes,
i.e.@: the addresses, are in pairs.  Each arrow points to what the address
is the address of, either an atom or another pair of addresses.  The
first box is the electronic address of @samp{rose} and the arrow points
to @samp{rose}; the second box is the address of the next pair of boxes,
the first part of which is the address of @samp{violet} and the second
part of which is the address of the next pair.  The very last box
points to the symbol @code{nil}, which marks the end of the list.

@need 1200
When a variable is set to a list with a function such as @code{setq},
it stores the address of the first box in the variable.  Thus,
evaluation of the expression

@smallexample
(setq bouquet '(rose violet buttercup))
@end smallexample

@need 1250
@noindent
creates a situation like this:

@c cons-cell-diagram #2
@ifnottex
@smallexample
@group
bouquet
     |
     |     ___ ___      ___ ___      ___ ___
      --> |___|___|--> |___|___|--> |___|___|--> nil
            |            |            |
            |            |            |
             --> rose     --> violet   --> buttercup
@end group
@end smallexample
@end ifnottex
@ifset print-postscript-figures
@sp 1
@tex
@center @image{cons-2}
%%%% old method of including an image
% \input /usr/local/lib/tex/inputs/psfig.tex
% \centerline{\psfig{figure=/usr/local/lib/emacs/man/cons-2.eps}}
% \catcode`\@=0 %
@end tex
@sp 1
@end ifset
@ifclear print-postscript-figures
@iftex
@smallexample
@group
bouquet
     |
     |     ___ ___      ___ ___      ___ ___
      --> |___|___|--> |___|___|--> |___|___|--> nil
            |            |            |
            |            |            |
             --> rose     --> violet   --> buttercup
@end group
@end smallexample
@end iftex
@end ifclear

@noindent
In this example, the symbol @code{bouquet} holds the address of the first
pair of boxes.

@need 1200
This same list can be illustrated in a different sort of box notation
like this:

@c cons-cell-diagram #2a
@ifnottex
@smallexample
@group
bouquet
 |
 |    --------------       ---------------       ----------------
 |   | car   | cdr  |     | car    | cdr  |     | car     | cdr  |
  -->| rose  |   o------->| violet |   o------->| butter- |  nil |
     |       |      |     |        |      |     | cup     |      |
      --------------       ---------------       ----------------
@end group
@end smallexample
@end ifnottex
@ifset print-postscript-figures
@sp 1
@tex
@center @image{cons-2a}
%%%% old method of including an image
% \input /usr/local/lib/tex/inputs/psfig.tex
% \centerline{\psfig{figure=/usr/local/lib/emacs/man/cons-2a.eps}}
% \catcode`\@=0 %
@end tex
@sp 1
@end ifset
@ifclear print-postscript-figures
@iftex
@smallexample
@group
bouquet
 |
 |    --------------       ---------------       ----------------
 |   | car   | cdr  |     | car    | cdr  |     | car     | cdr  |
  -->| rose  |   o------->| violet |   o------->| butter- |  nil |
     |       |      |     |        |      |     | cup     |      |
      --------------       ---------------       ----------------
@end group
@end smallexample
@end iftex
@end ifclear

(Symbols consist of more than pairs of addresses, but the structure of
a symbol is made up of addresses.  Indeed, the symbol @code{bouquet}
consists of a group of address-boxes, one of which is the address of
the printed word @samp{bouquet}, a second of which is the address of a
function definition attached to the symbol, if any, a third of which
is the address of the first pair of address-boxes for the list
@code{(rose violet buttercup)}, and so on.  Here we are showing that
the symbol's third address-box points to the first pair of
address-boxes for the list.)

If a symbol is set to the @sc{cdr} of a list, the list itself is not
changed; the symbol simply has an address further down the list.  (In
the jargon, @sc{car} and @sc{cdr} are `non-destructive'.)  Thus,
evaluation of the following expression

@smallexample
(setq flowers (cdr bouquet))
@end smallexample

@need 800
@noindent
produces this:

@c cons-cell-diagram #3
@ifnottex
@sp 1
@smallexample
@group
bouquet        flowers
  |              |
  |     ___ ___  |     ___ ___      ___ ___
   --> |   |   |  --> |   |   |    |   |   |
       |___|___|----> |___|___|--> |___|___|--> nil
         |              |            |
         |              |            |
          --> rose       --> violet   --> buttercup
@end group
@end smallexample
@sp 1
@end ifnottex
@ifset print-postscript-figures
@sp 1
@tex
@center @image{cons-3}
%%%% old method of including an image
% \input /usr/local/lib/tex/inputs/psfig.tex
% \centerline{\psfig{figure=/usr/local/lib/emacs/man/cons-3.eps}}
% \catcode`\@=0 %
@end tex
@sp 1
@end ifset
@ifclear print-postscript-figures
@iftex
@sp 1
@smallexample
@group
bouquet        flowers
  |              |
  |     ___ ___  |     ___ ___      ___ ___
   --> |   |   |  --> |   |   |    |   |   |
       |___|___|----> |___|___|--> |___|___|--> nil
         |              |            |
         |              |            |
          --> rose       --> violet   --> buttercup
@end group
@end smallexample
@sp 1
@end iftex
@end ifclear

@noindent
The value of @code{flowers} is @code{(violet buttercup)}, which is
to say, the symbol @code{flowers} holds the address of the pair of
address-boxes, the first of which holds the address of @code{violet},
and the second of which holds the address of @code{buttercup}.

A pair of address-boxes is called a @dfn{cons cell} or @dfn{dotted
pair}.  @xref{Cons Cell Type, , Cons Cell and List Types, elisp, The GNU Emacs Lisp
Reference Manual}, and @ref{Dotted Pair Notation, , Dotted Pair
Notation, elisp, The GNU Emacs Lisp Reference Manual}, for more
information about cons cells and dotted pairs.

@need 1200
The function @code{cons} adds a new pair of addresses to the front of
a series of addresses like that shown above.  For example, evaluating
the expression

@smallexample
(setq bouquet (cons 'lily bouquet))
@end smallexample

@need 1500
@noindent
produces:

@c cons-cell-diagram #4
@ifnottex
@sp 1
@smallexample
@group
bouquet                       flowers
  |                             |
  |     ___ ___        ___ ___  |     ___ ___       ___ ___
   --> |   |   |      |   |   |  --> |   |   |     |   |   |
       |___|___|----> |___|___|----> |___|___|---->|___|___|--> nil
         |              |              |             |
         |              |              |             |
          --> lily      --> rose       --> violet    --> buttercup
@end group
@end smallexample
@sp 1
@end ifnottex
@ifset print-postscript-figures
@sp 1
@tex
@center @image{cons-4}
%%%% old method of including an image
% \input /usr/local/lib/tex/inputs/psfig.tex
% \centerline{\psfig{figure=/usr/local/lib/emacs/man/cons-4.eps}}
% \catcode`\@=0 %
@end tex
@sp 1
@end ifset
@ifclear print-postscript-figures
@iftex
@sp 1
@smallexample
@group
bouquet                       flowers
  |                             |
  |     ___ ___        ___ ___  |     ___ ___       ___ ___
   --> |   |   |      |   |   |  --> |   |   |     |   |   |
       |___|___|----> |___|___|----> |___|___|---->|___|___|--> nil
         |              |              |             |
         |              |              |             |
          --> lily      --> rose       --> violet    --> buttercup
@end group
@end smallexample
@sp 1
@end iftex
@end ifclear

@need 1200
@noindent
However, this does not change the value of the symbol
@code{flowers}, as you can see by evaluating the following,

@smallexample
(eq (cdr (cdr bouquet)) flowers)
@end smallexample

@noindent
which returns @code{t} for true.

Until it is reset, @code{flowers} still has the value
@code{(violet buttercup)}; that is, it has the address of the cons
cell whose first address is of @code{violet}.  Also, this does not
alter any of the pre-existing cons cells; they are all still there.

Thus, in Lisp, to get the @sc{cdr} of a list, you just get the address
of the next cons cell in the series; to get the @sc{car} of a list,
you get the address of the first element of the list; to @code{cons} a
new element on a list, you add a new cons cell to the front of the list.
That is all there is to it!  The underlying structure of Lisp is
brilliantly simple!

And what does the last address in a series of cons cells refer to?  It
is the address of the empty list, of @code{nil}.

In summary, when a Lisp variable is set to a value, it is provided with
the address of the list to which the variable refers.


@node Symbols as Chest, List Exercise, Lists diagrammed, List Implementation
@section Symbols as a Chest of Drawers
@cindex Symbols as a Chest of Drawers
@cindex Chest of Drawers, metaphor for a symbol
@cindex Drawers, Chest of, metaphor for a symbol

In an earlier section, I suggested that you might imagine a symbol as
being a chest of drawers.  The function definition is put in one
drawer, the value in another, and so on.  What is put in the drawer
holding the value can be changed without affecting the contents of the
drawer holding the function definition, and vice-verse.

Actually, what is put in each drawer is the address of the value or
function definition.  It is as if you found an old chest in the attic,
and in one of its drawers you found a map giving you directions to
where the buried treasure lies.

(In addition to its name, symbol definition, and variable value, a
symbol has a `drawer' for a @dfn{property list} which can be used to
record other information.  Property lists are not discussed here; see
@ref{Property Lists, , Property Lists, elisp, The GNU Emacs Lisp
Reference Manual}.)

@need 1500
Here is a fanciful representation:

@c chest-of-drawers diagram
@ifnottex
@sp 1
@smallexample
@group
            Chest of Drawers            Contents of Drawers

            __   o0O0o   __
          /                 \
         ---------------------
        |    directions to    |            [map to]
        |     symbol name     |             bouquet
        |                     |
        +---------------------+
        |    directions to    |
        |  symbol definition  |             [none]
        |                     |
        +---------------------+
        |    directions to    |            [map to]
        |    variable value   |             (rose violet buttercup)
        |                     |
        +---------------------+
        |    directions to    |
        |    property list    |             [not described here]
        |                     |
        +---------------------+
        |/                   \|
@end group
@end smallexample
@sp 1
@end ifnottex
@ifset print-postscript-figures
@sp 1
@tex
@center @image{drawers}
%%%% old method of including an image
% \input /usr/local/lib/tex/inputs/psfig.tex
% \centerline{\psfig{figure=/usr/local/lib/emacs/man/drawers.eps}}
% \catcode`\@=0 %
@end tex
@sp 1
@end ifset
@ifclear print-postscript-figures
@iftex
@sp 1
@smallexample
@group
            Chest of Drawers            Contents of Drawers

            __   o0O0o   __
          /                 \
         ---------------------
        |    directions to    |            [map to]
        |     symbol name     |             bouquet
        |                     |
        +---------------------+
        |    directions to    |
        |  symbol definition  |             [none]
        |                     |
        +---------------------+
        |    directions to    |            [map to]
        |    variable value   |             (rose violet buttercup)
        |                     |
        +---------------------+
        |    directions to    |
        |    property list    |             [not described here]
        |                     |
        +---------------------+
        |/                   \|
@end group
@end smallexample
@sp 1
@end iftex
@end ifclear


@node List Exercise,  , Symbols as Chest, List Implementation
@section Exercise

Set @code{flowers} to @code{violet} and @code{buttercup}.  Cons two
more flowers on to this list and set this new list to
@code{more-flowers}.  Set the @sc{car} of @code{flowers} to a fish.
What does the @code{more-flowers} list now contain?


@node Yanking, Loops & Recursion, List Implementation, Top
@comment  node-name,  next,  previous,  up
@chapter Yanking Text Back
@findex yank
@cindex Text retrieval
@cindex Retrieving text
@cindex Pasting text

Whenever you cut text out of a buffer with a `kill' command in GNU Emacs,
you can bring it back with a `yank' command.  The text that is cut out of
the buffer is put in the kill ring and the yank commands insert the
appropriate contents of the kill ring back into a buffer (not necessarily
the original buffer).

A simple @kbd{C-y} (@code{yank}) command inserts the first item from
the kill ring into the current buffer.  If the @kbd{C-y} command is
followed immediately by @kbd{M-y}, the first element is replaced by
the second element.  Successive @kbd{M-y} commands replace the second
element with the third, fourth, or fifth element, and so on.  When the
last element in the kill ring is reached, it is replaced by the first
element and the cycle is repeated.  (Thus the kill ring is called a
`ring' rather than just a `list'.  However, the actual data structure
that holds the text is a list.
@xref{Kill Ring, , Handling the Kill Ring}, for the details of how the
list is handled as a ring.)

@menu
* Kill Ring Overview::
* kill-ring-yank-pointer::      The kill ring is a list.
* yank nthcdr Exercises::       The @code{kill-ring-yank-pointer} variable.
@end menu


@node Kill Ring Overview, kill-ring-yank-pointer, Yanking, Yanking
@comment  node-name,  next,  previous,  up
@section Kill Ring Overview
@cindex Kill ring overview

The kill ring is a list of textual strings.  This is what it looks like:

@smallexample
("some text" "a different piece of text" "yet more text")
@end smallexample

If this were the contents of my kill ring and I pressed @kbd{C-y}, the
string of characters saying @samp{some text} would be inserted in this
buffer where my cursor is located.

The @code{yank} command is also used for duplicating text by copying it.
The copied text is not cut from the buffer, but a copy of it is put on the
kill ring and is inserted by yanking it back.

Three functions are used for bringing text back from the kill ring:
@code{yank}, which is usually bound to @kbd{C-y}; @code{yank-pop},
which is usually bound to @kbd{M-y}; and @code{rotate-yank-pointer},
which is used by the two other functions.

These functions refer to the kill ring through a variable called the
@code{kill-ring-yank-pointer}.  Indeed, the insertion code for both the
@code{yank} and @code{yank-pop} functions is:

@smallexample
(insert (car kill-ring-yank-pointer))
@end smallexample

@noindent
(Well, no more.  In GNU Emacs 22, the function has been replaced by
@code{insert-for-yank} which calls @code{insert-for-yank-1}
repetitively for each @code{yank-handler} segment.  In turn,
@code{insert-for-yank-1} strips text properties from the inserted text
according to @code{yank-excluded-properties}.  Otherwise, it is just
like @code{insert}.  We will stick with plain @code{insert} since it
is easier to understand.)

To begin to understand how @code{yank} and @code{yank-pop} work, it is
first necessary to look at the @code{kill-ring-yank-pointer} variable.


@node kill-ring-yank-pointer, yank nthcdr Exercises, Kill Ring Overview, Yanking
@comment  node-name,  next,  previous,  up
@section The @code{kill-ring-yank-pointer} Variable

@code{kill-ring-yank-pointer} is a variable, just as @code{kill-ring} is
a variable.  It points to something by being bound to the value of what
it points to, like any other Lisp variable.

@need 1000
Thus, if the value of the kill ring is:

@smallexample
("some text" "a different piece of text" "yet more text")
@end smallexample

@need 1250
@noindent
and the @code{kill-ring-yank-pointer} points to the second clause, the
value of @code{kill-ring-yank-pointer} is:

@smallexample
("a different piece of text" "yet more text")
@end smallexample

As explained in the previous chapter (@pxref{List Implementation}), the
computer does not keep two different copies of the text being pointed to
by both the @code{kill-ring} and the @code{kill-ring-yank-pointer}.  The
words ``a different piece of text'' and ``yet more text'' are not
duplicated.  Instead, the two Lisp variables point to the same pieces of
text.  Here is a diagram:

@c cons-cell-diagram #5
@ifnottex
@smallexample
@group
kill-ring     kill-ring-yank-pointer
    |               |
    |      ___ ___  |     ___ ___      ___ ___
     ---> |   |   |  --> |   |   |    |   |   |
          |___|___|----> |___|___|--> |___|___|--> nil
            |              |            |
            |              |            |
            |              |             --> "yet more text"
            |              |
            |               --> "a different piece of text"
            |
             --> "some text"
@end group
@end smallexample
@sp 1
@end ifnottex
@ifset print-postscript-figures
@sp 1
@tex
@center @image{cons-5}
%%%% old method of including an image
% \input /usr/local/lib/tex/inputs/psfig.tex
% \centerline{\psfig{figure=/usr/local/lib/emacs/man/cons-5.eps}}
% \catcode`\@=0 %
@end tex
@sp 1
@end ifset
@ifclear print-postscript-figures
@iftex
@smallexample
@group
kill-ring     kill-ring-yank-pointer
    |               |
    |      ___ ___  |     ___ ___      ___ ___
     ---> |   |   |  --> |   |   |    |   |   |
          |___|___|----> |___|___|--> |___|___|--> nil
            |              |            |
            |              |            |
            |              |             --> "yet more text"
            |              |
            |               --> "a different piece of text
            |
             --> "some text"
@end group
@end smallexample
@sp 1
@end iftex
@end ifclear

Both the variable @code{kill-ring} and the variable
@code{kill-ring-yank-pointer} are pointers.  But the kill ring itself is
usually described as if it were actually what it is composed of.  The
@code{kill-ring} is spoken of as if it were the list rather than that it
points to the list.  Conversely, the @code{kill-ring-yank-pointer} is
spoken of as pointing to a list.

These two ways of talking about the same thing sound confusing at first but
make sense on reflection.  The kill ring is generally thought of as the
complete structure of data that holds the information of what has recently
been cut out of the Emacs buffers.  The @code{kill-ring-yank-pointer}
on the other hand, serves to indicate---that is, to `point to'---that part
of the kill ring of which the first element (the @sc{car}) will be
inserted.

@ignore
In GNU Emacs 22, the @code{kill-new} function calls

@code{(setq kill-ring-yank-pointer kill-ring)}

(defun rotate-yank-pointer (arg)
  "Rotate the yanking point in the kill ring.
With argument, rotate that many kills forward (or backward, if negative)."
  (interactive "p")
  (current-kill arg))

(defun current-kill (n &optional do-not-move)
  "Rotate the yanking point by N places, and then return that kill.
If N is zero, `interprogram-paste-function' is set, and calling it
returns a string, then that string is added to the front of the
kill ring and returned as the latest kill.
If optional arg DO-NOT-MOVE is non-nil, then don't actually move the
yanking point; just return the Nth kill forward."
  (let ((interprogram-paste (and (= n 0)
                                 interprogram-paste-function
                                 (funcall interprogram-paste-function))))
    (if interprogram-paste
        (progn
          ;; Disable the interprogram cut function when we add the new
          ;; text to the kill ring, so Emacs doesn't try to own the
          ;; selection, with identical text.
          (let ((interprogram-cut-function nil))
            (kill-new interprogram-paste))
          interprogram-paste)
      (or kill-ring (error "Kill ring is empty"))
      (let ((ARGth-kill-element
             (nthcdr (mod (- n (length kill-ring-yank-pointer))
                          (length kill-ring))
                     kill-ring)))
        (or do-not-move
            (setq kill-ring-yank-pointer ARGth-kill-element))
        (car ARGth-kill-element)))))

@end ignore


@need 1500
@node yank nthcdr Exercises,  , kill-ring-yank-pointer, Yanking
@section Exercises with @code{yank} and @code{nthcdr}

@itemize @bullet
@item
Using @kbd{C-h v} (@code{describe-variable}), look at the value of
your kill ring.  Add several items to your kill ring; look at its
value again.  Using @kbd{M-y} (@code{yank-pop)}, move all the way
around the kill ring.  How many items were in your kill ring?  Find
the value of @code{kill-ring-max}.  Was your kill ring full, or could
you have kept more blocks of text within it?

@item
Using @code{nthcdr} and @code{car}, construct a series of expressions
to return the first, second, third, and fourth elements of a list.
@end itemize


@node Loops & Recursion, Regexp Search, Yanking, Top
@comment  node-name,  next,  previous,  up
@chapter Loops and Recursion
@cindex Loops and recursion
@cindex Recursion and loops
@cindex Repetition (loops)

Emacs Lisp has two primary ways to cause an expression, or a series of
expressions, to be evaluated repeatedly: one uses a @code{while}
loop, and the other uses @dfn{recursion}.

Repetition can be very valuable.  For example, to move forward four
sentences, you need only write a program that will move forward one
sentence and then repeat the process four times.  Since a computer does
not get bored or tired, such repetitive action does not have the
deleterious effects that excessive or the wrong kinds of repetition can
have on humans.

People mostly write Emacs Lisp functions using @code{while} loops and
their kin; but you can use recursion, which provides a very powerful
way to think about and then to solve problems@footnote{You can write
recursive functions to be frugal or wasteful of mental or computer
resources; as it happens, methods that people find easy---that are
frugal of `mental resources'---sometimes use considerable computer
resources.  Emacs was designed to run on machines that we now consider
limited and its default settings are conservative.  You may want to
increase the values of @code{max-specpdl-size} and
@code{max-lisp-eval-depth}.  In my @file{.emacs} file, I set them to
15 and 30 times their default value.}.

@menu
* while::                       Causing a stretch of code to repeat.
* dolist dotimes::
* Recursion::                   Causing a function to call itself.
* Looping exercise::
@end menu


@node while, dolist dotimes, Loops & Recursion, Loops & Recursion
@comment  node-name,  next,  previous,  up
@section @code{while}
@cindex Loops
@findex while

The @code{while} special form tests whether the value returned by
evaluating its first argument is true or false.  This is similar to what
the Lisp interpreter does with an @code{if}; what the interpreter does
next, however, is different.

In a @code{while} expression, if the value returned by evaluating the
first argument is false, the Lisp interpreter skips the rest of the
expression (the @dfn{body} of the expression) and does not evaluate it.
However, if the value is true, the Lisp interpreter evaluates the body
of the expression and then again tests whether the first argument to
@code{while} is true or false.  If the value returned by evaluating the
first argument is again true, the Lisp interpreter again evaluates the
body of the expression.

@need 1200
The template for a @code{while} expression looks like this:

@smallexample
@group
(while @var{true-or-false-test}
  @var{body}@dots{})
@end group
@end smallexample

@menu
* Looping with while::          Repeat so long as test returns true.
* Loop Example::                A @code{while} loop that uses a list.
* print-elements-of-list::      Uses @code{while}, @code{car}, @code{cdr}.
* Incrementing Loop::           A loop with an incrementing counter.
* Incrementing Loop Details::
* Decrementing Loop::           A loop with a decrementing counter.
@end menu

@node Looping with while, Loop Example, while, while
@ifnottex
@unnumberedsubsec Looping with @code{while}
@end ifnottex

So long as the true-or-false-test of the @code{while} expression
returns a true value when it is evaluated, the body is repeatedly
evaluated.  This process is called a loop since the Lisp interpreter
repeats the same thing again and again, like an airplane doing a loop.
When the result of evaluating the true-or-false-test is false, the
Lisp interpreter does not evaluate the rest of the @code{while}
expression and `exits the loop'.

Clearly, if the value returned by evaluating the first argument to
@code{while} is always true, the body following will be evaluated
again and again @dots{} and again @dots{} forever.  Conversely, if the
value returned is never true, the expressions in the body will never
be evaluated.  The craft of writing a @code{while} loop consists of
choosing a mechanism such that the true-or-false-test returns true
just the number of times that you want the subsequent expressions to
be evaluated, and then have the test return false.

The value returned by evaluating a @code{while} is the value of the
true-or-false-test.  An interesting consequence of this is that a
@code{while} loop that evaluates without error will return @code{nil}
or false regardless of whether it has looped 1 or 100 times or none at
all.  A @code{while} expression that evaluates successfully never
returns a true value!  What this means is that @code{while} is always
evaluated for its side effects, which is to say, the consequences of
evaluating the expressions within the body of the @code{while} loop.
This makes sense.  It is not the mere act of looping that is desired,
but the consequences of what happens when the expressions in the loop
are repeatedly evaluated.

@node Loop Example, print-elements-of-list, Looping with while, while
@comment  node-name,  next,  previous,  up
@subsection A @code{while} Loop and a List

A common way to control a @code{while} loop is to test whether a list
has any elements.  If it does, the loop is repeated; but if it does not,
the repetition is ended.  Since this is an important technique, we will
create a short example to illustrate it.

A simple way to test whether a list has elements is to evaluate the
list: if it has no elements, it is an empty list and will return the
empty list, @code{()}, which is a synonym for @code{nil} or false.  On
the other hand, a list with elements will return those elements when it
is evaluated.  Since Emacs Lisp considers as true any value that is not
@code{nil}, a list that returns elements will test true in a
@code{while} loop.

@need 1200
For example, you can set the variable @code{empty-list} to @code{nil} by
evaluating the following @code{setq} expression:

@smallexample
(setq empty-list ())
@end smallexample

@noindent
After evaluating the @code{setq} expression, you can evaluate the
variable @code{empty-list} in the usual way, by placing the cursor after
the symbol and typing @kbd{C-x C-e}; @code{nil} will appear in your
echo area:

@smallexample
empty-list
@end smallexample

On the other hand, if you set a variable to be a list with elements, the
list will appear when you evaluate the variable, as you can see by
evaluating the following two expressions:

@smallexample
@group
(setq animals '(gazelle giraffe lion tiger))

animals
@end group
@end smallexample

Thus, to create a @code{while} loop that tests whether there are any
items in the list @code{animals}, the first part of the loop will be
written like this:

@smallexample
@group
(while animals
       @dots{}
@end group
@end smallexample

@noindent
When the @code{while} tests its first argument, the variable
@code{animals} is evaluated.  It returns a list.  So long as the list
has elements, the @code{while} considers the results of the test to be
true; but when the list is empty, it considers the results of the test
to be false.

To prevent the @code{while} loop from running forever, some mechanism
needs to be provided to empty the list eventually.  An oft-used
technique is to have one of the subsequent forms in the @code{while}
expression set the value of the list to be the @sc{cdr} of the list.
Each time the @code{cdr} function is evaluated, the list will be made
shorter, until eventually only the empty list will be left.  At this
point, the test of the @code{while} loop will return false, and the
arguments to the @code{while} will no longer be evaluated.

For example, the list of animals bound to the variable @code{animals}
can be set to be the @sc{cdr} of the original list with the
following expression:

@smallexample
(setq animals (cdr animals))
@end smallexample

@noindent
If you have evaluated the previous expressions and then evaluate this
expression, you will see @code{(giraffe lion tiger)} appear in the echo
area.  If you evaluate the expression again, @code{(lion tiger)} will
appear in the echo area.  If you evaluate it again and yet again,
@code{(tiger)} appears and then the empty list, shown by @code{nil}.

A template for a @code{while} loop that uses the @code{cdr} function
repeatedly to cause the true-or-false-test eventually to test false
looks like this:

@smallexample
@group
(while @var{test-whether-list-is-empty}
  @var{body}@dots{}
  @var{set-list-to-cdr-of-list})
@end group
@end smallexample

This test and use of @code{cdr} can be put together in a function that
goes through a list and prints each element of the list on a line of its
own.

@node print-elements-of-list, Incrementing Loop, Loop Example, while
@subsection An Example: @code{print-elements-of-list}
@findex print-elements-of-list

The @code{print-elements-of-list} function illustrates a @code{while}
loop with a list.

@cindex @file{*scratch*} buffer
The function requires several lines for its output.  If you are
reading this in a recent instance of GNU Emacs,
@c GNU Emacs 21, GNU Emacs 22, or a later version,
you can evaluate the following expression inside of Info, as usual.

If you are using an earlier version of Emacs, you need to copy the
necessary expressions to your @file{*scratch*} buffer and evaluate
them there.  This is because the echo area had only one line in the
earlier versions.

You can copy the expressions by marking the beginning of the region
with @kbd{C-@key{SPC}} (@code{set-mark-command}), moving the cursor to
the end of the region and then copying the region using @kbd{M-w}
(@code{kill-ring-save}, which calls @code{copy-region-as-kill} and
then provides visual feedback).  In the @file{*scratch*}
buffer, you can yank the expressions back by typing @kbd{C-y}
(@code{yank}).

After you have copied the expressions to the @file{*scratch*} buffer,
evaluate each expression in turn.  Be sure to evaluate the last
expression, @code{(print-elements-of-list animals)}, by typing
@kbd{C-u C-x C-e}, that is, by giving an argument to
@code{eval-last-sexp}.  This will cause the result of the evaluation
to be printed in the @file{*scratch*} buffer instead of being printed
in the echo area.  (Otherwise you will see something like this in your
echo area: @code{^Jgazelle^J^Jgiraffe^J^Jlion^J^Jtiger^Jnil}, in which
each @samp{^J} stands for a `newline'.)

@need 1500
In a recent instance of GNU Emacs, you can evaluate these expressions
directly in the Info buffer, and the echo area will grow to show the
results.

@smallexample
@group
(setq animals '(gazelle giraffe lion tiger))

(defun print-elements-of-list (list)
  "Print each element of LIST on a line of its own."
  (while list
    (print (car list))
    (setq list (cdr list))))

(print-elements-of-list animals)
@end group
@end smallexample

@need 1200
@noindent
When you evaluate the three expressions in sequence, you will see
this:

@smallexample
@group
gazelle

giraffe

lion

tiger
nil
@end group
@end smallexample

Each element of the list is printed on a line of its own (that is what
the function @code{print} does) and then the value returned by the
function is printed.  Since the last expression in the function is the
@code{while} loop, and since @code{while} loops always return
@code{nil}, a @code{nil} is printed after the last element of the list.

@node Incrementing Loop, Incrementing Loop Details, print-elements-of-list, while
@comment  node-name,  next,  previous,  up
@subsection A Loop with an Incrementing Counter

A loop is not useful unless it stops when it ought.  Besides
controlling a loop with a list, a common way of stopping a loop is to
write the first argument as a test that returns false when the correct
number of repetitions are complete.  This means that the loop must
have a counter---an expression that counts how many times the loop
repeats itself.

@node Incrementing Loop Details, Decrementing Loop, Incrementing Loop, while
@ifnottex
@unnumberedsubsec Details of an Incrementing Loop
@end ifnottex

The test for a loop with an incrementing counter can be an expression
such as @code{(< count desired-number)} which returns @code{t} for
true if the value of @code{count} is less than the
@code{desired-number} of repetitions and @code{nil} for false if the
value of @code{count} is equal to or is greater than the
@code{desired-number}.  The expression that increments the count can
be a simple @code{setq} such as @code{(setq count (1+ count))}, where
@code{1+} is a built-in function in Emacs Lisp that adds 1 to its
argument.  (The expression @w{@code{(1+ count)}} has the same result
as @w{@code{(+ count 1)}}, but is easier for a human to read.)

@need 1250
The template for a @code{while} loop controlled by an incrementing
counter looks like this:

@smallexample
@group
@var{set-count-to-initial-value}
(while (< count desired-number)         ; @r{true-or-false-test}
  @var{body}@dots{}
  (setq count (1+ count)))              ; @r{incrementer}
@end group
@end smallexample

@noindent
Note that you need to set the initial value of @code{count}; usually it
is set to 1.

@menu
* Incrementing Example::        Counting pebbles in a triangle.
* Inc Example parts::           The parts of the function definition.
* Inc Example altogether::      Putting the function definition together.
@end menu

@node Incrementing Example, Inc Example parts, Incrementing Loop Details, Incrementing Loop Details
@unnumberedsubsubsec  Example with incrementing counter

Suppose you are playing on the beach and decide to make a triangle of
pebbles, putting one pebble in the first row, two in the second row,
three in the third row and so on, like this:

@sp 1
@c pebble diagram
@ifnottex
@smallexample
@group
               *
              * *
             * * *
            * * * *
@end group
@end smallexample
@end ifnottex
@iftex
@smallexample
@group
               @bullet{}
              @bullet{} @bullet{}
             @bullet{} @bullet{} @bullet{}
            @bullet{} @bullet{} @bullet{} @bullet{}
@end group
@end smallexample
@end iftex
@sp 1

@noindent
(About 2500 years ago, Pythagoras and others developed the beginnings of
number theory by considering questions such as this.)

Suppose you want to know how many pebbles you will need to make a
triangle with 7 rows?

Clearly, what you need to do is add up the numbers from 1 to 7.  There
are two ways to do this; start with the smallest number, one, and add up
the list in sequence, 1, 2, 3, 4 and so on; or start with the largest
number and add the list going down: 7, 6, 5, 4 and so on.  Because both
mechanisms illustrate common ways of writing @code{while} loops, we will
create two examples, one counting up and the other counting down.  In
this first example, we will start with 1 and add 2, 3, 4 and so on.

If you are just adding up a short list of numbers, the easiest way to do
it is to add up all the numbers at once.  However, if you do not know
ahead of time how many numbers your list will have, or if you want to be
prepared for a very long list, then you need to design your addition so
that what you do is repeat a simple process many times instead of doing
a more complex process once.

For example, instead of adding up all the pebbles all at once, what you
can do is add the number of pebbles in the first row, 1, to the number
in the second row, 2, and then add the total of those two rows to the
third row, 3.  Then you can add the number in the fourth row, 4, to the
total of the first three rows; and so on.

The critical characteristic of the process is that each repetitive
action is simple.  In this case, at each step we add only two numbers,
the number of pebbles in the row and the total already found.  This
process of adding two numbers is repeated again and again until the last
row has been added to the total of all the preceding rows.  In a more
complex loop the repetitive action might not be so simple, but it will
be simpler than doing everything all at once.

@node Inc Example parts, Inc Example altogether, Incrementing Example, Incrementing Loop Details
@unnumberedsubsubsec The parts of the function definition

The preceding analysis gives us the bones of our function definition:
first, we will need a variable that we can call @code{total} that will
be the total number of pebbles.  This will be the value returned by
the function.

Second, we know that the function will require an argument: this
argument will be the total number of rows in the triangle.  It can be
called @code{number-of-rows}.

Finally, we need a variable to use as a counter.  We could call this
variable @code{counter}, but a better name is @code{row-number}.  That
is because what the counter does in this function is count rows, and a
program should be written to be as understandable as possible.

When the Lisp interpreter first starts evaluating the expressions in the
function, the value of @code{total} should be set to zero, since we have
not added anything to it.  Then the function should add the number of
pebbles in the first row to the total, and then add the number of
pebbles in the second to the total, and then add the number of
pebbles in the third row to the total, and so on, until there are no
more rows left to add.

Both @code{total} and @code{row-number} are used only inside the
function, so they can be declared as local variables with @code{let}
and given initial values.  Clearly, the initial value for @code{total}
should be 0.  The initial value of @code{row-number} should be 1,
since we start with the first row.  This means that the @code{let}
statement will look like this:

@smallexample
@group
  (let ((total 0)
        (row-number 1))
    @var{body}@dots{})
@end group
@end smallexample

After the internal variables are declared and bound to their initial
values, we can begin the @code{while} loop.  The expression that serves
as the test should return a value of @code{t} for true so long as the
@code{row-number} is less than or equal to the @code{number-of-rows}.
(If the expression tests true only so long as the row number is less
than the number of rows in the triangle, the last row will never be
added to the total; hence the row number has to be either less than or
equal to the number of rows.)

@need 1500
@findex <= @r{(less than or equal)}
Lisp provides the @code{<=} function that returns true if the value of
its first argument is less than or equal to the value of its second
argument and false otherwise.  So the expression that the @code{while}
will evaluate as its test should look like this:

@smallexample
(<= row-number number-of-rows)
@end smallexample

The total number of pebbles can be found by repeatedly adding the number
of pebbles in a row to the total already found.  Since the number of
pebbles in the row is equal to the row number, the total can be found by
adding the row number to the total.  (Clearly, in a more complex
situation, the number of pebbles in the row might be related to the row
number in a more complicated way; if this were the case, the row number
would be replaced by the appropriate expression.)

@smallexample
(setq total (+ total row-number))
@end smallexample

@noindent
What this does is set the new value of @code{total} to be equal to the
sum of adding the number of pebbles in the row to the previous total.

After setting the value of @code{total}, the conditions need to be
established for the next repetition of the loop, if there is one.  This
is done by incrementing the value of the @code{row-number} variable,
which serves as a counter.  After the @code{row-number} variable has
been incremented, the true-or-false-test at the beginning of the
@code{while} loop tests whether its value is still less than or equal to
the value of the @code{number-of-rows} and if it is, adds the new value
of the @code{row-number} variable to the @code{total} of the previous
repetition of the loop.

@need 1200
The built-in Emacs Lisp function @code{1+} adds 1 to a number, so the
@code{row-number} variable can be incremented with this expression:

@smallexample
(setq row-number (1+ row-number))
@end smallexample

@node Inc Example altogether,  , Inc Example parts, Incrementing Loop Details
@unnumberedsubsubsec Putting the function definition together

We have created the parts for the function definition; now we need to
put them together.

@need 800
First, the contents of the @code{while} expression:

@smallexample
@group
(while (<= row-number number-of-rows)   ; @r{true-or-false-test}
  (setq total (+ total row-number))
  (setq row-number (1+ row-number)))    ; @r{incrementer}
@end group
@end smallexample

Along with the @code{let} expression varlist, this very nearly
completes the body of the function definition.  However, it requires
one final element, the need for which is somewhat subtle.

The final touch is to place the variable @code{total} on a line by
itself after the @code{while} expression.  Otherwise, the value returned
by the whole function is the value of the last expression that is
evaluated in the body of the @code{let}, and this is the value
returned by the @code{while}, which is always @code{nil}.

This may not be evident at first sight.  It almost looks as if the
incrementing expression is the last expression of the whole function.
But that expression is part of the body of the @code{while}; it is the
last element of the list that starts with the symbol @code{while}.
Moreover, the whole of the @code{while} loop is a list within the body
of the @code{let}.

@need 1250
In outline, the function will look like this:

@smallexample
@group
(defun @var{name-of-function} (@var{argument-list})
  "@var{documentation}@dots{}"
  (let (@var{varlist})
    (while (@var{true-or-false-test})
      @var{body-of-while}@dots{} )
    @dots{} ))                    ; @r{Need final expression here.}
@end group
@end smallexample

The result of evaluating the @code{let} is what is going to be returned
by the @code{defun} since the @code{let} is not embedded within any
containing list, except for the @code{defun} as a whole.  However, if
the @code{while} is the last element of the @code{let} expression, the
function will always return @code{nil}.  This is not what we want!
Instead, what we want is the value of the variable @code{total}.  This
is returned by simply placing the symbol as the last element of the list
starting with @code{let}.  It gets evaluated after the preceding
elements of the list are evaluated, which means it gets evaluated after
it has been assigned the correct value for the total.

It may be easier to see this by printing the list starting with
@code{let} all on one line.  This format makes it evident that the
@var{varlist} and @code{while} expressions are the second and third
elements of the list starting with @code{let}, and the @code{total} is
the last element:

@smallexample
@group
(let (@var{varlist}) (while (@var{true-or-false-test}) @var{body-of-while}@dots{} ) total)
@end group
@end smallexample

@need 1200
Putting everything together, the @code{triangle} function definition
looks like this:

@smallexample
@group
(defun triangle (number-of-rows)    ; @r{Version with}
                                    ; @r{  incrementing counter.}
  "Add up the number of pebbles in a triangle.
The first row has one pebble, the second row two pebbles,
the third row three pebbles, and so on.
The argument is NUMBER-OF-ROWS."
@end group
@group
  (let ((total 0)
        (row-number 1))
    (while (<= row-number number-of-rows)
      (setq total (+ total row-number))
      (setq row-number (1+ row-number)))
    total))
@end group
@end smallexample

@need 1200
After you have installed @code{triangle} by evaluating the function, you
can try it out.  Here are two examples:

@smallexample
@group
(triangle 4)

(triangle 7)
@end group
@end smallexample

@noindent
The sum of the first four numbers is 10 and the sum of the first seven
numbers is 28.

@node Decrementing Loop,  , Incrementing Loop Details, while
@comment  node-name,  next,  previous,  up
@subsection Loop with a Decrementing Counter

Another common way to write a @code{while} loop is to write the test
so that it determines whether a counter is greater than zero.  So long
as the counter is greater than zero, the loop is repeated.  But when
the counter is equal to or less than zero, the loop is stopped.  For
this to work, the counter has to start out greater than zero and then
be made smaller and smaller by a form that is evaluated
repeatedly.

The test will be an expression such as @code{(> counter 0)} which
returns @code{t} for true if the value of @code{counter} is greater
than zero, and @code{nil} for false if the value of @code{counter} is
equal to or less than zero.  The expression that makes the number
smaller and smaller can be a simple @code{setq} such as @code{(setq
counter (1- counter))}, where @code{1-} is a built-in function in
Emacs Lisp that subtracts 1 from its argument.

@need 1250
The template for a decrementing @code{while} loop looks like this:

@smallexample
@group
(while (> counter 0)                    ; @r{true-or-false-test}
  @var{body}@dots{}
  (setq counter (1- counter)))          ; @r{decrementer}
@end group
@end smallexample

@menu
* Decrementing Example::        More pebbles on the beach.
* Dec Example parts::           The parts of the function definition.
* Dec Example altogether::      Putting the function definition together.
@end menu

@node Decrementing Example, Dec Example parts, Decrementing Loop, Decrementing Loop
@unnumberedsubsubsec Example with decrementing counter

To illustrate a loop with a decrementing counter, we will rewrite the
@code{triangle} function so the counter decreases to zero.

This is the reverse of the earlier version of the function.  In this
case, to find out how many pebbles are needed to make a triangle with
3 rows, add the number of pebbles in the third row, 3, to the number
in the preceding row, 2, and then add the total of those two rows to
the row that precedes them, which is 1.

Likewise, to find the number of pebbles in a triangle with 7 rows, add
the number of pebbles in the seventh row, 7, to the number in the
preceding row, which is 6, and then add the total of those two rows to
the row that precedes them, which is 5, and so on.  As in the previous
example, each addition only involves adding two numbers, the total of
the rows already added up and the number of pebbles in the row that is
being added to the total.  This process of adding two numbers is
repeated again and again until there are no more pebbles to add.

We know how many pebbles to start with: the number of pebbles in the
last row is equal to the number of rows.  If the triangle has seven
rows, the number of pebbles in the last row is 7.  Likewise, we know how
many pebbles are in the preceding row: it is one less than the number in
the row.

@node Dec Example parts, Dec Example altogether, Decrementing Example, Decrementing Loop
@unnumberedsubsubsec The parts of the function definition

We start with three variables: the total number of rows in the
triangle; the number of pebbles in a row; and the total number of
pebbles, which is what we want to calculate.  These variables can be
named @code{number-of-rows}, @code{number-of-pebbles-in-row}, and
@code{total}, respectively.

Both @code{total} and @code{number-of-pebbles-in-row} are used only
inside the function and are declared with @code{let}.  The initial
value of @code{total} should, of course, be zero.  However, the
initial value of @code{number-of-pebbles-in-row} should be equal to
the number of rows in the triangle, since the addition will start with
the longest row.

@need 1250
This means that the beginning of the @code{let} expression will look
like this:

@smallexample
@group
(let ((total 0)
      (number-of-pebbles-in-row number-of-rows))
  @var{body}@dots{})
@end group
@end smallexample

The total number of pebbles can be found by repeatedly adding the number
of pebbles in a row to the total already found, that is, by repeatedly
evaluating the following expression:

@smallexample
(setq total (+ total number-of-pebbles-in-row))
@end smallexample

@noindent
After the @code{number-of-pebbles-in-row} is added to the @code{total},
the @code{number-of-pebbles-in-row} should be decremented by one, since
the next time the loop repeats, the preceding row will be
added to the total.

The number of pebbles in a preceding row is one less than the number of
pebbles in a row, so the built-in Emacs Lisp function @code{1-} can be
used to compute the number of pebbles in the preceding row.  This can be
done with the following expression:

@smallexample
@group
(setq number-of-pebbles-in-row
      (1- number-of-pebbles-in-row))
@end group
@end smallexample

Finally, we know that the @code{while} loop should stop making repeated
additions when there are no pebbles in a row.  So the test for
the @code{while} loop is simply:

@smallexample
(while (> number-of-pebbles-in-row 0)
@end smallexample

@node Dec Example altogether,  , Dec Example parts, Decrementing Loop
@unnumberedsubsubsec Putting the function definition together

We can put these expressions together to create a function definition
that works.  However, on examination, we find that one of the local
variables is unneeded!

@need 1250
The function definition looks like this:

@smallexample
@group
;;; @r{First subtractive version.}
(defun triangle (number-of-rows)
  "Add up the number of pebbles in a triangle."
  (let ((total 0)
        (number-of-pebbles-in-row number-of-rows))
    (while (> number-of-pebbles-in-row 0)
      (setq total (+ total number-of-pebbles-in-row))
      (setq number-of-pebbles-in-row
            (1- number-of-pebbles-in-row)))
    total))
@end group
@end smallexample

As written, this function works.

However, we do not need @code{number-of-pebbles-in-row}.

@cindex Argument as local variable
When the @code{triangle} function is evaluated, the symbol
@code{number-of-rows} will be bound to a number, giving it an initial
value.  That number can be changed in the body of the function as if
it were a local variable, without any fear that such a change will
effect the value of the variable outside of the function.  This is a
very useful characteristic of Lisp; it means that the variable
@code{number-of-rows} can be used anywhere in the function where
@code{number-of-pebbles-in-row} is used.

@need 800
Here is a second version of the function written a bit more cleanly:

@smallexample
@group
(defun triangle (number)                ; @r{Second version.}
  "Return sum of numbers 1 through NUMBER inclusive."
  (let ((total 0))
    (while (> number 0)
      (setq total (+ total number))
      (setq number (1- number)))
    total))
@end group
@end smallexample

In brief, a properly written @code{while} loop will consist of three parts:

@enumerate
@item
A test that will return false after the loop has repeated itself the
correct number of times.

@item
An expression the evaluation of which will return the value desired
after being repeatedly evaluated.

@item
An expression to change the value passed to the true-or-false-test so
that the test returns false after the loop has repeated itself the right
number of times.
@end enumerate


@node dolist dotimes, Recursion, while, Loops & Recursion
@comment  node-name,  next,  previous,  up
@section Save your time: @code{dolist} and @code{dotimes}

In addition to @code{while}, both @code{dolist} and @code{dotimes}
provide for looping.  Sometimes these are quicker to write than the
equivalent @code{while} loop.  Both are Lisp macros.  (@xref{Macros, ,
Macros, elisp, The GNU Emacs Lisp Reference Manual}. )

@code{dolist} works like a @code{while} loop that `@sc{cdr}s down a
list':  @code{dolist} automatically shortens the list each time it
loops---takes the @sc{cdr} of the list---and binds the @sc{car} of
each shorter version of the list to the first of its arguments.

@code{dotimes} loops a specific number of times: you specify the number.

@menu
* dolist::
* dotimes::
@end menu

@node dolist, dotimes, dolist dotimes, dolist dotimes
@unnumberedsubsubsec The @code{dolist} Macro
@findex dolist

Suppose, for example, you want to reverse a list, so that
``first'' ``second'' ``third'' becomes ``third'' ``second'' ``first''.

@need 1250
In practice, you would use the @code{reverse} function, like this:

@smallexample
@group
(setq animals '(gazelle giraffe lion tiger))

(reverse animals)
@end group
@end smallexample

@need 800
@noindent
Here is how you could reverse the list using a @code{while} loop:

@smallexample
@group
(setq animals '(gazelle giraffe lion tiger))

(defun reverse-list-with-while (list)
  "Using while, reverse the order of LIST."
  (let (value)  ; make sure list starts empty
    (while list
      (setq value (cons (car list) value))
      (setq list (cdr list)))
    value))

(reverse-list-with-while animals)
@end group
@end smallexample

@need 800
@noindent
And here is how you could use the @code{dolist} macro:

@smallexample
@group
(setq animals '(gazelle giraffe lion tiger))

(defun reverse-list-with-dolist (list)
  "Using dolist, reverse the order of LIST."
  (let (value)  ; make sure list starts empty
    (dolist (element list value)
      (setq value (cons element value)))))

(reverse-list-with-dolist animals)
@end group
@end smallexample

@need 1250
@noindent
In Info, you can place your cursor after the closing parenthesis of
each expression and type @kbd{C-x C-e}; in each case, you should see

@smallexample
(tiger lion giraffe gazelle)
@end smallexample

@noindent
in the echo area.

For this example, the existing @code{reverse} function is obviously best.
The @code{while} loop is just like our first example (@pxref{Loop
Example, , A @code{while} Loop and a List}).  The @code{while} first
checks whether the list has elements; if so, it constructs a new list
by adding the first element of the list to the existing list (which in
the first iteration of the loop is @code{nil}).  Since the second
element is prepended in front of the first element, and the third
element is prepended in front of the second element, the list is reversed.

In the expression using a @code{while} loop,
the @w{@code{(setq list (cdr list))}}
expression shortens the list, so the @code{while} loop eventually
stops.  In addition, it provides the @code{cons} expression with a new
first element by creating a new and shorter list at each repetition of
the loop.

The @code{dolist} expression does very much the same as the
@code{while} expression, except that the @code{dolist} macro does some
of the work you have to do when writing a @code{while} expression.

Like a @code{while} loop, a @code{dolist} loops.  What is different is
that it automatically shortens the list each time it loops --- it
`@sc{cdr}s down the list' on its own --- and it automatically binds
the @sc{car} of each shorter version of the list to the first of its
arguments.

In the example, the @sc{car} of each shorter version of the list is
referred to using the symbol @samp{element}, the list itself is called
@samp{list}, and the value returned is called @samp{value}.  The
remainder of the @code{dolist} expression is the body.

The @code{dolist} expression binds the @sc{car} of each shorter
version of the list to @code{element} and then evaluates the body of
the expression; and repeats the loop.  The result is returned in
@code{value}.

@node dotimes,  , dolist, dolist dotimes
@unnumberedsubsubsec The @code{dotimes} Macro
@findex dotimes

The @code{dotimes} macro is similar to @code{dolist}, except that it
loops a specific number of times.

The first argument to @code{dotimes} is assigned the numbers 0, 1, 2
and so forth each time around the loop, and the value of the third
argument is returned.  You need to provide the value of the second
argument, which is how many times the macro loops.

@need 1250
For example, the following binds the numbers from 0 up to, but not
including, the number 3 to the first argument, @var{number}, and then
constructs a list of the three numbers.  (The first number is 0, the
second number is 1, and the third number is 2; this makes a total of
three numbers in all, starting with zero as the first number.)

@smallexample
@group
(let (value)      ; otherwise a value is a void variable
  (dotimes (number 3 value)
    (setq value (cons number value))))

@result{} (2 1 0)
@end group
@end smallexample

@noindent
@code{dotimes} returns @code{value}, so the way to use
@code{dotimes} is to operate on some expression @var{number} number of
times and then return the result, either as a list or an atom.

@need 1250
Here is an example of a @code{defun} that uses @code{dotimes} to add
up the number of pebbles in a triangle.

@smallexample
@group
(defun triangle-using-dotimes (number-of-rows)
  "Using dotimes, add up the number of pebbles in a triangle."
(let ((total 0))  ; otherwise a total is a void variable
  (dotimes (number number-of-rows total)
    (setq total (+ total (1+ number))))))

(triangle-using-dotimes 4)
@end group
@end smallexample


@node Recursion, Looping exercise, dolist dotimes, Loops & Recursion
@comment  node-name,  next,  previous,  up
@section Recursion
@cindex Recursion

A recursive function contains code that tells the Lisp interpreter to
call a program that runs exactly like itself, but with slightly
different arguments.  The code runs exactly the same because it has
the same name.  However, even though the program has the same name, it
is not the same entity.  It is different.  In the jargon, it is a
different `instance'.

Eventually, if the program is written correctly, the `slightly
different arguments' will become sufficiently different from the first
arguments that the final instance will stop.

@menu
* Building Robots::             Same model, different serial number ...
* Recursive Definition Parts::  Walk until you stop ...
* Recursion with list::         Using a list as the test whether to recurse.
* Recursive triangle function::
* Recursion with cond::
* Recursive Patterns::          Often used templates.
* No Deferment::                Don't store up work ...
* No deferment solution::
@end menu

@node Building Robots, Recursive Definition Parts, Recursion, Recursion
@comment  node-name,  next,  previous,  up
@subsection Building Robots: Extending the Metaphor
@cindex Building robots
@cindex Robots, building

It is sometimes helpful to think of a running program as a robot that
does a job.  In doing its job, a recursive function calls on a second
robot to help it.  The second robot is identical to the first in every
way, except that the second robot helps the first and has been
passed different arguments than the first.

In a recursive function, the second robot may call a third; and the
third may call a fourth, and so on.  Each of these is a different
entity; but all are clones.

Since each robot has slightly different instructions---the arguments
will differ from one robot to the next---the last robot should know
when to stop.

Let's expand on the metaphor in which a computer program is a robot.

A function definition provides the blueprints for a robot.  When you
install a function definition, that is, when you evaluate a
@code{defun} special form, you install the necessary equipment to
build robots.  It is as if you were in a factory, setting up an
assembly line.  Robots with the same name are built according to the
same blueprints.  So they have, as it were, the same `model number',
but a different `serial number'.

We often say that a recursive function `calls itself'.  What we mean
is that the instructions in a recursive function cause the Lisp
interpreter to run a different function that has the same name and
does the same job as the first, but with different arguments.

It is important that the arguments differ from one instance to the
next; otherwise, the process will never stop.

@node Recursive Definition Parts, Recursion with list, Building Robots, Recursion
@comment  node-name,  next,  previous,  up
@subsection The Parts of a Recursive Definition
@cindex Parts of a Recursive Definition
@cindex Recursive Definition Parts

A recursive function typically contains a conditional expression which
has three parts:

@enumerate
@item
A true-or-false-test that determines whether the function is called
again, here called the @dfn{do-again-test}.

@item
The name of the function.  When this name is called, a new instance of
the function---a new robot, as it were---is created and told what to do.

@item
An expression that returns a different value each time the function is
called, here called the @dfn{next-step-expression}.  Consequently, the
argument (or arguments) passed to the new instance of the function
will be different from that passed to the previous instance.  This
causes the conditional expression, the @dfn{do-again-test}, to test
false after the correct number of repetitions.
@end enumerate

Recursive functions can be much simpler than any other kind of
function.  Indeed, when people first start to use them, they often look
so mysteriously simple as to be incomprehensible.  Like riding a
bicycle, reading a recursive function definition takes a certain knack
which is hard at first but then seems simple.

@need 1200
There are several different common recursive patterns.  A very simple
pattern looks like this:

@smallexample
@group
(defun @var{name-of-recursive-function} (@var{argument-list})
  "@var{documentation}@dots{}"
  (if @var{do-again-test}
    @var{body}@dots{}
    (@var{name-of-recursive-function}
         @var{next-step-expression})))
@end group
@end smallexample

Each time a recursive function is evaluated, a new instance of it is
created and told what to do.  The arguments tell the instance what to do.

An argument is bound to the value of the next-step-expression.  Each
instance runs with a different value of the next-step-expression.

The value in the next-step-expression is used in the do-again-test.

The value returned by the next-step-expression is passed to the new
instance of the function, which evaluates it (or some
transmogrification of it) to determine whether to continue or stop.
The next-step-expression is designed so that the do-again-test returns
false when the function should no longer be repeated.

The do-again-test is sometimes called the @dfn{stop condition},
since it stops the repetitions when it tests false.

@node Recursion with list, Recursive triangle function, Recursive Definition Parts, Recursion
@comment  node-name,  next,  previous,  up
@subsection Recursion with a List

The example of a @code{while} loop that printed the elements of a list
of numbers can be written recursively.  Here is the code, including
an expression to set the value of the variable @code{animals} to a list.

If you are using GNU Emacs 20 or before, this example must be copied
to the @file{*scratch*} buffer and each expression must be evaluated
there.  Use @kbd{C-u C-x C-e} to evaluate the
@code{(print-elements-recursively animals)} expression so that the
results are printed in the buffer; otherwise the Lisp interpreter will
try to squeeze the results into the one line of the echo area.

Also, place your cursor immediately after the last closing parenthesis
of the @code{print-elements-recursively} function, before the comment.
Otherwise, the Lisp interpreter will try to evaluate the comment.

If you are using a more recent version of Emacs, you can evaluate this
expression directly in Info.

@findex print-elements-recursively
@smallexample
@group
(setq animals '(gazelle giraffe lion tiger))

(defun print-elements-recursively (list)
  "Print each element of LIST on a line of its own.
Uses recursion."
  (when list                            ; @r{do-again-test}
        (print (car list))              ; @r{body}
        (print-elements-recursively     ; @r{recursive call}
         (cdr list))))                  ; @r{next-step-expression}

(print-elements-recursively animals)
@end group
@end smallexample

The @code{print-elements-recursively} function first tests whether
there is any content in the list; if there is, the function prints the
first element of the list, the @sc{car} of the list.  Then the
function `invokes itself', but gives itself as its argument, not the
whole list, but the second and subsequent elements of the list, the
@sc{cdr} of the list.

Put another way, if the list is not empty, the function invokes
another instance of code that is similar to the initial code, but is a
different thread of execution, with different arguments than the first
instance.

Put in yet another way, if the list is not empty, the first robot
assembles a second robot and tells it what to do; the second robot is
a different individual from the first, but is the same model.

When the second evaluation occurs, the @code{when} expression is
evaluated and if true, prints the first element of the list it
receives as its argument (which is the second element of the original
list).  Then the function `calls itself' with the @sc{cdr} of the list
it is invoked with, which (the second time around) is the @sc{cdr} of
the @sc{cdr} of the original list.

Note that although we say that the function `calls itself', what we
mean is that the Lisp interpreter assembles and instructs a new
instance of the program.  The new instance is a clone of the first,
but is a separate individual.

Each time the function `invokes itself', it invokes itself on a
shorter version of the original list.  It creates a new instance that
works on a shorter list.

Eventually, the function invokes itself on an empty list.  It creates
a new instance whose argument is @code{nil}.  The conditional expression
tests the value of @code{list}.  Since the value of @code{list} is
@code{nil}, the @code{when} expression tests false so the then-part is
not evaluated.  The function as a whole then returns @code{nil}.

@need 1200
When you evaluate the expression @code{(print-elements-recursively
animals)} in the @file{*scratch*} buffer, you see this result:

@smallexample
@group
gazelle

giraffe

lion

tiger
nil
@end group
@end smallexample

@need 2000
@node Recursive triangle function, Recursion with cond, Recursion with list, Recursion
@comment  node-name,  next,  previous,  up
@subsection Recursion in Place of a Counter
@findex triangle-recursively

@need 1200
The @code{triangle} function described in a previous section can also
be written recursively.  It looks like this:

@smallexample
@group
(defun triangle-recursively (number)
  "Return the sum of the numbers 1 through NUMBER inclusive.
Uses recursion."
  (if (= number 1)                    ; @r{do-again-test}
      1                               ; @r{then-part}
    (+ number                         ; @r{else-part}
       (triangle-recursively          ; @r{recursive call}
        (1- number)))))               ; @r{next-step-expression}

(triangle-recursively 7)
@end group
@end smallexample

@noindent
You can install this function by evaluating it and then try it by
evaluating @code{(triangle-recursively 7)}.  (Remember to put your
cursor immediately after the last parenthesis of the function
definition, before the comment.)  The function evaluates to 28.

To understand how this function works, let's consider what happens in the
various cases when the function is passed 1, 2, 3, or 4 as the value of
its argument.

@menu
* Recursive Example arg of 1 or 2::
* Recursive Example arg of 3 or 4::
@end menu

@node Recursive Example arg of 1 or 2, Recursive Example arg of 3 or 4, Recursive triangle function, Recursive triangle function
@ifnottex
@unnumberedsubsubsec An argument of 1 or 2
@end ifnottex

First, what happens if the value of the argument is 1?

The function has an @code{if} expression after the documentation
string.  It tests whether the value of @code{number} is equal to 1; if
so, Emacs evaluates the then-part of the @code{if} expression, which
returns the number 1 as the value of the function.  (A triangle with
one row has one pebble in it.)

Suppose, however, that the value of the argument is 2.  In this case,
Emacs evaluates the else-part of the @code{if} expression.

@need 1200
The else-part consists of an addition, the recursive call to
@code{triangle-recursively} and a decrementing action; and it looks like
this:

@smallexample
(+ number (triangle-recursively (1- number)))
@end smallexample

When Emacs evaluates this expression, the innermost expression is
evaluated first; then the other parts in sequence.  Here are the steps
in detail:

@table @i
@item Step 1 @w{  } Evaluate the innermost expression.

The innermost expression is @code{(1- number)} so Emacs decrements the
value of @code{number} from 2 to 1.

@item Step 2 @w{  } Evaluate the @code{triangle-recursively} function.

The Lisp interpreter creates an individual instance of
@code{triangle-recursively}.  It does not matter that this function is
contained within itself.  Emacs passes the result Step 1 as the
argument used by this instance of the @code{triangle-recursively}
function

In this case, Emacs evaluates @code{triangle-recursively} with an
argument of 1.  This means that this evaluation of
@code{triangle-recursively} returns 1.

@item Step 3 @w{  } Evaluate the value of @code{number}.

The variable @code{number} is the second element of the list that
starts with @code{+}; its value is 2.

@item Step 4 @w{  } Evaluate the @code{+} expression.

The @code{+} expression receives two arguments, the first
from the evaluation of @code{number} (Step 3) and the second from the
evaluation of @code{triangle-recursively} (Step 2).

The result of the addition is the sum of 2 plus 1, and the number 3 is
returned, which is correct.  A triangle with two rows has three
pebbles in it.
@end table

@node Recursive Example arg of 3 or 4,  , Recursive Example arg of 1 or 2, Recursive triangle function
@unnumberedsubsubsec An argument of 3 or 4

Suppose that @code{triangle-recursively} is called with an argument of
3.

@table @i
@item Step 1 @w{  } Evaluate the do-again-test.

The @code{if} expression is evaluated first.  This is the do-again
test and returns false, so the else-part of the @code{if} expression
is evaluated.  (Note that in this example, the do-again-test causes
the function to call itself when it tests false, not when it tests
true.)

@item Step 2 @w{  } Evaluate the innermost expression of the else-part.

The innermost expression of the else-part is evaluated, which decrements
3 to 2.  This is the next-step-expression.

@item Step 3 @w{  } Evaluate the @code{triangle-recursively} function.

The number 2 is passed to the @code{triangle-recursively} function.

We already know what happens when Emacs evaluates @code{triangle-recursively} with
an argument of 2.  After going through the sequence of actions described
earlier, it returns a value of 3.  So that is what will happen here.

@item Step 4 @w{  } Evaluate the addition.

3 will be passed as an argument to the addition and will be added to the
number with which the function was called, which is 3.
@end table

@noindent
The value returned by the function as a whole will be 6.

Now that we know what will happen when @code{triangle-recursively} is
called with an argument of 3, it is evident what will happen if it is
called with an argument of 4:

@quotation
@need 800
In the recursive call, the evaluation of

@smallexample
(triangle-recursively (1- 4))
@end smallexample

@need 800
@noindent
will return the value of evaluating

@smallexample
(triangle-recursively 3)
@end smallexample

@noindent
which is 6 and this value will be added to 4 by the addition in the
third line.
@end quotation

@noindent
The value returned by the function as a whole will be 10.

Each time @code{triangle-recursively} is evaluated, it evaluates a
version of itself---a different instance of itself---with a smaller
argument, until the argument is small enough so that it does not
evaluate itself.

Note that this particular design for a recursive function
requires that operations be deferred.

Before @code{(triangle-recursively 7)} can calculate its answer, it
must call @code{(triangle-recursively 6)}; and before
@code{(triangle-recursively 6)} can calculate its answer, it must call
@code{(triangle-recursively 5)}; and so on.  That is to say, the
calculation that @code{(triangle-recursively 7)} makes must be
deferred until @code{(triangle-recursively 6)} makes its calculation;
and @code{(triangle-recursively 6)} must defer until
@code{(triangle-recursively 5)} completes; and so on.

If each of these instances of @code{triangle-recursively} are thought
of as different robots, the first robot must wait for the second to
complete its job, which must wait until the third completes, and so
on.

There is a way around this kind of waiting, which we will discuss in
@ref{No Deferment, , Recursion without Deferments}.

@node Recursion with cond, Recursive Patterns, Recursive triangle function, Recursion
@comment  node-name,  next,  previous,  up
@subsection Recursion Example Using @code{cond}
@findex cond

The version of @code{triangle-recursively} described earlier is written
with the @code{if} special form.  It can also be written using another
special form called @code{cond}.  The name of the special form
@code{cond} is an abbreviation of the word @samp{conditional}.

Although the @code{cond} special form is not used as often in the
Emacs Lisp sources as @code{if}, it is used often enough to justify
explaining it.

@need 800
The template for a @code{cond} expression looks like this:

@smallexample
@group
(cond
 @var{body}@dots{})
@end group
@end smallexample

@noindent
where the @var{body} is a series of lists.

@need 800
Written out more fully, the template looks like this:

@smallexample
@group
(cond
 (@var{first-true-or-false-test} @var{first-consequent})
 (@var{second-true-or-false-test} @var{second-consequent})
 (@var{third-true-or-false-test} @var{third-consequent})
  @dots{})
@end group
@end smallexample

When the Lisp interpreter evaluates the @code{cond} expression, it
evaluates the first element (the @sc{car} or true-or-false-test) of
the first expression in a series of expressions within the body of the
@code{cond}.

If the true-or-false-test returns @code{nil} the rest of that
expression, the consequent, is skipped and  the true-or-false-test of the
next expression is evaluated.  When an expression is found whose
true-or-false-test returns a value that is not @code{nil}, the
consequent of that expression is evaluated.  The consequent can be one
or more expressions.  If the consequent consists of more than one
expression, the expressions are evaluated in sequence and the value of
the last one is returned.  If the expression does not have a consequent,
the value of the true-or-false-test is returned.

If none of the true-or-false-tests test true, the @code{cond} expression
returns @code{nil}.

@need 1250
Written using @code{cond}, the @code{triangle} function looks like this:

@smallexample
@group
(defun triangle-using-cond (number)
  (cond ((<= number 0) 0)
        ((= number 1) 1)
        ((> number 1)
         (+ number (triangle-using-cond (1- number))))))
@end group
@end smallexample

@noindent
In this example, the @code{cond} returns 0 if the number is less than or
equal to 0, it returns 1 if the number is 1 and it evaluates @code{(+
number (triangle-using-cond (1- number)))} if the number is greater than
1.

@node Recursive Patterns, No Deferment, Recursion with cond, Recursion
@comment  node-name,  next,  previous,  up
@subsection Recursive Patterns
@cindex Recursive Patterns

Here are three common recursive patterns.  Each involves a list.
Recursion does not need to involve lists, but Lisp is designed for lists
and this provides a sense of its primal capabilities.

@menu
* Every::
* Accumulate::
* Keep::
@end menu

@node Every, Accumulate, Recursive Patterns, Recursive Patterns
@comment  node-name,  next,  previous,  up
@unnumberedsubsubsec Recursive Pattern: @emph{every}
@cindex Every, type of recursive pattern
@cindex Recursive pattern: every

In the @code{every} recursive pattern, an action is performed on every
element of a list.

@need 1500
The basic pattern is:

@itemize @bullet
@item
If a list be empty, return @code{nil}.
@item
Else, act on the beginning of the list (the @sc{car} of the list)
    @itemize @minus
    @item
    through a recursive call by the function on the rest (the
    @sc{cdr}) of the list,
    @item
    and, optionally, combine the acted-on element, using @code{cons},
    with the results of acting on the rest.
    @end itemize
@end itemize

@need 1500
Here is example:

@smallexample
@group
(defun square-each (numbers-list)
  "Square each of a NUMBERS LIST, recursively."
  (if (not numbers-list)                ; do-again-test
      nil
    (cons
     (* (car numbers-list) (car numbers-list))
     (square-each (cdr numbers-list))))) ; next-step-expression
@end group

@group
(square-each '(1 2 3))
    @result{} (1 4 9)
@end group
@end smallexample

@need 1200
@noindent
If @code{numbers-list} is empty, do nothing.  But if it has content,
construct a list combining the square of the first number in the list
with the result of the recursive call.

(The example follows the pattern exactly: @code{nil} is returned if
the numbers' list is empty.  In practice, you would write the
conditional so it carries out the action when the numbers' list is not
empty.)

The @code{print-elements-recursively} function (@pxref{Recursion with
list, , Recursion with a List}) is another example of an @code{every}
pattern, except in this case, rather than bring the results together
using @code{cons}, we print each element of output.

@need 1250
The @code{print-elements-recursively} function looks like this:

@smallexample
@group
(setq animals '(gazelle giraffe lion tiger))
@end group

@group
(defun print-elements-recursively (list)
  "Print each element of LIST on a line of its own.
Uses recursion."
  (when list                            ; @r{do-again-test}
        (print (car list))              ; @r{body}
        (print-elements-recursively     ; @r{recursive call}
         (cdr list))))                  ; @r{next-step-expression}

(print-elements-recursively animals)
@end group
@end smallexample

@need 1500
The pattern for @code{print-elements-recursively} is:

@itemize @bullet
@item
When the list is empty, do nothing.
@item
But when the list has at least one element,
    @itemize @minus
    @item
    act on the beginning of the list (the @sc{car} of the list),
    @item
    and make a recursive call on the rest (the @sc{cdr}) of the list.
    @end itemize
@end itemize

@node Accumulate, Keep, Every, Recursive Patterns
@comment  node-name,  next,  previous,  up
@unnumberedsubsubsec Recursive Pattern: @emph{accumulate}
@cindex Accumulate, type of recursive pattern
@cindex Recursive pattern: accumulate

Another recursive pattern is called the @code{accumulate} pattern.  In
the @code{accumulate} recursive pattern, an action is performed on
every element of a list and the result of that action is accumulated
with the results of performing the action on the other elements.

This is very like the `every' pattern using @code{cons}, except that
@code{cons} is not used, but some other combiner.

@need 1500
The pattern is:

@itemize @bullet
@item
If a list be empty, return zero or some other constant.
@item
Else, act on the beginning of the list (the @sc{car} of the list),
    @itemize @minus
    @item
    and combine that acted-on element, using @code{+} or
    some other combining function, with
    @item
    a recursive call by the function on the rest (the @sc{cdr}) of the list.
    @end itemize
@end itemize

@need 1500
Here is an example:

@smallexample
@group
(defun add-elements (numbers-list)
  "Add the elements of NUMBERS-LIST together."
  (if (not numbers-list)
      0
    (+ (car numbers-list) (add-elements (cdr numbers-list)))))
@end group

@group
(add-elements '(1 2 3 4))
    @result{} 10
@end group
@end smallexample

@xref{Files List, , Making a List of Files}, for an example of the
accumulate pattern.

@node Keep,  , Accumulate, Recursive Patterns
@comment  node-name,  next,  previous,  up
@unnumberedsubsubsec Recursive Pattern: @emph{keep}
@cindex Keep, type of recursive pattern
@cindex Recursive pattern: keep

A third recursive pattern is called the @code{keep} pattern.
In the @code{keep} recursive pattern, each element of a list is tested;
the element is acted on and the results are kept only if the element
meets a criterion.

Again, this is very like the `every' pattern, except the element is
skipped unless it meets a criterion.

@need 1500
The pattern has three parts:

@itemize @bullet
@item
If a list be empty, return @code{nil}.
@item
Else, if the beginning of the list (the @sc{car} of the list) passes
        a test
    @itemize @minus
    @item
    act on that element and combine it, using @code{cons} with
    @item
    a recursive call by the function on the rest (the @sc{cdr}) of the list.
    @end itemize
@item
Otherwise, if the beginning of the list (the @sc{car} of the list) fails
the test
    @itemize @minus
    @item
    skip on that element,
    @item
    and, recursively call the function on the rest (the @sc{cdr}) of the list.
    @end itemize
@end itemize

@need 1500
Here is an example that uses @code{cond}:

@smallexample
@group
(defun keep-three-letter-words (word-list)
  "Keep three letter words in WORD-LIST."
  (cond
   ;; First do-again-test: stop-condition
   ((not word-list) nil)

   ;; Second do-again-test: when to act
   ((eq 3 (length (symbol-name (car word-list))))
    ;; combine acted-on element with recursive call on shorter list
    (cons (car word-list) (keep-three-letter-words (cdr word-list))))

   ;; Third do-again-test: when to skip element;
   ;;   recursively call shorter list with next-step expression
   (t (keep-three-letter-words (cdr word-list)))))
@end group

@group
(keep-three-letter-words '(one two three four five six))
    @result{} (one two six)
@end group
@end smallexample

It goes without saying that you need not use @code{nil} as the test for
when to stop; and you can, of course, combine these patterns.

@node No Deferment, No deferment solution, Recursive Patterns, Recursion
@subsection Recursion without Deferments
@cindex Deferment in recursion
@cindex Recursion without Deferments

Let's consider again what happens with the @code{triangle-recursively}
function.  We will find that the intermediate calculations are
deferred until all can be done.

@need 800
Here is the function definition:

@smallexample
@group
(defun triangle-recursively (number)
  "Return the sum of the numbers 1 through NUMBER inclusive.
Uses recursion."
  (if (= number 1)                    ; @r{do-again-test}
      1                               ; @r{then-part}
    (+ number                         ; @r{else-part}
       (triangle-recursively          ; @r{recursive call}
        (1- number)))))               ; @r{next-step-expression}
@end group
@end smallexample

What happens when we call this function with a argument of 7?

The first instance of the @code{triangle-recursively} function adds
the number 7 to the value returned by a second instance of
@code{triangle-recursively}, an instance that has been passed an
argument of 6.  That is to say, the first calculation is:

@smallexample
(+ 7 (triangle-recursively 6))
@end smallexample

@noindent
The first instance of @code{triangle-recursively}---you may want to
think of it as a little robot---cannot complete its job.  It must hand
off the calculation for @code{(triangle-recursively 6)} to a second
instance of the program, to a second robot.  This second individual is
completely different from the first one; it is, in the jargon, a
`different instantiation'.  Or, put another way, it is a different
robot.  It is the same model as the first; it calculates triangle
numbers recursively; but it has a different serial number.

And what does @code{(triangle-recursively 6)} return?  It returns the
number 6 added to the value returned by evaluating
@code{triangle-recursively} with an argument of 5.  Using the robot
metaphor, it asks yet another robot to help it.

@need 800
Now the total is:

@smallexample
(+ 7 6 (triangle-recursively 5))
@end smallexample

@need 800
And what happens next?

@smallexample
(+ 7 6 5 (triangle-recursively 4))
@end smallexample

Each time @code{triangle-recursively} is called, except for the last
time, it creates another instance of the program---another robot---and
asks it to make a calculation.

@need 800
Eventually, the full addition is set up and performed:

@smallexample
(+ 7 6 5 4 3 2 1)
@end smallexample

This design for the function defers the calculation of the first step
until the second can be done, and defers that until the third can be
done, and so on.  Each deferment means the computer must remember what
is being waited on.  This is not a problem when there are only a few
steps, as in this example.  But it can be a problem when there are
more steps.

@node No deferment solution,  , No Deferment, Recursion
@subsection No Deferment Solution
@cindex No deferment solution
@cindex Defermentless solution
@cindex Solution without deferment

The solution to the problem of deferred operations is to write in a
manner that does not defer operations@footnote{The phrase @dfn{tail
recursive} is used to describe such a process, one that uses
`constant space'.}.  This requires
writing to a different pattern, often one that involves writing two
function definitions, an `initialization' function and a `helper'
function.

The `initialization' function sets up the job; the `helper' function
does the work.

@need 1200
Here are the two function definitions for adding up numbers.  They are
so simple, I find them hard to understand.

@smallexample
@group
(defun triangle-initialization (number)
  "Return the sum of the numbers 1 through NUMBER inclusive.
This is the `initialization' component of a two function
duo that uses recursion."
  (triangle-recursive-helper 0 0 number))
@end group
@end smallexample

@smallexample
@group
(defun triangle-recursive-helper (sum counter number)
  "Return SUM, using COUNTER, through NUMBER inclusive.
This is the `helper' component of a two function duo
that uses recursion."
  (if (> counter number)
      sum
    (triangle-recursive-helper (+ sum counter)  ; @r{sum}
                               (1+ counter)     ; @r{counter}
                               number)))        ; @r{number}
@end group
@end smallexample

@need 1250
Install both function definitions by evaluating them, then call
@code{triangle-initialization} with 2 rows:

@smallexample
@group
(triangle-initialization 2)
    @result{} 3
@end group
@end smallexample

The `initialization' function calls the first instance of the `helper'
function with three arguments: zero, zero, and a number which is the
number of rows in the triangle.

The first two arguments passed to the `helper' function are
initialization values.  These values are changed when
@code{triangle-recursive-helper} invokes new instances.@footnote{The
jargon is mildly confusing:  @code{triangle-recursive-helper} uses a
process that is iterative in a procedure that is recursive.  The
process is called iterative because the computer need only record the
three values, @code{sum}, @code{counter}, and @code{number}; the
procedure is recursive because the function `calls itself'.  On the
other hand, both the process and the procedure used by
@code{triangle-recursively} are called recursive.  The word
`recursive' has different meanings in the two contexts.}

Let's see what happens when we have a triangle that has one row.  (This
triangle will have one pebble in it!)

@need 1200
@code{triangle-initialization} will call its helper with
the arguments @w{@code{0 0 1}}.  That function will run the conditional
test whether @code{(> counter number)}:

@smallexample
(> 0 1)
@end smallexample

@need 1200
@noindent
and find that the result is false, so it will invoke
the else-part of the @code{if} clause:

@smallexample
@group
    (triangle-recursive-helper
     (+ sum counter)  ; @r{sum plus counter} @result{} @r{sum}
     (1+ counter)     ; @r{increment counter} @result{} @r{counter}
     number)          ; @r{number stays the same}
@end group
@end smallexample

@need 800
@noindent
which will first compute:

@smallexample
@group
(triangle-recursive-helper (+ 0 0)  ; @r{sum}
                           (1+ 0)   ; @r{counter}
                           1)       ; @r{number}
@exdent which is:

(triangle-recursive-helper 0 1 1)
@end group
@end smallexample

Again, @code{(> counter number)} will be false, so again, the Lisp
interpreter will evaluate @code{triangle-recursive-helper}, creating a
new instance with new arguments.

@need 800
This new instance will be;

@smallexample
@group
    (triangle-recursive-helper
     (+ sum counter)  ; @r{sum plus counter} @result{} @r{sum}
     (1+ counter)     ; @r{increment counter} @result{} @r{counter}
     number)          ; @r{number stays the same}

@exdent which is:

(triangle-recursive-helper 1 2 1)
@end group
@end smallexample

In this case, the @code{(> counter number)} test will be true!  So the
instance will return the value of the sum, which will be 1, as
expected.

Now, let's pass @code{triangle-initialization} an argument
of 2, to find out how many pebbles there are in a triangle with two rows.

That function calls @code{(triangle-recursive-helper 0 0 2)}.

@need 800
In stages, the instances called will be:

@smallexample
@group
                          @r{sum counter number}
(triangle-recursive-helper 0    1       2)

(triangle-recursive-helper 1    2       2)

(triangle-recursive-helper 3    3       2)
@end group
@end smallexample

When the last instance is called, the @code{(> counter number)} test
will be true, so the instance will return the value of @code{sum},
which will be 3.

This kind of pattern helps when you are writing functions that can use
many resources in a computer.


@need 1500
@node Looping exercise,  , Recursion, Loops & Recursion
@section Looping Exercise

@itemize @bullet
@item
Write a function similar to @code{triangle} in which each row has a
value which is the square of the row number.  Use a @code{while} loop.

@item
Write a function similar to @code{triangle} that multiplies instead of
adds the values.

@item
Rewrite these two functions recursively.  Rewrite these functions
using @code{cond}.

@c comma in printed title causes problem in Info cross reference
@item
Write a function for Texinfo mode that creates an index entry at the
beginning of a paragraph for every @samp{@@dfn} within the paragraph.
(In a Texinfo file, @samp{@@dfn} marks a definition.  This book is
written in Texinfo.)

Many of the functions you will need are described in two of the
previous chapters, @ref{Cutting & Storing Text, , Cutting and Storing
Text}, and @ref{Yanking, , Yanking Text Back}.  If you use
@code{forward-paragraph} to put the index entry at the beginning of
the paragraph, you will have to use @w{@kbd{C-h f}}
(@code{describe-function}) to find out how to make the command go
backwards.

For more information, see
@ifinfo
@ref{Indicating, , Indicating Definitions, texinfo}.
@end ifinfo
@ifhtml
@ref{Indicating, , Indicating, texinfo, Texinfo Manual}, which goes to
a Texinfo manual in the current directory.  Or, if you are on the
Internet, see
@uref{http://www.gnu.org/software/texinfo/manual/texinfo/}
@end ifhtml
@iftex
``Indicating Definitions, Commands, etc.'' in @cite{Texinfo, The GNU
Documentation Format}.
@end iftex
@end itemize


@node Regexp Search, Counting Words, Loops & Recursion, Top
@comment  node-name,  next,  previous,  up
@chapter Regular Expression Searches
@cindex Searches, illustrating
@cindex Regular expression searches
@cindex Patterns, searching for
@cindex Motion by sentence and paragraph
@cindex Sentences, movement by
@cindex Paragraphs, movement by

Regular expression searches are used extensively in GNU Emacs.  The
two functions, @code{forward-sentence} and @code{forward-paragraph},
illustrate these searches well.  They use regular expressions to find
where to move point.  The phrase `regular expression' is often written
as `regexp'.

Regular expression searches are described in @ref{Regexp Search, ,
Regular Expression Search, emacs, The GNU Emacs Manual}, as well as in
@ref{Regular Expressions, , , elisp, The GNU Emacs Lisp Reference
Manual}.  In writing this chapter, I am presuming that you have at
least a mild acquaintance with them.  The major point to remember is
that regular expressions permit you to search for patterns as well as
for literal strings of characters.  For example, the code in
@code{forward-sentence} searches for the pattern of possible
characters that could mark the end of a sentence, and moves point to
that spot.

Before looking at the code for the @code{forward-sentence} function, it
is worth considering what the pattern that marks the end of a sentence
must be.  The pattern is discussed in the next section; following that
is a description of the regular expression search function,
@code{re-search-forward}.  The @code{forward-sentence} function
is described in the section following.  Finally, the
@code{forward-paragraph} function is described in the last section of
this chapter.  @code{forward-paragraph} is a complex function that
introduces several new features.

@menu
* sentence-end::                The regular expression for @code{sentence-end}.
* re-search-forward::           Very similar to @code{search-forward}.
* forward-sentence::            A straightforward example of regexp search.
* forward-paragraph::           A somewhat complex example.
* etags::                       How to create your own @file{TAGS} table.
* Regexp Review::
* re-search Exercises::
@end menu


@node sentence-end, re-search-forward, Regexp Search, Regexp Search
@comment  node-name,  next,  previous,  up
@section The Regular Expression for @code{sentence-end}
@findex sentence-end

The symbol @code{sentence-end} is bound to the pattern that marks the
end of a sentence.  What should this regular expression be?

Clearly, a sentence may be ended by a period, a question mark, or an
exclamation mark.  Indeed, in English, only clauses that end with one
of those three characters should be considered the end of a sentence.
This means that the pattern should include the character set:

@smallexample
[.?!]
@end smallexample

However, we do not want @code{forward-sentence} merely to jump to a
period, a question mark, or an exclamation mark, because such a character
might be used in the middle of a sentence.  A period, for example, is
used after abbreviations.  So other information is needed.

According to convention, you type two spaces after every sentence, but
only one space after a period, a question mark, or an exclamation mark in
the body of a sentence.  So a period, a question mark, or an exclamation
mark followed by two spaces is a good indicator of an end of sentence.
However, in a file, the two spaces may instead be a tab or the end of a
line.  This means that the regular expression should include these three
items as alternatives.

@need 800
This group of alternatives will look like this:

@smallexample
@group
\\($\\| \\|  \\)
       ^   ^^
      TAB  SPC
@end group
@end smallexample

@noindent
Here, @samp{$} indicates the end of the line, and I have pointed out
where the tab and two spaces are inserted in the expression.  Both are
inserted by putting the actual characters into the expression.

Two backslashes, @samp{\\}, are required before the parentheses and
vertical bars: the first backslash quotes the following backslash in
Emacs; and the second indicates that the following character, the
parenthesis or the vertical bar, is special.

@need 1000
Also, a sentence may be followed by one or more carriage returns, like
this:

@smallexample
@group
[
]*
@end group
@end smallexample

@noindent
Like tabs and spaces, a carriage return is inserted into a regular
expression by inserting it literally.  The asterisk indicates that the
@key{RET} is repeated zero or more times.

But a sentence end does not consist only of a period, a question mark or
an exclamation mark followed by appropriate space: a closing quotation
mark or a closing brace of some kind may precede the space.  Indeed more
than one such mark or brace may precede the space.  These require a
expression that looks like this:

@smallexample
[]\"')@}]*
@end smallexample

In this expression, the first @samp{]} is the first character in the
expression; the second character is @samp{"}, which is preceded by a
@samp{\} to tell Emacs the @samp{"} is @emph{not} special.  The last
three characters are @samp{'}, @samp{)}, and @samp{@}}.

All this suggests what the regular expression pattern for matching the
end of a sentence should be; and, indeed, if we evaluate
@code{sentence-end} we find that it returns the following value:

@smallexample
@group
sentence-end
     @result{} "[.?!][]\"')@}]*\\($\\|     \\|  \\)[
]*"
@end group
@end smallexample

@noindent
(Well, not in GNU Emacs 22; that is because of an effort to make the
process simpler and to handle more glyphs and languages.  When the
value of @code{sentence-end} is @code{nil}, then use the value defined
by the function @code{sentence-end}.  (Here is a use of the difference
between a value and a function in Emacs Lisp.)  The function returns a
value constructed from the variables @code{sentence-end-base},
@code{sentence-end-double-space}, @code{sentence-end-without-period},
and @code{sentence-end-without-space}.  The critical variable is
@code{sentence-end-base}; its global value is similar to the one
described above but it also contains two additional quotation marks.
These have differing degrees of curliness.  The
@code{sentence-end-without-period} variable, when true, tells Emacs
that a sentence may end without a period, such as text in Thai.)

@ignore
@noindent
(Note that here the @key{TAB}, two spaces, and  @key{RET} are shown
literally in the pattern.)

This regular expression can be deciphered as follows:

@table @code
@item [.?!]
The first part of the pattern is the three characters, a period, a question
mark and an exclamation mark, within square brackets.  The pattern must
begin with one or other of these characters.

@item []\"')@}]*
The second part of the pattern is the group of closing braces and
quotation marks, which can appear zero or more times.  These may follow
the period, question mark or exclamation mark.  In a regular expression,
the backslash, @samp{\}, followed by the double quotation mark,
@samp{"}, indicates the class of string-quote characters.  Usually, the
double quotation mark is the only character in this class.  The
asterisk, @samp{*}, indicates that the items in the previous group (the
group surrounded by square brackets, @samp{[]}) may be repeated zero or
more times.

@item \\($\\|   \\|  \\)
The third part of the pattern is one or other of: either the end of a
line, or two blank spaces, or a tab.  The double back-slashes are used
to prevent Emacs from reading the parentheses and vertical bars as part
of the search pattern; the parentheses are used to mark the group and
the vertical bars are used to indicated that the patterns to either side
of them are alternatives.  The dollar sign is used to indicate the end
of a line and both the two spaces and the tab are each inserted as is to
indicate what they are.

@item [@key{RET}]*
Finally, the last part of the pattern indicates that the end of the line
or the whitespace following the period, question mark or exclamation
mark may, but need not, be followed by one or more carriage returns.  In
the pattern, the carriage return is inserted as an actual carriage
return between square brackets but here it is shown as @key{RET}.
@end table
@end ignore


@node re-search-forward, forward-sentence, sentence-end, Regexp Search
@comment  node-name,  next,  previous,  up
@section The @code{re-search-forward} Function
@findex re-search-forward

The @code{re-search-forward} function is very like the
@code{search-forward} function.  (@xref{search-forward, , The
@code{search-forward} Function}.)

@code{re-search-forward} searches for a regular expression.  If the
search is successful, it leaves point immediately after the last
character in the target.  If the search is backwards, it leaves point
just before the first character in the target.  You may tell
@code{re-search-forward} to return @code{t} for true.  (Moving point
is therefore a `side effect'.)

Like @code{search-forward}, the @code{re-search-forward} function takes
four arguments:

@enumerate
@item
The first argument is the regular expression that the function searches
for.  The regular expression will be a string between quotations marks.

@item
The optional second argument limits how far the function will search; it is a
bound, which is specified as a position in the buffer.

@item
The optional third argument specifies how the function responds to
failure: @code{nil} as the third argument causes the function to
signal an error (and print a message) when the search fails; any other
value causes it to return @code{nil} if the search fails and @code{t}
if the search succeeds.

@item
The optional fourth argument is the repeat count.  A negative repeat
count causes @code{re-search-forward} to search backwards.
@end enumerate

@need 800
The template for @code{re-search-forward} looks like this:

@smallexample
@group
(re-search-forward "@var{regular-expression}"
                @var{limit-of-search}
                @var{what-to-do-if-search-fails}
                @var{repeat-count})
@end group
@end smallexample

The second, third, and fourth arguments are optional.  However, if you
want to pass a value to either or both of the last two arguments, you
must also pass a value to all the preceding arguments.  Otherwise, the
Lisp interpreter will mistake which argument you are passing the value
to.

@need 1200
In the @code{forward-sentence} function, the regular expression will be
the value of the variable @code{sentence-end}.  In simple form, that is:

@smallexample
@group
"[.?!][]\"')@}]*\\($\\|  \\|  \\)[
]*"
@end group
@end smallexample

@noindent
The limit of the search will be the end of the paragraph (since a
sentence cannot go beyond a paragraph).  If the search fails, the
function will return @code{nil}; and the repeat count will be provided
by the argument to the @code{forward-sentence} function.


@node forward-sentence, forward-paragraph, re-search-forward, Regexp Search
@comment  node-name,  next,  previous,  up
@section @code{forward-sentence}
@findex forward-sentence

The command to move the cursor forward a sentence is a straightforward
illustration of how to use regular expression searches in Emacs Lisp.
Indeed, the function looks longer and more complicated than it is; this
is because the function is designed to go backwards as well as forwards;
and, optionally, over more than one sentence.  The function is usually
bound to the key command @kbd{M-e}.

@menu
* Complete forward-sentence::
* fwd-sentence while loops::    Two @code{while} loops.
* fwd-sentence re-search::      A regular expression search.
@end menu

@node Complete forward-sentence, fwd-sentence while loops, forward-sentence, forward-sentence
@ifnottex
@unnumberedsubsec Complete @code{forward-sentence} function definition
@end ifnottex

@need 1250
Here is the code for @code{forward-sentence}:

@c in GNU Emacs 22
@smallexample
@group
(defun forward-sentence (&optional arg)
  "Move forward to next `sentence-end'.  With argument, repeat.
With negative argument, move backward repeatedly to `sentence-beginning'.

The variable `sentence-end' is a regular expression that matches ends of
sentences.  Also, every paragraph boundary terminates sentences as well."
@end group
@group
  (interactive "p")
  (or arg (setq arg 1))
  (let ((opoint (point))
        (sentence-end (sentence-end)))
    (while (< arg 0)
      (let ((pos (point))
            (par-beg (save-excursion (start-of-paragraph-text) (point))))
       (if (and (re-search-backward sentence-end par-beg t)
                (or (< (match-end 0) pos)
                    (re-search-backward sentence-end par-beg t)))
           (goto-char (match-end 0))
         (goto-char par-beg)))
      (setq arg (1+ arg)))
@end group
@group
    (while (> arg 0)
      (let ((par-end (save-excursion (end-of-paragraph-text) (point))))
       (if (re-search-forward sentence-end par-end t)
           (skip-chars-backward " \t\n")
         (goto-char par-end)))
      (setq arg (1- arg)))
    (constrain-to-field nil opoint t)))
@end group
@end smallexample

@ignore
GNU Emacs 21
@smallexample
@group
(defun forward-sentence (&optional arg)
  "Move forward to next sentence-end.  With argument, repeat.
With negative argument, move backward repeatedly to sentence-beginning.
Sentence ends are identified by the value of sentence-end
treated as a regular expression.  Also, every paragraph boundary
terminates sentences as well."
@end group
@group
  (interactive "p")
  (or arg (setq arg 1))
  (while (< arg 0)
    (let ((par-beg
           (save-excursion (start-of-paragraph-text) (point))))
      (if (re-search-backward
           (concat sentence-end "[^ \t\n]") par-beg t)
          (goto-char (1- (match-end 0)))
        (goto-char par-beg)))
    (setq arg (1+ arg)))
  (while (> arg 0)
    (let ((par-end
           (save-excursion (end-of-paragraph-text) (point))))
      (if (re-search-forward sentence-end par-end t)
          (skip-chars-backward " \t\n")
        (goto-char par-end)))
    (setq arg (1- arg))))
@end group
@end smallexample
@end ignore

The function looks long at first sight and it is best to look at its
skeleton first, and then its muscle.  The way to see the skeleton is to
look at the expressions that start in the left-most columns:

@smallexample
@group
(defun forward-sentence (&optional arg)
  "@var{documentation}@dots{}"
  (interactive "p")
  (or arg (setq arg 1))
  (let ((opoint (point)) (sentence-end (sentence-end)))
    (while (< arg 0)
      (let ((pos (point))
            (par-beg (save-excursion (start-of-paragraph-text) (point))))
       @var{rest-of-body-of-while-loop-when-going-backwards}
    (while (> arg 0)
      (let ((par-end (save-excursion (end-of-paragraph-text) (point))))
       @var{rest-of-body-of-while-loop-when-going-forwards}
    @var{handle-forms-and-equivalent}
@end group
@end smallexample

This looks much simpler!  The function definition consists of
documentation, an @code{interactive} expression, an @code{or}
expression, a @code{let} expression, and @code{while} loops.

Let's look at each of these parts in turn.

We note that the documentation is thorough and understandable.

The function has an @code{interactive "p"} declaration.  This means
that the processed prefix argument, if any, is passed to the
function as its argument.  (This will be a number.)  If the function
is not passed an argument (it is optional) then the argument
@code{arg} will be bound to 1.

When @code{forward-sentence} is called non-interactively without an
argument, @code{arg} is bound to @code{nil}.  The @code{or} expression
handles this.  What it does is either leave the value of @code{arg} as
it is, but only if @code{arg} is bound to a value; or it sets the
value of @code{arg} to 1, in the case when @code{arg} is bound to
@code{nil}.

Next is a @code{let}.  That specifies the values of two local
variables, @code{point} and @code{sentence-end}.  The local value of
point, from before the search, is used in the
@code{constrain-to-field} function which handles forms and
equivalents.  The @code{sentence-end} variable is set by the
@code{sentence-end} function.

@node fwd-sentence while loops, fwd-sentence re-search, Complete forward-sentence, forward-sentence
@unnumberedsubsec The @code{while} loops

Two @code{while} loops follow.  The first @code{while} has a
true-or-false-test that tests true if the prefix argument for
@code{forward-sentence} is a negative number.  This is for going
backwards.  The body of this loop is similar to the body of the second
@code{while} clause, but it is not exactly the same.  We will skip
this @code{while} loop and concentrate on the second @code{while}
loop.

@need 1500
The second @code{while} loop is for moving point forward.  Its skeleton
looks like this:

@smallexample
@group
(while (> arg 0)            ; @r{true-or-false-test}
  (let @var{varlist}
    (if (@var{true-or-false-test})
        @var{then-part}
      @var{else-part}
  (setq arg (1- arg))))     ; @code{while} @r{loop decrementer}
@end group
@end smallexample

The @code{while} loop is of the decrementing kind.
(@xref{Decrementing Loop, , A Loop with a Decrementing Counter}.)  It
has a true-or-false-test that tests true so long as the counter (in
this case, the variable @code{arg}) is greater than zero; and it has a
decrementer that subtracts 1 from the value of the counter every time
the loop repeats.

If no prefix argument is given to @code{forward-sentence}, which is
the most common way the command is used, this @code{while} loop will
run once, since the value of @code{arg} will be 1.

The body of the @code{while} loop consists of a @code{let} expression,
which creates and binds a local variable, and has, as its body, an
@code{if} expression.

@need 1250
The body of the @code{while} loop looks like this:

@smallexample
@group
(let ((par-end
       (save-excursion (end-of-paragraph-text) (point))))
  (if (re-search-forward sentence-end par-end t)
      (skip-chars-backward " \t\n")
    (goto-char par-end)))
@end group
@end smallexample

The @code{let} expression creates and binds the local variable
@code{par-end}.  As we shall see, this local variable is designed to
provide a bound or limit to the regular expression search.  If the
search fails to find a proper sentence ending in the paragraph, it will
stop on reaching the end of the paragraph.

But first, let us examine how @code{par-end} is bound to the value of
the end of the paragraph.  What happens is that the @code{let} sets the
value of @code{par-end} to the value returned when the Lisp interpreter
evaluates the expression

@smallexample
@group
(save-excursion (end-of-paragraph-text) (point))
@end group
@end smallexample

@noindent
In this expression, @code{(end-of-paragraph-text)} moves point to the
end of the paragraph, @code{(point)} returns the value of point, and then
@code{save-excursion} restores point to its original position.  Thus,
the @code{let} binds @code{par-end} to the value returned by the
@code{save-excursion} expression, which is the position of the end of
the paragraph.  (The @code{end-of-paragraph-text} function uses
@code{forward-paragraph}, which we will discuss shortly.)

@need 1200
Emacs next evaluates the body of the @code{let}, which is an @code{if}
expression that looks like this:

@smallexample
@group
(if (re-search-forward sentence-end par-end t) ; @r{if-part}
    (skip-chars-backward " \t\n")              ; @r{then-part}
  (goto-char par-end)))                        ; @r{else-part}
@end group
@end smallexample

The @code{if} tests whether its first argument is true and if so,
evaluates its then-part; otherwise, the Emacs Lisp interpreter
evaluates the else-part.  The true-or-false-test of the @code{if}
expression is the regular expression search.

It may seem odd to have what looks like the `real work' of
the @code{forward-sentence} function buried here, but this is a common
way this kind of operation is carried out in Lisp.

@node fwd-sentence re-search,  , fwd-sentence while loops, forward-sentence
@unnumberedsubsec The regular expression search

The @code{re-search-forward} function searches for the end of the
sentence, that is, for the pattern defined by the @code{sentence-end}
regular expression.  If the pattern is found---if the end of the sentence is
found---then the @code{re-search-forward} function does two things:

@enumerate
@item
The @code{re-search-forward} function carries out a side effect, which
is to move point to the end of the occurrence found.

@item
The @code{re-search-forward} function returns a value of true.  This is
the value received by the @code{if}, and means that the search was
successful.
@end enumerate

@noindent
The side effect, the movement of point, is completed before the
@code{if} function is handed the value returned by the successful
conclusion of the search.

When the @code{if} function receives the value of true from a successful
call to @code{re-search-forward}, the @code{if} evaluates the then-part,
which is the expression @code{(skip-chars-backward " \t\n")}.  This
expression moves backwards over any blank spaces, tabs or carriage
returns until a printed character is found and then leaves point after
the character.  Since point has already been moved to the end of the
pattern that marks the end of the sentence, this action leaves point
right after the closing printed character of the sentence, which is
usually a period.

On the other hand, if the @code{re-search-forward} function fails to
find a pattern marking the end of the sentence, the function returns
false.  The false then causes the @code{if} to evaluate its third
argument, which is @code{(goto-char par-end)}:  it moves point to the
end of the paragraph.

(And if the text is in a form or equivalent, and point may not move
fully, then the @code{constrain-to-field} function comes into play.)

Regular expression searches are exceptionally useful and the pattern
illustrated by @code{re-search-forward}, in which the search is the
test of an @code{if} expression, is handy.  You will see or write code
incorporating this pattern often.


@node forward-paragraph, etags, forward-sentence, Regexp Search
@comment  node-name,  next,  previous,  up
@section @code{forward-paragraph}: a Goldmine of Functions
@findex forward-paragraph

@ignore
@c in GNU Emacs 22
(defun forward-paragraph (&optional arg)
  "Move forward to end of paragraph.
With argument ARG, do it ARG times;
a negative argument ARG = -N means move backward N paragraphs.

A line which `paragraph-start' matches either separates paragraphs
\(if `paragraph-separate' matches it also) or is the first line of a paragraph.
A paragraph end is the beginning of a line which is not part of the paragraph
to which the end of the previous line belongs, or the end of the buffer.
Returns the count of paragraphs left to move."
  (interactive "p")
  (or arg (setq arg 1))
  (let* ((opoint (point))
         (fill-prefix-regexp
          (and fill-prefix (not (equal fill-prefix ""))
               (not paragraph-ignore-fill-prefix)
               (regexp-quote fill-prefix)))
         ;; Remove ^ from paragraph-start and paragraph-sep if they are there.
         ;; These regexps shouldn't be anchored, because we look for them
         ;; starting at the left-margin.  This allows paragraph commands to
         ;; work normally with indented text.
         ;; This hack will not find problem cases like "whatever\\|^something".
         (parstart (if (and (not (equal "" paragraph-start))
                            (equal ?^ (aref paragraph-start 0)))
                       (substring paragraph-start 1)
                     paragraph-start))
         (parsep (if (and (not (equal "" paragraph-separate))
                          (equal ?^ (aref paragraph-separate 0)))
                     (substring paragraph-separate 1)
                   paragraph-separate))
         (parsep
          (if fill-prefix-regexp
              (concat parsep "\\|"
                      fill-prefix-regexp "[ \t]*$")
            parsep))
         ;; This is used for searching.
         (sp-parstart (concat "^[ \t]*\\(?:" parstart "\\|" parsep "\\)"))
         start found-start)
    (while (and (< arg 0) (not (bobp)))
      (if (and (not (looking-at parsep))
               (re-search-backward "^\n" (max (1- (point)) (point-min)) t)
               (looking-at parsep))
          (setq arg (1+ arg))
        (setq start (point))
        ;; Move back over paragraph-separating lines.
        (forward-char -1) (beginning-of-line)
        (while (and (not (bobp))
                    (progn (move-to-left-margin)
                           (looking-at parsep)))
          (forward-line -1))
        (if (bobp)
            nil
          (setq arg (1+ arg))
          ;; Go to end of the previous (non-separating) line.
          (end-of-line)
          ;; Search back for line that starts or separates paragraphs.
          (if (if fill-prefix-regexp
                  ;; There is a fill prefix; it overrides parstart.
                  (let (multiple-lines)
                    (while (and (progn (beginning-of-line) (not (bobp)))
                                (progn (move-to-left-margin)
                                       (not (looking-at parsep)))
                                (looking-at fill-prefix-regexp))
                      (unless (= (point) start)
                        (setq multiple-lines t))
                      (forward-line -1))
                    (move-to-left-margin)
                    ;; This deleted code caused a long hanging-indent line
                    ;; not to be filled together with the following lines.
                    ;; ;; Don't move back over a line before the paragraph
                    ;; ;; which doesn't start with fill-prefix
                    ;; ;; unless that is the only line we've moved over.
                    ;; (and (not (looking-at fill-prefix-regexp))
                    ;;      multiple-lines
                    ;;      (forward-line 1))
                    (not (bobp)))
                (while (and (re-search-backward sp-parstart nil 1)
                            (setq found-start t)
                            ;; Found a candidate, but need to check if it is a
                            ;; REAL parstart.
                            (progn (setq start (point))
                                   (move-to-left-margin)
                                   (not (looking-at parsep)))
                            (not (and (looking-at parstart)
                                      (or (not use-hard-newlines)
                                          (bobp)
                                          (get-text-property
                                           (1- start) 'hard)))))
                  (setq found-start nil)
                  (goto-char start))
                found-start)
              ;; Found one.
              (progn
                ;; Move forward over paragraph separators.
                ;; We know this cannot reach the place we started
                ;; because we know we moved back over a non-separator.
                (while (and (not (eobp))
                            (progn (move-to-left-margin)
                                   (looking-at parsep)))
                  (forward-line 1))
                ;; If line before paragraph is just margin, back up to there.
                (end-of-line 0)
                (if (> (current-column) (current-left-margin))
                    (forward-char 1)
                  (skip-chars-backward " \t")
                  (if (not (bolp))
                      (forward-line 1))))
            ;; No starter or separator line => use buffer beg.
            (goto-char (point-min))))))

    (while (and (> arg 0) (not (eobp)))
      ;; Move forward over separator lines...
      (while (and (not (eobp))
                  (progn (move-to-left-margin) (not (eobp)))
                  (looking-at parsep))
        (forward-line 1))
      (unless (eobp) (setq arg (1- arg)))
      ;; ... and one more line.
      (forward-line 1)
      (if fill-prefix-regexp
          ;; There is a fill prefix; it overrides parstart.
          (while (and (not (eobp))
                      (progn (move-to-left-margin) (not (eobp)))
                      (not (looking-at parsep))
                      (looking-at fill-prefix-regexp))
            (forward-line 1))
        (while (and (re-search-forward sp-parstart nil 1)
                    (progn (setq start (match-beginning 0))
                           (goto-char start)
                           (not (eobp)))
                    (progn (move-to-left-margin)
                           (not (looking-at parsep)))
                    (or (not (looking-at parstart))
                        (and use-hard-newlines
                             (not (get-text-property (1- start) 'hard)))))
          (forward-char 1))
        (if (< (point) (point-max))
            (goto-char start))))
    (constrain-to-field nil opoint t)
    ;; Return the number of steps that could not be done.
    arg))
@end ignore

The @code{forward-paragraph} function moves point forward to the end
of the paragraph.  It is usually bound to @kbd{M-@}} and makes use of a
number of functions that are important in themselves, including
@code{let*}, @code{match-beginning}, and @code{looking-at}.

The function definition for @code{forward-paragraph} is considerably
longer than the function definition for @code{forward-sentence}
because it works with a paragraph, each line of which may begin with a
fill prefix.

A fill prefix consists of a string of characters that are repeated at
the beginning of each line.  For example, in Lisp code, it is a
convention to start each line of a paragraph-long comment with
@samp{;;; }.  In Text mode, four blank spaces make up another common
fill prefix, creating an indented paragraph.  (@xref{Fill Prefix, , ,
emacs, The GNU Emacs Manual}, for more information about fill
prefixes.)

The existence of a fill prefix means that in addition to being able to
find the end of a paragraph whose lines begin on the left-most
column, the @code{forward-paragraph} function must be able to find the
end of a paragraph when all or many of the lines in the buffer begin
with the fill prefix.

Moreover, it is sometimes practical to ignore a fill prefix that
exists, especially when blank lines separate paragraphs.
This is an added complication.

@menu
* forward-paragraph in brief::  Key parts of the function definition.
* fwd-para let::                The @code{let*} expression.
* fwd-para while::              The forward motion @code{while} loop.
@end menu

@node forward-paragraph in brief, fwd-para let, forward-paragraph, forward-paragraph
@ifnottex
@unnumberedsubsec Shortened @code{forward-paragraph} function definition
@end ifnottex

Rather than print all of the @code{forward-paragraph} function, we
will only print parts of it.  Read without preparation, the function
can be daunting!

@need 800
In outline, the function looks like this:

@smallexample
@group
(defun forward-paragraph (&optional arg)
  "@var{documentation}@dots{}"
  (interactive "p")
  (or arg (setq arg 1))
  (let*
      @var{varlist}
    (while (and (< arg 0) (not (bobp)))     ; @r{backward-moving-code}
      @dots{}
    (while (and (> arg 0) (not (eobp)))     ; @r{forward-moving-code}
      @dots{}
@end group
@end smallexample

The first parts of the function are routine: the function's argument
list consists of one optional argument.  Documentation follows.

The lower case @samp{p} in the @code{interactive} declaration means
that the processed prefix argument, if any, is passed to the function.
This will be a number, and is the repeat count of how many paragraphs
point will move.  The @code{or} expression in the next line handles
the common case when no argument is passed to the function, which occurs
if the function is called from other code rather than interactively.
This case was described earlier.  (@xref{forward-sentence, The
@code{forward-sentence} function}.)  Now we reach the end of the
familiar part of this function.

@node fwd-para let, fwd-para while, forward-paragraph in brief, forward-paragraph
@unnumberedsubsec The @code{let*} expression

The next line of the @code{forward-paragraph} function begins a
@code{let*} expression.  This is a different than @code{let}.  The
symbol is @code{let*} not @code{let}.

The @code{let*} special form is like @code{let} except that Emacs sets
each variable in sequence, one after another, and variables in the
latter part of the varlist can make use of the values to which Emacs
set variables in the earlier part of the varlist.

@ignore
( refappend save-excursion, , code save-excursion in code append-to-buffer .)
@end ignore

(@ref{append save-excursion, , @code{save-excursion} in @code{append-to-buffer}}.)

In the @code{let*} expression in this function, Emacs binds a total of
seven variables:  @code{opoint}, @code{fill-prefix-regexp},
@code{parstart}, @code{parsep}, @code{sp-parstart}, @code{start}, and
@code{found-start}.

The variable @code{parsep} appears twice, first, to remove instances
of @samp{^}, and second, to handle fill prefixes.

The variable @code{opoint} is just the value of @code{point}.  As you
can guess, it is used in a @code{constrain-to-field} expression, just
as in @code{forward-sentence}.

The variable @code{fill-prefix-regexp} is set to the value returned by
evaluating the following list:

@smallexample
@group
(and fill-prefix
     (not (equal fill-prefix ""))
     (not paragraph-ignore-fill-prefix)
     (regexp-quote fill-prefix))
@end group
@end smallexample

@noindent
This is an expression whose first element is the @code{and} special form.

As we learned earlier (@pxref{kill-new function, , The @code{kill-new}
function}), the @code{and} special form evaluates each of its
arguments until one of the arguments returns a value of @code{nil}, in
which case the @code{and} expression returns @code{nil}; however, if
none of the arguments returns a value of @code{nil}, the value
resulting from evaluating the last argument is returned.  (Since such
a value is not @code{nil}, it is considered true in Lisp.)  In other
words, an @code{and} expression returns a true value only if all its
arguments are true.
@findex and

In this case, the variable @code{fill-prefix-regexp} is bound to a
non-@code{nil} value only if the following four expressions produce a
true (i.e., a non-@code{nil}) value when they are evaluated; otherwise,
@code{fill-prefix-regexp} is bound to @code{nil}.

@table @code
@item fill-prefix
When this variable is evaluated, the value of the fill prefix, if any,
is returned.  If there is no fill prefix, this variable returns
@code{nil}.

@item (not (equal fill-prefix "")
This expression checks whether an existing fill prefix is an empty
string, that is, a string with no characters in it.  An empty string is
not a useful fill prefix.

@item (not paragraph-ignore-fill-prefix)
This expression returns @code{nil} if the variable
@code{paragraph-ignore-fill-prefix} has been turned on by being set to a
true value such as @code{t}.

@item (regexp-quote fill-prefix)
This is the last argument to the @code{and} special form.  If all the
arguments to the @code{and} are true, the value resulting from
evaluating this expression will be returned by the @code{and} expression
and bound to the variable @code{fill-prefix-regexp},
@end table

@findex regexp-quote
@noindent
The result of evaluating this @code{and} expression successfully is that
@code{fill-prefix-regexp} will be bound to the value of
@code{fill-prefix} as modified by the @code{regexp-quote} function.
What @code{regexp-quote} does is read a string and return a regular
expression that will exactly match the string and match nothing else.
This means that @code{fill-prefix-regexp} will be set to a value that
will exactly match the fill prefix if the fill prefix exists.
Otherwise, the variable will be set to @code{nil}.

The next two local variables in the @code{let*} expression are
designed to remove instances of @samp{^} from @code{parstart} and
@code{parsep}, the local variables which indicate the paragraph start
and the paragraph separator.  The next expression sets @code{parsep}
again.  That is to handle fill prefixes.

This is the setting that requires the definition call @code{let*}
rather than @code{let}.  The true-or-false-test for the @code{if}
depends on whether the variable @code{fill-prefix-regexp} evaluates to
@code{nil} or some other value.

If @code{fill-prefix-regexp} does not have a value, Emacs evaluates
the else-part of the @code{if} expression and binds @code{parsep} to
its local value.  (@code{parsep} is a regular expression that matches
what separates paragraphs.)

But if @code{fill-prefix-regexp} does have a value, Emacs evaluates
the then-part of the @code{if} expression and binds @code{parsep} to a
regular expression that includes the @code{fill-prefix-regexp} as part
of the pattern.

Specifically, @code{parsep} is set to the original value of the
paragraph separate regular expression concatenated with an alternative
expression that consists of the @code{fill-prefix-regexp} followed by
optional whitespace to the end of the line.  The whitespace is defined
by @w{@code{"[ \t]*$"}}.)  The @samp{\\|} defines this portion of the
regexp as an alternative to @code{parsep}.

According to a comment in the code, the next local variable,
@code{sp-parstart}, is used for searching, and then the final two,
@code{start} and @code{found-start}, are set to @code{nil}.

Now we get into the body of the @code{let*}.  The first part of the body
of the @code{let*} deals with the case when the function is given a
negative argument and is therefore moving backwards.  We will skip this
section.

@node fwd-para while,  , fwd-para let, forward-paragraph
@unnumberedsubsec The forward motion @code{while} loop

The second part of the body of the @code{let*} deals with forward
motion.  It is a @code{while} loop that repeats itself so long as the
value of @code{arg} is greater than zero.  In the most common use of
the function, the value of the argument is 1, so the body of the
@code{while} loop is evaluated exactly once, and the cursor moves
forward one paragraph.

@ignore
(while (and (> arg 0) (not (eobp)))

  ;; Move forward over separator lines...
  (while (and (not (eobp))
              (progn (move-to-left-margin) (not (eobp)))
              (looking-at parsep))
    (forward-line 1))
  (unless (eobp) (setq arg (1- arg)))
  ;; ... and one more line.
  (forward-line 1)

  (if fill-prefix-regexp
      ;; There is a fill prefix; it overrides parstart.
      (while (and (not (eobp))
                  (progn (move-to-left-margin) (not (eobp)))
                  (not (looking-at parsep))
                  (looking-at fill-prefix-regexp))
        (forward-line 1))

    (while (and (re-search-forward sp-parstart nil 1)
                (progn (setq start (match-beginning 0))
                       (goto-char start)
                       (not (eobp)))
                (progn (move-to-left-margin)
                       (not (looking-at parsep)))
                (or (not (looking-at parstart))
                    (and use-hard-newlines
                         (not (get-text-property (1- start) 'hard)))))
      (forward-char 1))

    (if (< (point) (point-max))
        (goto-char start))))
@end ignore

This part handles three situations: when point is between paragraphs,
when there is a fill prefix and when there is no fill prefix.

@need 800
The @code{while} loop looks like this:

@smallexample
@group
;; @r{going forwards and not at the end of the buffer}
(while (and (> arg 0) (not (eobp)))

  ;; @r{between paragraphs}
  ;; Move forward over separator lines...
  (while (and (not (eobp))
              (progn (move-to-left-margin) (not (eobp)))
              (looking-at parsep))
    (forward-line 1))
  ;;  @r{This decrements the loop}
  (unless (eobp) (setq arg (1- arg)))
  ;; ... and one more line.
  (forward-line 1)
@end group

@group
  (if fill-prefix-regexp
      ;; There is a fill prefix; it overrides parstart;
      ;; we go forward line by line
      (while (and (not (eobp))
                  (progn (move-to-left-margin) (not (eobp)))
                  (not (looking-at parsep))
                  (looking-at fill-prefix-regexp))
        (forward-line 1))
@end group

@group
    ;; There is no fill prefix;
    ;; we go forward character by character
    (while (and (re-search-forward sp-parstart nil 1)
                (progn (setq start (match-beginning 0))
                       (goto-char start)
                       (not (eobp)))
                (progn (move-to-left-margin)
                       (not (looking-at parsep)))
                (or (not (looking-at parstart))
                    (and use-hard-newlines
                         (not (get-text-property (1- start) 'hard)))))
      (forward-char 1))
@end group

@group
    ;; and if there is no fill prefix and if we are not at the end,
    ;;     go to whatever was found in the regular expression search
    ;;     for sp-parstart
    (if (< (point) (point-max))
        (goto-char start))))
@end group
@end smallexample

@findex eobp
We can see that this is a decrementing counter @code{while} loop,
using the expression @code{(setq arg (1- arg))} as the decrementer.
That expression is not far from the @code{while}, but is hidden in
another Lisp macro, an @code{unless} macro.  Unless we are at the end
of the buffer --- that is what the @code{eobp} function determines; it
is an abbreviation of @samp{End Of Buffer P} --- we decrease the value
of @code{arg} by one.

(If we are at the end of the buffer, we cannot go forward any more and
the next loop of the @code{while} expression will test false since the
test is an @code{and} with @code{(not (eobp))}.  The @code{not}
function means exactly as you expect; it is another name for
@code{null}, a function that returns true when its argument is false.)

Interestingly, the loop count is not decremented until we leave the
space between paragraphs, unless we come to the end of buffer or stop
seeing the local value of the paragraph separator.

That second @code{while} also has a @code{(move-to-left-margin)}
expression.  The function is self-explanatory.  It is inside a
@code{progn} expression and not the last element of its body, so it is
only invoked for its side effect, which is to move point to the left
margin of the current line.

@findex looking-at
The @code{looking-at} function is also self-explanatory; it returns
true if the text after point matches the regular expression given as
its argument.

The rest of the body of the loop looks difficult at first, but makes
sense as you come to understand it.

@need 800
First consider what happens if there is a fill prefix:

@smallexample
@group
  (if fill-prefix-regexp
      ;; There is a fill prefix; it overrides parstart;
      ;; we go forward line by line
      (while (and (not (eobp))
                  (progn (move-to-left-margin) (not (eobp)))
                  (not (looking-at parsep))
                  (looking-at fill-prefix-regexp))
        (forward-line 1))
@end group
@end smallexample

@noindent
This expression moves point forward line by line so long
as four conditions are true:

@enumerate
@item
Point is not at the end of the buffer.

@item
We can move to the left margin of the text and are
not at the end of the buffer.

@item
The text following point does not separate paragraphs.

@item
The pattern following point is the fill prefix regular expression.
@end enumerate

The last condition may be puzzling, until you remember that point was
moved to the beginning of the line early in the @code{forward-paragraph}
function.  This means that if the text has a fill prefix, the
@code{looking-at} function will see it.

@need 1250
Consider what happens when there is no fill prefix.

@smallexample
@group
    (while (and (re-search-forward sp-parstart nil 1)
                (progn (setq start (match-beginning 0))
                       (goto-char start)
                       (not (eobp)))
                (progn (move-to-left-margin)
                       (not (looking-at parsep)))
                (or (not (looking-at parstart))
                    (and use-hard-newlines
                         (not (get-text-property (1- start) 'hard)))))
      (forward-char 1))
@end group
@end smallexample

@noindent
This @code{while} loop has us searching forward for
@code{sp-parstart}, which is the combination of possible whitespace
with a the local value of the start of a paragraph or of a paragraph
separator.  (The latter two are within an expression starting
@code{\(?:} so that they are not referenced by the
@code{match-beginning} function.)

@need 800
The two expressions,

@smallexample
@group
(setq start (match-beginning 0))
(goto-char start)
@end group
@end smallexample

@noindent
mean go to the start of the text matched by the regular expression
search.

The @code{(match-beginning 0)} expression is new.  It returns a number
specifying the location of the start of the text that was matched by
the last search.

The @code{match-beginning} function is used here because of a
characteristic of a forward search: a successful forward search,
regardless of whether it is a plain search or a regular expression
search, moves point to the end of the text that is found.  In this
case, a successful search moves point to the end of the pattern for
@code{sp-parstart}.

However, we want to put point at the end of the current paragraph, not
somewhere else.  Indeed, since the search possibly includes the
paragraph separator, point may end up at the beginning of the next one
unless we use an expression that includes @code{match-beginning}.

@findex match-beginning
When given an argument of 0, @code{match-beginning} returns the
position that is the start of the text matched by the most recent
search.  In this case, the most recent search looks for
@code{sp-parstart}.  The @code{(match-beginning 0)} expression returns
the beginning position of that pattern, rather than the end position
of that pattern.

(Incidentally, when passed a positive number as an argument, the
@code{match-beginning} function returns the location of point at that
parenthesized expression in the last search unless that parenthesized
expression begins with @code{\(?:}.  I don't know why @code{\(?:}
appears here since the argument is 0.)

@need 1250
The last expression when there is no fill prefix is

@smallexample
@group
(if (< (point) (point-max))
    (goto-char start))))
@end group
@end smallexample

@noindent
This says that if there is no fill prefix and if we are not at the
end, point should move to the beginning of whatever was found by the
regular expression search for @code{sp-parstart}.

The full definition for the @code{forward-paragraph} function not only
includes code for going forwards, but also code for going backwards.

If you are reading this inside of GNU Emacs and you want to see the
whole function, you can type @kbd{C-h f} (@code{describe-function})
and the name of the function.  This gives you the function
documentation and the name of the library containing the function's
source.  Place point over the name of the library and press the RET
key; you will be taken directly to the source.  (Be sure to install
your sources!  Without them, you are like a person who tries to drive
a car with his eyes shut!)


@node etags, Regexp Review, forward-paragraph, Regexp Search
@section Create Your Own @file{TAGS} File
@findex etags
@cindex @file{TAGS} file, create own

Besides @kbd{C-h f} (@code{describe-function}), another way to see the
source of a function is to type @kbd{M-.} (@code{find-tag}) and the
name of the function when prompted for it.  This is a good habit to
get into.  The @kbd{M-.} (@code{find-tag}) command takes you directly
to the source for a function, variable, or node.  The function depends
on tags tables to tell it where to go.

If the @code{find-tag} function first asks you for the name of a
@file{TAGS} table, give it the name of a @file{TAGS} file such as
@file{/usr/local/src/emacs/src/TAGS}.  (The exact path to your
@file{TAGS} file depends on how your copy of Emacs was installed.  I
just told you the location that provides both my C and my Emacs Lisp
sources.)

You can also create your own @file{TAGS} file for directories that
lack one.

You often need to build and install tags tables yourself.  They are
not built automatically.  A tags table is called a @file{TAGS} file;
the name is in upper case letters.

You can create a @file{TAGS} file by calling the @code{etags} program
that comes as a part of the Emacs distribution.  Usually, @code{etags}
is compiled and installed when Emacs is built.  (@code{etags} is not
an Emacs Lisp function or a part of Emacs; it is a C program.)

@need 1250
To create a @file{TAGS} file, first switch to the directory in which
you want to create the file.  In Emacs you can do this with the
@kbd{M-x cd} command, or by visiting a file in the directory, or by
listing the directory with @kbd{C-x d} (@code{dired}).  Then run the
compile command, with @w{@code{etags *.el}} as the command to execute

@smallexample
M-x compile RET etags *.el RET
@end smallexample

@noindent
to create a @file{TAGS} file for Emacs Lisp.

For example, if you have a large number of files in your
@file{~/emacs} directory, as I do---I have 137 @file{.el} files in it,
of which I load 12---you can create a @file{TAGS} file for the Emacs
Lisp files in that directory.

@need 1250
The @code{etags} program takes all the usual shell `wildcards'.  For
example, if you have two directories for which you want a single
@file{TAGS} file, type @w{@code{etags *.el ../elisp/*.el}}, where
@file{../elisp/} is the second directory:

@smallexample
M-x compile RET etags *.el ../elisp/*.el RET
@end smallexample

@need 1250
Type

@smallexample
M-x compile RET etags --help RET
@end smallexample

@noindent
to see a list of the options accepted by @code{etags} as well as a
list of supported languages.

The @code{etags} program handles more than 20 languages, including
Emacs Lisp, Common Lisp, Scheme, C, C++, Ada, Fortran, HTML, Java,
LaTeX, Pascal, Perl, Postscript, Python, TeX, Texinfo, makefiles, and
most assemblers.  The program has no switches for specifying the
language; it recognizes the language in an input file according to its
file name and contents.

@file{etags} is very helpful when you are writing code yourself and
want to refer back to functions you have already written.  Just run
@code{etags} again at intervals as you write new functions, so they
become part of the @file{TAGS} file.

If you think an appropriate @file{TAGS} file already exists for what
you want, but do not know where it is, you can use the @code{locate}
program to attempt to find it.

Type @w{@kbd{M-x locate @key{RET} TAGS @key{RET}}} and Emacs will list
for you the full path names of all your @file{TAGS} files.  On my
system, this command lists 34 @file{TAGS} files.  On the other hand, a
`plain vanilla' system I recently installed did not contain any
@file{TAGS} files.

If the tags table you want has been created, you can use the @code{M-x
visit-tags-table} command to specify it.  Otherwise, you will need to
create the tag table yourself and then use @code{M-x
visit-tags-table}.

@subsubheading Building Tags in the Emacs sources
@cindex Building Tags in the Emacs sources
@cindex Tags in the Emacs sources
@findex make tags

The GNU Emacs sources come with a @file{Makefile} that contains a
sophisticated @code{etags} command that creates, collects, and merges
tags tables from all over the Emacs sources and puts the information
into one @file{TAGS} file in the @file{src/} directory. (The
@file{src/} directory is below the top level of your Emacs directory.)

@need 1250
To build this @file{TAGS} file, go to the top level of your Emacs
source directory and run the compile command @code{make tags}:

@smallexample
M-x compile RET make tags RET
@end smallexample

@noindent
(The @code{make tags} command works well with the GNU Emacs sources,
as well as with some other source packages.)

For more information, see @ref{Tags, , Tag Tables, emacs, The GNU Emacs
Manual}.


@node Regexp Review, re-search Exercises, etags, Regexp Search
@comment  node-name,  next,  previous,  up
@section Review

Here is a brief summary of some recently introduced functions.

@table @code
@item while
Repeatedly evaluate the body of the expression so long as the first
element of the body tests true.  Then return @code{nil}.  (The
expression is evaluated only for its side effects.)

@need 1250
For example:

@smallexample
@group
(let ((foo 2))
  (while (> foo 0)
    (insert (format "foo is %d.\n" foo))
    (setq foo (1- foo))))

     @result{}      foo is 2.
             foo is 1.
             nil
@end group
@end smallexample

@noindent
(The @code{insert} function inserts its arguments at point; the
@code{format} function returns a string formatted from its arguments
the way @code{message} formats its arguments; @code{\n} produces a new
line.)

@item re-search-forward
Search for a pattern, and if the pattern is found, move point to rest
just after it.

@noindent
Takes four arguments, like @code{search-forward}:

@enumerate
@item
A regular expression that specifies the pattern to search for.
(Remember to put quotation marks around this argument!)

@item
Optionally, the limit of the search.

@item
Optionally, what to do if the search fails, return @code{nil} or an
error message.

@item
Optionally, how many times to repeat the search; if negative, the
search goes backwards.
@end enumerate

@item let*
Bind some variables locally to particular values,
and then evaluate the remaining arguments, returning the value of the
last one.  While binding the local variables, use the local values of
variables bound earlier, if any.

@need 1250
For example:

@smallexample
@group
(let* ((foo 7)
      (bar (* 3 foo)))
  (message "`bar' is %d." bar))
     @result{} `bar' is 21.
@end group
@end smallexample

@item match-beginning
Return the position of the start of the text found by the last regular
expression search.

@item looking-at
Return @code{t} for true if the text after point matches the argument,
which should be a regular expression.

@item eobp
Return @code{t} for true if point is at the end of the accessible part
of a buffer.  The end of the accessible part is the end of the buffer
if the buffer is not narrowed; it is the end of the narrowed part if
the buffer is narrowed.
@end table


@need 1500
@node re-search Exercises,  , Regexp Review, Regexp Search
@section Exercises with @code{re-search-forward}

@itemize @bullet
@item
Write a function to search for a regular expression that matches two
or more blank lines in sequence.

@item
Write a function to search for duplicated words, such as `the the'.
@xref{Regexps, , Syntax of Regular Expressions, emacs, The GNU Emacs
Manual}, for information on how to write a regexp (a regular
expression) to match a string that is composed of two identical
halves.  You can devise several regexps; some are better than others.
The function I use is described in an appendix, along with several
regexps.  @xref{the-the, , @code{the-the} Duplicated Words Function}.
@end itemize


@node Counting Words, Words in a defun, Regexp Search, Top
@chapter Counting: Repetition and Regexps
@cindex Repetition for word counting
@cindex Regular expressions for word counting

Repetition and regular expression searches are powerful tools that you
often use when you write code in Emacs Lisp.  This chapter illustrates
the use of regular expression searches through the construction of
word count commands using @code{while} loops and recursion.

@menu
* Why Count Words::
* count-words-region::          Use a regexp, but find a problem.
* recursive-count-words::       Start with case of no words in region.
* Counting Exercise::
@end menu

@node Why Count Words, count-words-region, Counting Words, Counting Words
@ifnottex
@unnumberedsec Counting words
@end ifnottex

The standard Emacs distribution contains a function for counting the
number of lines within a region.  However, there is no corresponding
function for counting words.

Certain types of writing ask you to count words.  Thus, if you write
an essay, you may be limited to 800 words; if you write a novel, you
may discipline yourself to write 1000 words a day.  It seems odd to me
that Emacs lacks a word count command.  Perhaps people use Emacs
mostly for code or types of documentation that do not require word
counts; or perhaps they restrict themselves to the operating system
word count command, @code{wc}.  Alternatively, people may follow
the publishers' convention and compute a word count by dividing the
number of characters in a document by five.  In any event, here are
commands to count words.


@node count-words-region, recursive-count-words, Why Count Words, Counting Words
@comment  node-name,  next,  previous,  up
@section The @code{count-words-region} Function
@findex count-words-region

A word count command could count words in a line, paragraph, region,
or buffer.  What should the command cover?  You could design the
command to count the number of words in a complete buffer.  However,
the Emacs tradition encourages flexibility---you may want to count
words in just a section, rather than all of a buffer.  So it makes
more sense to design the command to count the number of words in a
region.  Once you have a @code{count-words-region} command, you can,
if you wish, count words in a whole buffer by marking it with
@w{@kbd{C-x h}} (@code{mark-whole-buffer}).

Clearly, counting words is a repetitive act: starting from the
beginning of the region, you count the first word, then the second
word, then the third word, and so on, until you reach the end of the
region.  This means that word counting is ideally suited to recursion
or to a @code{while} loop.

@menu
* Design count-words-region::   The definition using a @code{while} loop.
* Whitespace Bug::              The Whitespace Bug in @code{count-words-region}.
@end menu

@node Design count-words-region, Whitespace Bug, count-words-region, count-words-region
@ifnottex
@unnumberedsubsec Designing @code{count-words-region}
@end ifnottex

First, we will implement the word count command with a @code{while}
loop, then with recursion.  The command will, of course, be
interactive.

@need 800
The template for an interactive function definition is, as always:

@smallexample
@group
(defun @var{name-of-function} (@var{argument-list})
  "@var{documentation}@dots{}"
  (@var{interactive-expression}@dots{})
  @var{body}@dots{})
@end group
@end smallexample

What we need to do is fill in the slots.

The name of the function should be self-explanatory and similar to the
existing @code{count-lines-region} name.  This makes the name easier
to remember.  @code{count-words-region} is a good choice.

The function counts words within a region.  This means that the
argument list must contain symbols that are bound to the two
positions, the beginning and end of the region.  These two positions
can be called @samp{beginning} and @samp{end} respectively.  The first
line of the documentation should be a single sentence, since that is
all that is printed as documentation by a command such as
@code{apropos}.  The interactive expression will be of the form
@samp{(interactive "r")}, since that will cause Emacs to pass the
beginning and end of the region to the function's argument list.  All
this is routine.

The body of the function needs to be written to do three tasks:
first, to set up conditions under which the @code{while} loop can
count words, second, to run the @code{while} loop, and third, to send
a message to the user.

When a user calls @code{count-words-region}, point may be at the
beginning or the end of the region.  However, the counting process
must start at the beginning of the region.  This means we will want
to put point there if it is not already there.  Executing
@code{(goto-char beginning)} ensures this.  Of course, we will want to
return point to its expected position when the function finishes its
work.  For this reason, the body must be enclosed in a
@code{save-excursion} expression.

The central part of the body of the function consists of a
@code{while} loop in which one expression jumps point forward word by
word, and another expression counts those jumps.  The true-or-false-test
of the @code{while} loop should test true so long as point should jump
forward, and false when point is at the end of the region.

We could use @code{(forward-word 1)} as the expression for moving point
forward word by word, but it is easier to see what Emacs identifies as a
`word' if we use a regular expression search.

A regular expression search that finds the pattern for which it is
searching leaves point after the last character matched.  This means
that a succession of successful word searches will move point forward
word by word.

As a practical matter, we want the regular expression search to jump
over whitespace and punctuation between words as well as over the
words themselves.  A regexp that refuses to jump over interword
whitespace would never jump more than one word!  This means that
the regexp should include the whitespace and punctuation that follows
a word, if any, as well as the word itself.  (A word may end a buffer
and not have any following whitespace or punctuation, so that part of
the regexp must be optional.)

Thus, what we want for the regexp is a pattern defining one or more
word constituent characters followed, optionally, by one or more
characters that are not word constituents.  The regular expression for
this is:

@smallexample
\w+\W*
@end smallexample

@noindent
The buffer's syntax table determines which characters are and are not
word constituents.  (@xref{Syntax, , What Constitutes a Word or
Symbol?}, for more about syntax.  Also, see @ref{Syntax, Syntax, The
Syntax Table, emacs, The GNU Emacs Manual}, and @ref{Syntax Tables, ,
Syntax Tables, elisp, The GNU Emacs Lisp Reference Manual}.)

@need 800
The search expression looks like this:

@smallexample
(re-search-forward "\\w+\\W*")
@end smallexample

@noindent
(Note that paired backslashes precede the @samp{w} and @samp{W}.  A
single backslash has special meaning to the Emacs Lisp interpreter.
It indicates that the following character is interpreted differently
than usual.  For example, the two characters, @samp{\n}, stand for
@samp{newline}, rather than for a backslash followed by @samp{n}.  Two
backslashes in a row stand for an ordinary, `unspecial' backslash, so
Emacs Lisp interpreter ends of seeing a single backslash followed by a
letter.  So it discovers the letter is special.)

We need a counter to count how many words there are; this variable
must first be set to 0 and then incremented each time Emacs goes
around the @code{while} loop.  The incrementing expression is simply:

@smallexample
(setq count (1+ count))
@end smallexample

Finally, we want to tell the user how many words there are in the
region.  The @code{message} function is intended for presenting this
kind of information to the user.  The message has to be phrased so
that it reads properly regardless of how many words there are in the
region: we don't want to say that ``there are 1 words in the region''.
The conflict between singular and plural is ungrammatical.  We can
solve this problem by using a conditional expression that evaluates
different messages depending on the number of words in the region.
There are three possibilities: no words in the region, one word in the
region, and more than one word.  This means that the @code{cond}
special form is appropriate.

@need 1500
All this leads to the following function definition:

@smallexample
@group
;;; @r{First version; has bugs!}
(defun count-words-region (beginning end)
  "Print number of words in the region.
Words are defined as at least one word-constituent
character followed by at least one character that
is not a word-constituent.  The buffer's syntax
table determines which characters these are."
  (interactive "r")
  (message "Counting words in region ... ")
@end group

@group
;;; @r{1. Set up appropriate conditions.}
  (save-excursion
    (goto-char beginning)
    (let ((count 0))
@end group

@group
;;; @r{2. Run the} while @r{loop.}
      (while (< (point) end)
        (re-search-forward "\\w+\\W*")
        (setq count (1+ count)))
@end group

@group
;;; @r{3. Send a message to the user.}
      (cond ((zerop count)
             (message
              "The region does NOT have any words."))
            ((= 1 count)
             (message
              "The region has 1 word."))
            (t
             (message
              "The region has %d words." count))))))
@end group
@end smallexample

@noindent
As written, the function works, but not in all circumstances.

@node Whitespace Bug,  , Design count-words-region, count-words-region
@comment  node-name,  next,  previous,  up
@subsection The Whitespace Bug in @code{count-words-region}

The @code{count-words-region} command described in the preceding
section has two bugs, or rather, one bug with two manifestations.
First, if you mark a region containing only whitespace in the middle
of some text, the @code{count-words-region} command tells you that the
region contains one word!  Second, if you mark a region containing
only whitespace at the end of the buffer or the accessible portion of
a narrowed buffer, the command displays an error message that looks
like this:

@smallexample
Search failed: "\\w+\\W*"
@end smallexample

If you are reading this in Info in GNU Emacs, you can test for these
bugs yourself.

First, evaluate the function in the usual manner to install it.
@ifinfo
Here is a copy of the definition.  Place your cursor after the closing
parenthesis and type @kbd{C-x C-e} to install it.

@smallexample
@group
;; @r{First version; has bugs!}
(defun count-words-region (beginning end)
  "Print number of words in the region.
Words are defined as at least one word-constituent character followed
by at least one character that is not a word-constituent.  The buffer's
syntax table determines which characters these are."
@end group
@group
  (interactive "r")
  (message "Counting words in region ... ")
@end group

@group
;;; @r{1. Set up appropriate conditions.}
  (save-excursion
    (goto-char beginning)
    (let ((count 0))
@end group

@group
;;; @r{2. Run the} while @r{loop.}
      (while (< (point) end)
        (re-search-forward "\\w+\\W*")
        (setq count (1+ count)))
@end group

@group
;;; @r{3. Send a message to the user.}
      (cond ((zerop count)
             (message "The region does NOT have any words."))
            ((= 1 count) (message "The region has 1 word."))
            (t (message "The region has %d words." count))))))
@end group
@end smallexample
@end ifinfo

@need 1000
If you wish, you can also install this keybinding by evaluating it:

@smallexample
(global-set-key "\C-c=" 'count-words-region)
@end smallexample

To conduct the first test, set mark and point to the beginning and end
of the following line and then type @kbd{C-c =} (or @kbd{M-x
count-words-region} if you have not bound @kbd{C-c =}):

@smallexample
    one   two  three
@end smallexample

@noindent
Emacs will tell you, correctly, that the region has three words.

Repeat the test, but place mark at the beginning of the line and place
point just @emph{before} the word @samp{one}.  Again type the command
@kbd{C-c =} (or @kbd{M-x count-words-region}).  Emacs should tell you
that the region has no words, since it is composed only of the
whitespace at the beginning of the line.  But instead Emacs tells you
that the region has one word!

For the third test, copy the sample line to the end of the
@file{*scratch*} buffer and then type several spaces at the end of the
line.  Place mark right after the word @samp{three} and point at the
end of line.  (The end of the line will be the end of the buffer.)
Type @kbd{C-c =} (or @kbd{M-x count-words-region}) as you did before.
Again, Emacs should tell you that the region has no words, since it is
composed only of the whitespace at the end of the line.  Instead,
Emacs displays an error message saying @samp{Search failed}.

The two bugs stem from the same problem.

Consider the first manifestation of the bug, in which the command
tells you that the whitespace at the beginning of the line contains
one word.  What happens is this: The @code{M-x count-words-region}
command moves point to the beginning of the region.  The @code{while}
tests whether the value of point is smaller than the value of
@code{end}, which it is.  Consequently, the regular expression search
looks for and finds the first word.  It leaves point after the word.
@code{count} is set to one.  The @code{while} loop repeats; but this
time the value of point is larger than the value of @code{end}, the
loop is exited; and the function displays a message saying the number
of words in the region is one.  In brief, the regular expression
search looks for and finds the word even though it is outside
the marked region.

In the second manifestation of the bug, the region is whitespace at
the end of the buffer.  Emacs says @samp{Search failed}.  What happens
is that the true-or-false-test in the @code{while} loop tests true, so
the search expression is executed.  But since there are no more words
in the buffer, the search fails.

In both manifestations of the bug, the search extends or attempts to
extend outside of the region.

The solution is to limit the search to the region---this is a fairly
simple action, but as you may have come to expect, it is not quite as
simple as you might think.

As we have seen, the @code{re-search-forward} function takes a search
pattern as its first argument.  But in addition to this first,
mandatory argument, it accepts three optional arguments.  The optional
second argument bounds the search.  The optional third argument, if
@code{t}, causes the function to return @code{nil} rather than signal
an error if the search fails.  The optional fourth argument is a
repeat count.  (In Emacs, you can see a function's documentation by
typing @kbd{C-h f}, the name of the function, and then @key{RET}.)

In the @code{count-words-region} definition, the value of the end of
the region is held by the variable @code{end} which is passed as an
argument to the function.  Thus, we can add @code{end} as an argument
to the regular expression search expression:

@smallexample
(re-search-forward "\\w+\\W*" end)
@end smallexample

However, if you make only this change to the @code{count-words-region}
definition and then test the new version of the definition on a
stretch of whitespace, you will receive an error message saying
@samp{Search failed}.

What happens is this: the search is limited to the region, and fails
as you expect because there are no word-constituent characters in the
region.  Since it fails, we receive an error message.  But we do not
want to receive an error message in this case; we want to receive the
message that "The region does NOT have any words."

The solution to this problem is to provide @code{re-search-forward}
with a third argument of @code{t}, which causes the function to return
@code{nil} rather than signal an error if the search fails.

However, if you make this change and try it, you will see the message
``Counting words in region ... '' and @dots{} you will keep on seeing
that message @dots{}, until you type @kbd{C-g} (@code{keyboard-quit}).

Here is what happens: the search is limited to the region, as before,
and it fails because there are no word-constituent characters in the
region, as expected.  Consequently, the @code{re-search-forward}
expression returns @code{nil}.  It does nothing else.  In particular,
it does not move point, which it does as a side effect if it finds the
search target.  After the @code{re-search-forward} expression returns
@code{nil}, the next expression in the @code{while} loop is evaluated.
This expression increments the count.  Then the loop repeats.  The
true-or-false-test tests true because the value of point is still less
than the value of end, since the @code{re-search-forward} expression
did not move point. @dots{} and the cycle repeats @dots{}

The @code{count-words-region} definition requires yet another
modification, to cause the true-or-false-test of the @code{while} loop
to test false if the search fails.  Put another way, there are two
conditions that must be satisfied in the true-or-false-test before the
word count variable is incremented: point must still be within the
region and the search expression must have found a word to count.

Since both the first condition and the second condition must be true
together, the two expressions, the region test and the search
expression, can be joined with an @code{and} special form and embedded in
the @code{while} loop as the true-or-false-test, like this:

@smallexample
(and (< (point) end) (re-search-forward "\\w+\\W*" end t))
@end smallexample

@c colon in printed section title causes problem in Info cross reference
@c also trouble with an overfull hbox
@iftex
@noindent
(For information about @code{and}, see
@ref{kill-new function, , The @code{kill-new} function}.)
@end iftex
@ifinfo
@noindent
(@xref{kill-new function, , The @code{kill-new} function}, for
information about @code{and}.)
@end ifinfo

The @code{re-search-forward} expression returns @code{t} if the search
succeeds and as a side effect moves point.  Consequently, as words are
found, point is moved through the region.  When the search expression
fails to find another word, or when point reaches the end of the
region, the true-or-false-test tests false, the @code{while} loop
exits, and the @code{count-words-region} function displays one or
other of its messages.

After incorporating these final changes, the @code{count-words-region}
works without bugs (or at least, without bugs that I have found!).
Here is what it looks like:

@smallexample
@group
;;; @r{Final version:} @code{while}
(defun count-words-region (beginning end)
  "Print number of words in the region."
  (interactive "r")
  (message "Counting words in region ... ")
@end group

@group
;;; @r{1. Set up appropriate conditions.}
  (save-excursion
    (let ((count 0))
      (goto-char beginning)
@end group

@group
;;; @r{2. Run the} while @r{loop.}
      (while (and (< (point) end)
                  (re-search-forward "\\w+\\W*" end t))
        (setq count (1+ count)))
@end group

@group
;;; @r{3. Send a message to the user.}
      (cond ((zerop count)
             (message
              "The region does NOT have any words."))
            ((= 1 count)
             (message
              "The region has 1 word."))
            (t
             (message
              "The region has %d words." count))))))
@end group
@end smallexample


@node recursive-count-words, Counting Exercise, count-words-region, Counting Words
@comment  node-name,  next,  previous,  up
@section Count Words Recursively
@cindex Count words recursively
@cindex Recursively counting words
@cindex Words, counted recursively

You can write the function for counting words recursively as well as
with a @code{while} loop.  Let's see how this is done.

First, we need to recognize that the @code{count-words-region}
function has three jobs: it sets up the appropriate conditions for
counting to occur; it counts the words in the region; and it sends a
message to the user telling how many words there are.

If we write a single recursive function to do everything, we will
receive a message for every recursive call.  If the region contains 13
words, we will receive thirteen messages, one right after the other.
We don't want this!  Instead, we must write two functions to do the
job, one of which (the recursive function) will be used inside of the
other.  One function will set up the conditions and display the
message; the other will return the word count.

Let us start with the function that causes the message to be displayed.
We can continue to call this @code{count-words-region}.

This is the function that the user will call.  It will be interactive.
Indeed, it will be similar to our previous versions of this
function, except that it will call @code{recursive-count-words} to
determine how many words are in the region.

@need 1250
We can readily construct a template for this function, based on our
previous versions:

@smallexample
@group
;; @r{Recursive version; uses regular expression search}
(defun count-words-region (beginning end)
  "@var{documentation}@dots{}"
  (@var{interactive-expression}@dots{})
@end group
@group

;;; @r{1. Set up appropriate conditions.}
  (@var{explanatory message})
  (@var{set-up functions}@dots{}
@end group
@group

;;; @r{2. Count the words.}
    @var{recursive call}
@end group
@group

;;; @r{3. Send a message to the user.}
    @var{message providing word count}))
@end group
@end smallexample

The definition looks straightforward, except that somehow the count
returned by the recursive call must be passed to the message
displaying the word count.  A little thought suggests that this can be
done by making use of a @code{let} expression: we can bind a variable
in the varlist of a @code{let} expression to the number of words in
the region, as returned by the recursive call; and then the
@code{cond} expression, using binding, can display the value to the
user.

Often, one thinks of the binding within a @code{let} expression as
somehow secondary to the `primary' work of a function.  But in this
case, what you might consider the `primary' job of the function,
counting words, is done within the @code{let} expression.

@need 1250
Using @code{let}, the function definition looks like this:

@smallexample
@group
(defun count-words-region (beginning end)
  "Print number of words in the region."
  (interactive "r")
@end group

@group
;;; @r{1. Set up appropriate conditions.}
  (message "Counting words in region ... ")
  (save-excursion
    (goto-char beginning)
@end group

@group
;;; @r{2. Count the words.}
    (let ((count (recursive-count-words end)))
@end group

@group
;;; @r{3. Send a message to the user.}
      (cond ((zerop count)
             (message
              "The region does NOT have any words."))
            ((= 1 count)
             (message
              "The region has 1 word."))
            (t
             (message
              "The region has %d words." count))))))
@end group
@end smallexample

Next, we need to write the recursive counting function.

A recursive function has at least three parts: the `do-again-test', the
`next-step-expression', and the recursive call.

The do-again-test determines whether the function will or will not be
called again.  Since we are counting words in a region and can use a
function that moves point forward for every word, the do-again-test
can check whether point is still within the region.  The do-again-test
should find the value of point and determine whether point is before,
at, or after the value of the end of the region.  We can use the
@code{point} function to locate point.  Clearly, we must pass the
value of the end of the region to the recursive counting function as an
argument.

In addition, the do-again-test should also test whether the search finds a
word.  If it does not, the function should not call itself again.

The next-step-expression changes a value so that when the recursive
function is supposed to stop calling itself, it stops.  More
precisely, the next-step-expression changes a value so that at the
right time, the do-again-test stops the recursive function from
calling itself again.  In this case, the next-step-expression can be
the expression that moves point forward, word by word.

The third part of a recursive function is the recursive call.

Somewhere, also, we also need a part that does the `work' of the
function, a part that does the counting.  A vital part!

@need 1250
But already, we have an outline of the recursive counting function:

@smallexample
@group
(defun recursive-count-words (region-end)
  "@var{documentation}@dots{}"
   @var{do-again-test}
   @var{next-step-expression}
   @var{recursive call})
@end group
@end smallexample

Now we need to fill in the slots.  Let's start with the simplest cases
first:  if point is at or beyond the end of the region, there cannot
be any words in the region, so the function should return zero.
Likewise, if the search fails, there are no words to count, so the
function should return zero.

On the other hand, if point is within the region and the search
succeeds, the function should call itself again.

@need 800
Thus, the do-again-test should look like this:

@smallexample
@group
(and (< (point) region-end)
     (re-search-forward "\\w+\\W*" region-end t))
@end group
@end smallexample

Note that the search expression is part of the do-again-test---the
function returns @code{t} if its search succeeds and @code{nil} if it
fails.  (@xref{Whitespace Bug, , The Whitespace Bug in
@code{count-words-region}}, for an explanation of how
@code{re-search-forward} works.)

The do-again-test is the true-or-false test of an @code{if} clause.
Clearly, if the do-again-test succeeds, the then-part of the @code{if}
clause should call the function again; but if it fails, the else-part
should return zero since either point is outside the region or the
search failed because there were no words to find.

But before considering the recursive call, we need to consider the
next-step-expression.  What is it?  Interestingly, it is the search
part of the do-again-test.

In addition to returning @code{t} or @code{nil} for the
do-again-test, @code{re-search-forward} moves point forward as a side
effect of a successful search.  This is the action that changes the
value of point so that the recursive function stops calling itself
when point completes its movement through the region.  Consequently,
the @code{re-search-forward} expression is the next-step-expression.

@need 1200
In outline, then, the body of the @code{recursive-count-words}
function looks like this:

@smallexample
@group
(if @var{do-again-test-and-next-step-combined}
    ;; @r{then}
    @var{recursive-call-returning-count}
  ;; @r{else}
  @var{return-zero})
@end group
@end smallexample

How to incorporate the mechanism that counts?

If you are not used to writing recursive functions, a question like
this can be troublesome.  But it can and should be approached
systematically.

We know that the counting mechanism should be associated in some way
with the recursive call.  Indeed, since the next-step-expression moves
point forward by one word, and since a recursive call is made for
each word, the counting mechanism must be an expression that adds one
to the value returned by a call to @code{recursive-count-words}.

@need 800
Consider several cases:

@itemize @bullet
@item
If there are two words in the region, the function should return
a value resulting from adding one to the value returned when it counts
the first word, plus the number returned when it counts the remaining
words in the region, which in this case is one.

@item
If there is one word in the region, the function should return
a value resulting from adding one to the value returned when it counts
that word, plus the number returned when it counts the remaining
words in the region, which in this case is zero.

@item
If there are no words in the region, the function should return zero.
@end itemize

From the sketch we can see that the else-part of the @code{if} returns
zero for the case of no words.  This means that the then-part of the
@code{if} must return a value resulting from adding one to the value
returned from a count of the remaining words.

@need 1200
The expression will look like this, where @code{1+} is a function that
adds one to its argument.

@smallexample
(1+ (recursive-count-words region-end))
@end smallexample

@need 1200
The whole @code{recursive-count-words} function will then look like
this:

@smallexample
@group
(defun recursive-count-words (region-end)
  "@var{documentation}@dots{}"

;;; @r{1. do-again-test}
  (if (and (< (point) region-end)
           (re-search-forward "\\w+\\W*" region-end t))
@end group

@group
;;; @r{2. then-part: the recursive call}
      (1+ (recursive-count-words region-end))

;;; @r{3. else-part}
    0))
@end group
@end smallexample

@need 1250
Let's examine how this works:

If there are no words in the region, the else part of the @code{if}
expression is evaluated and consequently the function returns zero.

If there is one word in the region, the value of point is less than
the value of @code{region-end} and the search succeeds.  In this case,
the true-or-false-test of the @code{if} expression tests true, and the
then-part of the @code{if} expression is evaluated.  The counting
expression is evaluated.  This expression returns a value (which will
be the value returned by the whole function) that is the sum of one
added to the value returned by a recursive call.

Meanwhile, the next-step-expression has caused point to jump over the
first (and in this case only) word in the region.  This means that
when @code{(recursive-count-words region-end)} is evaluated a second
time, as a result of the recursive call, the value of point will be
equal to or greater than the value of region end.  So this time,
@code{recursive-count-words} will return zero.  The zero will be added
to one, and the original evaluation of @code{recursive-count-words}
will return one plus zero, which is one, which is the correct amount.

Clearly, if there are two words in the region, the first call to
@code{recursive-count-words} returns one added to the value returned
by calling @code{recursive-count-words} on a region containing the
remaining word---that is, it adds one to one, producing two, which is
the correct amount.

Similarly, if there are three words in the region, the first call to
@code{recursive-count-words} returns one added to the value returned
by calling @code{recursive-count-words} on a region containing the
remaining two words---and so on and so on.

@need 1250
@noindent
With full documentation the two functions look like this:

@need 1250
@noindent
The recursive function:

@findex recursive-count-words
@smallexample
@group
(defun recursive-count-words (region-end)
  "Number of words between point and REGION-END."
@end group

@group
;;; @r{1. do-again-test}
  (if (and (< (point) region-end)
           (re-search-forward "\\w+\\W*" region-end t))
@end group

@group
;;; @r{2. then-part: the recursive call}
      (1+ (recursive-count-words region-end))

;;; @r{3. else-part}
    0))
@end group
@end smallexample

@need 800
@noindent
The wrapper:

@smallexample
@group
;;; @r{Recursive version}
(defun count-words-region (beginning end)
  "Print number of words in the region.
@end group

@group
Words are defined as at least one word-constituent
character followed by at least one character that is
not a word-constituent.  The buffer's syntax table
determines which characters these are."
@end group
@group
  (interactive "r")
  (message "Counting words in region ... ")
  (save-excursion
    (goto-char beginning)
    (let ((count (recursive-count-words end)))
@end group
@group
      (cond ((zerop count)
             (message
              "The region does NOT have any words."))
@end group
@group
            ((= 1 count)
             (message "The region has 1 word."))
            (t
             (message
              "The region has %d words." count))))))
@end group
@end smallexample


@node Counting Exercise,  , recursive-count-words, Counting Words
@section Exercise: Counting Punctuation

Using a @code{while} loop, write a function to count the number of
punctuation marks in a region---period, comma, semicolon, colon,
exclamation mark, and question mark.  Do the same using recursion.


@node Words in a defun, Readying a Graph, Counting Words, Top
@chapter Counting Words in a @code{defun}
@cindex Counting words in a @code{defun}
@cindex Word counting in a @code{defun}

Our next project is to count the number of words in a function
definition.  Clearly, this can be done using some variant of
@code{count-word-region}.  @xref{Counting Words, , Counting Words:
Repetition and Regexps}.  If we are just going to count the words in
one definition, it is easy enough to mark the definition with the
@kbd{C-M-h} (@code{mark-defun}) command, and then call
@code{count-word-region}.

However, I am more ambitious: I want to count the words and symbols in
every definition in the Emacs sources and then print a graph that
shows how many functions there are of each length: how many contain 40
to 49 words or symbols, how many contain 50 to 59 words or symbols,
and so on.  I have often been curious how long a typical function is,
and this will tell.

@menu
* Divide and Conquer::
* Words and Symbols::           What to count?
* Syntax::                      What constitutes a word or symbol?
* count-words-in-defun::        Very like @code{count-words}.
* Several defuns::              Counting several defuns in a file.
* Find a File::                 Do you want to look at a file?
* lengths-list-file::           A list of the lengths of many definitions.
* Several files::               Counting in definitions in different files.
* Several files recursively::   Recursively counting in different files.
* Prepare the data::            Prepare the data for display in a graph.
@end menu

@node Divide and Conquer, Words and Symbols, Words in a defun, Words in a defun
@ifnottex
@unnumberedsec Divide and Conquer
@end ifnottex

Described in one phrase, the histogram project is daunting; but
divided into numerous small steps, each of which we can take one at a
time, the project becomes less fearsome.  Let us consider what the
steps must be:

@itemize @bullet
@item
First, write a function to count the words in one definition.  This
includes the problem of handling symbols as well as words.

@item
Second, write a function to list the numbers of words in each function
in a file.  This function can use the @code{count-words-in-defun}
function.

@item
Third, write a function to list the numbers of words in each function
in each of several files.  This entails automatically finding the
various files, switching to them, and counting the words in the
definitions within them.

@item
Fourth, write a function to convert the list of numbers that we
created in step three to a form that will be suitable for printing as
a graph.

@item
Fifth, write a function to print the results as a graph.
@end itemize

This is quite a project!  But if we take each step slowly, it will not
be difficult.


@node Words and Symbols, Syntax, Divide and Conquer, Words in a defun
@section What to Count?
@cindex Words and symbols in defun

When we first start thinking about how to count the words in a
function definition, the first question is (or ought to be) what are
we going to count?  When we speak of `words' with respect to a Lisp
function definition, we are actually speaking, in large part, of
`symbols'.  For example, the following @code{multiply-by-seven}
function contains the five symbols @code{defun},
@code{multiply-by-seven}, @code{number}, @code{*}, and @code{7}.  In
addition, in the documentation string, it contains the four words
@samp{Multiply}, @samp{NUMBER}, @samp{by}, and @samp{seven}.  The
symbol @samp{number} is repeated, so the definition contains a total
of ten words and symbols.

@smallexample
@group
(defun multiply-by-seven (number)
  "Multiply NUMBER by seven."
  (* 7 number))
@end group
@end smallexample

@noindent
However, if we mark the @code{multiply-by-seven} definition with
@kbd{C-M-h} (@code{mark-defun}), and then call
@code{count-words-region} on it, we will find that
@code{count-words-region} claims the definition has eleven words, not
ten!  Something is wrong!

The problem is twofold: @code{count-words-region} does not count the
@samp{*} as a word, and it counts the single symbol,
@code{multiply-by-seven}, as containing three words.  The hyphens are
treated as if they were interword spaces rather than intraword
connectors: @samp{multiply-by-seven} is counted as if it were written
@samp{multiply by seven}.

The cause of this confusion is the regular expression search within
the @code{count-words-region} definition that moves point forward word
by word.  In the canonical version of @code{count-words-region}, the
regexp is:

@smallexample
"\\w+\\W*"
@end smallexample

@noindent
This regular expression is a pattern defining one or more word
constituent characters possibly followed by one or more characters
that are not word constituents.  What is meant by `word constituent
characters' brings us to the issue of syntax, which is worth a section
of its own.


@node Syntax, count-words-in-defun, Words and Symbols, Words in a defun
@section What Constitutes a Word or Symbol?
@cindex Syntax categories and tables

Emacs treats different characters as belonging to different
@dfn{syntax categories}.  For example, the regular expression,
@samp{\\w+}, is a pattern specifying one or more @emph{word
constituent} characters.  Word constituent characters are members of
one syntax category.  Other syntax categories include the class of
punctuation characters, such as the period and the comma, and the
class of whitespace characters, such as the blank space and the tab
character.  (For more information, see @ref{Syntax, Syntax, The Syntax
Table, emacs, The GNU Emacs Manual}, and @ref{Syntax Tables, , Syntax
Tables, elisp, The GNU Emacs Lisp Reference Manual}.)

Syntax tables specify which characters belong to which categories.
Usually, a hyphen is not specified as a `word constituent character'.
Instead, it is specified as being in the `class of characters that are
part of symbol names but not words.'  This means that the
@code{count-words-region} function treats it in the same way it treats
an interword white space, which is why @code{count-words-region}
counts @samp{multiply-by-seven} as three words.

There are two ways to cause Emacs to count @samp{multiply-by-seven} as
one symbol: modify the syntax table or modify the regular expression.

We could redefine a hyphen as a word constituent character by
modifying the syntax table that Emacs keeps for each mode.  This
action would serve our purpose, except that a hyphen is merely the
most common character within symbols that is not typically a word
constituent character; there are others, too.

Alternatively, we can redefine the regular expression used in the
@code{count-words} definition so as to include symbols.  This
procedure has the merit of clarity, but the task is a little tricky.

@need 1200
The first part is simple enough: the pattern must match ``at least one
character that is a word or symbol constituent''.  Thus:

@smallexample
"\\(\\w\\|\\s_\\)+"
@end smallexample

@noindent
The @samp{\\(} is the first part of the grouping construct that
includes the @samp{\\w} and the @samp{\\s_} as alternatives, separated
by the @samp{\\|}.  The @samp{\\w} matches any word-constituent
character and the @samp{\\s_} matches any character that is part of a
symbol name but not a word-constituent character.  The @samp{+}
following the group indicates that the word or symbol constituent
characters must be matched at least once.

However, the second part of the regexp is more difficult to design.
What we want is to follow the first part with ``optionally one or more
characters that are not constituents of a word or symbol''.  At first,
I thought I could define this with the following:

@smallexample
"\\(\\W\\|\\S_\\)*"
@end smallexample

@noindent
The upper case @samp{W} and @samp{S} match characters that are
@emph{not} word or symbol constituents.  Unfortunately, this
expression matches any character that is either not a word constituent
or not a symbol constituent.  This matches any character!

I then noticed that every word or symbol in my test region was
followed by white space (blank space, tab, or newline).  So I tried
placing a pattern to match one or more blank spaces after the pattern
for one or more word or symbol constituents.  This failed, too.  Words
and symbols are often separated by whitespace, but in actual code
parentheses may follow symbols and punctuation may follow words.  So
finally, I designed a pattern in which the word or symbol constituents
are followed optionally by characters that are not white space and
then followed optionally by white space.

@need 800
Here is the full regular expression:

@smallexample
"\\(\\w\\|\\s_\\)+[^ \t\n]*[ \t\n]*"
@end smallexample


@node count-words-in-defun, Several defuns, Syntax, Words in a defun
@section The @code{count-words-in-defun} Function
@cindex Counting words in a @code{defun}

We have seen that there are several ways to write a
@code{count-word-region} function.  To write a
@code{count-words-in-defun}, we need merely adapt one of these
versions.

The version that uses a @code{while} loop is easy to understand, so I
am going to adapt that.  Because @code{count-words-in-defun} will be
part of a more complex program, it need not be interactive and it need
not display a message but just return the count.  These considerations
simplify the definition a little.

On the other hand, @code{count-words-in-defun} will be used within a
buffer that contains function definitions.  Consequently, it is
reasonable to ask that the function determine whether it is called
when point is within a function definition, and if it is, to return
the count for that definition.  This adds complexity to the
definition, but saves us from needing to pass arguments to the
function.

@need 1250
These considerations lead us to prepare the following template:

@smallexample
@group
(defun count-words-in-defun ()
  "@var{documentation}@dots{}"
  (@var{set up}@dots{}
     (@var{while loop}@dots{})
   @var{return count})
@end group
@end smallexample

@noindent
As usual, our job is to fill in the slots.

First, the set up.

We are presuming that this function will be called within a buffer
containing function definitions.  Point will either be within a
function definition or not.  For @code{count-words-in-defun} to work,
point must move to the beginning of the definition, a counter must
start at zero, and the counting loop must stop when point reaches the
end of the definition.

The @code{beginning-of-defun} function searches backwards for an
opening delimiter such as a @samp{(} at the beginning of a line, and
moves point to that position, or else to the limit of the search.  In
practice, this means that @code{beginning-of-defun} moves point to the
beginning of an enclosing or preceding function definition, or else to
the beginning of the buffer.  We can use @code{beginning-of-defun} to
place point where we wish to start.

The @code{while} loop requires a counter to keep track of the words or
symbols being counted.  A @code{let} expression can be used to create
a local variable for this purpose, and bind it to an initial value of zero.

The @code{end-of-defun} function works like @code{beginning-of-defun}
except that it moves point to the end of the definition.
@code{end-of-defun} can be used as part of an expression that
determines the position of the end of the definition.

The set up for @code{count-words-in-defun} takes shape rapidly: first
we move point to the beginning of the definition, then we create a
local variable to hold the count, and finally, we record the position
of the end of the definition so the @code{while} loop will know when to stop
looping.

@need 1250
The code looks like this:

@smallexample
@group
(beginning-of-defun)
(let ((count 0)
      (end (save-excursion (end-of-defun) (point))))
@end group
@end smallexample

@noindent
The code is simple.  The only slight complication is likely to concern
@code{end}: it is bound to the position of the end of the definition
by a @code{save-excursion} expression that returns the value of point
after @code{end-of-defun} temporarily moves it to the end of the
definition.

The second part of the @code{count-words-in-defun}, after the set up,
is the @code{while} loop.

The loop must contain an expression that jumps point forward word by
word and symbol by symbol, and another expression that counts the
jumps.  The true-or-false-test for the @code{while} loop should test
true so long as point should jump forward, and false when point is at
the end of the definition.  We have already redefined the regular
expression for this (@pxref{Syntax}), so the loop is straightforward:

@smallexample
@group
(while (and (< (point) end)
            (re-search-forward
             "\\(\\w\\|\\s_\\)+[^ \t\n]*[ \t\n]*" end t)
  (setq count (1+ count)))
@end group
@end smallexample

The third part of the function definition returns the count of words
and symbols.  This part is the last expression within the body of the
@code{let} expression, and can be, very simply, the local variable
@code{count}, which when evaluated returns the count.

@need 1250
Put together, the @code{count-words-in-defun} definition looks like this:

@findex count-words-in-defun
@smallexample
@group
(defun count-words-in-defun ()
  "Return the number of words and symbols in a defun."
  (beginning-of-defun)
  (let ((count 0)
        (end (save-excursion (end-of-defun) (point))))
@end group
@group
    (while
        (and (< (point) end)
             (re-search-forward
              "\\(\\w\\|\\s_\\)+[^ \t\n]*[ \t\n]*"
              end t))
      (setq count (1+ count)))
    count))
@end group
@end smallexample

How to test this?  The function is not interactive, but it is easy to
put a wrapper around the function to make it interactive; we can use
almost the same code as for the recursive version of
@code{count-words-region}:

@smallexample
@group
;;; @r{Interactive version.}
(defun count-words-defun ()
  "Number of words and symbols in a function definition."
  (interactive)
  (message
   "Counting words and symbols in function definition ... ")
@end group
@group
  (let ((count (count-words-in-defun)))
    (cond
     ((zerop count)
      (message
       "The definition does NOT have any words or symbols."))
@end group
@group
     ((= 1 count)
      (message
       "The definition has 1 word or symbol."))
     (t
      (message
       "The definition has %d words or symbols." count)))))
@end group
@end smallexample

@need 800
@noindent
Let's re-use @kbd{C-c =} as a convenient keybinding:

@smallexample
(global-set-key "\C-c=" 'count-words-defun)
@end smallexample

Now we can try out @code{count-words-defun}: install both
@code{count-words-in-defun} and @code{count-words-defun}, and set the
keybinding, and then place the cursor within the following definition:

@smallexample
@group
(defun multiply-by-seven (number)
  "Multiply NUMBER by seven."
  (* 7 number))
     @result{} 10
@end group
@end smallexample

@noindent
Success!  The definition has 10 words and symbols.

The next problem is to count the numbers of words and symbols in
several definitions within a single file.


@node Several defuns, Find a File, count-words-in-defun, Words in a defun
@section Count Several @code{defuns} Within a File

A file such as @file{simple.el} may have a hundred or more function
definitions within it.  Our long term goal is to collect statistics on
many files, but as a first step, our immediate goal is to collect
statistics on one file.

The information will be a series of numbers, each number being the
length of a function definition.  We can store the numbers in a list.

We know that we will want to incorporate the information regarding one
file with information about many other files; this means that the
function for counting definition lengths within one file need only
return the list of lengths.  It need not and should not display any
messages.

The word count commands contain one expression to jump point forward
word by word and another expression to count the jumps.  The function
to return the lengths of definitions can be designed to work the same
way, with one expression to jump point forward definition by
definition and another expression to construct the lengths' list.

This statement of the problem makes it elementary to write the
function definition.  Clearly, we will start the count at the
beginning of the file, so the first command will be @code{(goto-char
(point-min))}.  Next, we start the @code{while} loop; and the
true-or-false test of the loop can be a regular expression search for
the next function definition---so long as the search succeeds, point
is moved forward and then the body of the loop is evaluated.  The body
needs an expression that constructs the lengths' list.  @code{cons},
the list construction command, can be used to create the list.  That
is almost all there is to it.

@need 800
Here is what this fragment of code looks like:

@smallexample
@group
(goto-char (point-min))
(while (re-search-forward "^(defun" nil t)
  (setq lengths-list
        (cons (count-words-in-defun) lengths-list)))
@end group
@end smallexample

What we have left out is the mechanism for finding the file that
contains the function definitions.

In previous examples, we either used this, the Info file, or we
switched back and forth to some other buffer, such as the
@file{*scratch*} buffer.

Finding a file is a new process that we have not yet discussed.


@node Find a File, lengths-list-file, Several defuns, Words in a defun
@comment  node-name,  next,  previous,  up
@section Find a File
@cindex Find a File

To find a file in Emacs, you use the @kbd{C-x C-f} (@code{find-file})
command.  This command is almost, but not quite right for the lengths
problem.

@need 1200
Let's look at the source for @code{find-file}:

@smallexample
@group
(defun find-file (filename)
  "Edit file FILENAME.
Switch to a buffer visiting file FILENAME,
creating one if none already exists."
  (interactive "FFind file: ")
  (switch-to-buffer (find-file-noselect filename)))
@end group
@end smallexample

@noindent
(The most recent version of the @code{find-file} function definition
permits you to specify optional wildcards to visit multiple files; that
makes the definition more complex and we will not discuss it here,
since it is not relevant.  You can see its source using either
@kbd{M-.} (@code{find-tag}) or @kbd{C-h f} (@code{describe-function}).)

@ignore
In Emacs 22
(defun find-file (filename &optional wildcards)
  "Edit file FILENAME.
Switch to a buffer visiting file FILENAME,
creating one if none already exists.
Interactively, the default if you just type RET is the current directory,
but the visited file name is available through the minibuffer history:
type M-n to pull it into the minibuffer.

Interactively, or if WILDCARDS is non-nil in a call from Lisp,
expand wildcards (if any) and visit multiple files.  You can
suppress wildcard expansion by setting `find-file-wildcards' to nil.

To visit a file without any kind of conversion and without
automatically choosing a major mode, use \\[find-file-literally]."
  (interactive (find-file-read-args "Find file: " nil))
  (let ((value (find-file-noselect filename nil nil wildcards)))
    (if (listp value)
        (mapcar 'switch-to-buffer (nreverse value))
      (switch-to-buffer value))))
@end ignore

The definition I am showing possesses short but complete documentation
and an interactive specification that prompts you for a file name when
you use the command interactively.  The body of the definition
contains two functions, @code{find-file-noselect} and
@code{switch-to-buffer}.

According to its documentation as shown by @kbd{C-h f} (the
@code{describe-function} command), the @code{find-file-noselect}
function reads the named file into a buffer and returns the buffer.
(Its most recent version includes an optional wildcards argument,
too, as well as another to read a file literally and an other you
suppress warning messages.  These optional arguments are irrelevant.)

However, the @code{find-file-noselect} function does not select the
buffer in which it puts the file.  Emacs does not switch its attention
(or yours if you are using @code{find-file-noselect}) to the selected
buffer.  That is what @code{switch-to-buffer} does: it switches the
buffer to which Emacs attention is directed; and it switches the
buffer displayed in the window to the new buffer.  We have discussed
buffer switching elsewhere.  (@xref{Switching Buffers}.)

In this histogram project, we do not need to display each file on the
screen as the program determines the length of each definition within
it.  Instead of employing @code{switch-to-buffer}, we can work with
@code{set-buffer}, which redirects the attention of the computer
program to a different buffer but does not redisplay it on the screen.
So instead of calling on @code{find-file} to do the job, we must write
our own expression.

The task is easy: use @code{find-file-noselect} and @code{set-buffer}.


@node lengths-list-file, Several files, Find a File, Words in a defun
@section @code{lengths-list-file} in Detail

The core of the @code{lengths-list-file} function is a @code{while}
loop containing a function to move point forward `defun by defun' and
a function to count the number of words and symbols in each defun.
This core must be surrounded by functions that do various other tasks,
including finding the file, and ensuring that point starts out at the
beginning of the file.  The function definition looks like this:
@findex lengths-list-file

@smallexample
@group
(defun lengths-list-file (filename)
  "Return list of definitions' lengths within FILE.
The returned list is a list of numbers.
Each number is the number of words or
symbols in one function definition."
@end group
@group
  (message "Working on `%s' ... " filename)
  (save-excursion
    (let ((buffer (find-file-noselect filename))
          (lengths-list))
      (set-buffer buffer)
      (setq buffer-read-only t)
      (widen)
      (goto-char (point-min))
      (while (re-search-forward "^(defun" nil t)
        (setq lengths-list
              (cons (count-words-in-defun) lengths-list)))
      (kill-buffer buffer)
      lengths-list)))
@end group
@end smallexample

@noindent
The function is passed one argument, the name of the file on which it
will work.  It has four lines of documentation, but no interactive
specification.  Since people worry that a computer is broken if they
don't see anything going on, the first line of the body is a
message.

The next line contains a @code{save-excursion} that returns Emacs'
attention to the current buffer when the function completes.  This is
useful in case you embed this function in another function that
presumes point is restored to the original buffer.

In the varlist of the @code{let} expression, Emacs finds the file and
binds the local variable @code{buffer} to the buffer containing the
file.  At the same time, Emacs creates @code{lengths-list} as a local
variable.

Next, Emacs switches its attention to the buffer.

In the following line, Emacs makes the buffer read-only.  Ideally,
this line is not necessary.  None of the functions for counting words
and symbols in a function definition should change the buffer.
Besides, the buffer is not going to be saved, even if it were changed.
This line is entirely the consequence of great, perhaps excessive,
caution.  The reason for the caution is that this function and those
it calls work on the sources for Emacs and it is inconvenient if they
are inadvertently modified.  It goes without saying that I did not
realize a need for this line until an experiment went awry and started
to modify my Emacs source files @dots{}

Next comes a call to widen the buffer if it is narrowed.  This
function is usually not needed---Emacs creates a fresh buffer if none
already exists; but if a buffer visiting the file already exists Emacs
returns that one.  In this case, the buffer may be narrowed and must
be widened.  If we wanted to be fully `user-friendly', we would
arrange to save the restriction and the location of point, but we
won't.

The @code{(goto-char (point-min))} expression moves point to the
beginning of the buffer.

Then comes a @code{while} loop in which the `work' of the function is
carried out.  In the loop, Emacs determines the length of each
definition and constructs a lengths' list containing the information.

Emacs kills the buffer after working through it.  This is to save
space inside of Emacs.  My version of GNU Emacs 19 contained over 300
source files of interest; GNU Emacs 22 contains over a thousand source
files.  Another function will apply @code{lengths-list-file} to each
of the files.

Finally, the last expression within the @code{let} expression is the
@code{lengths-list} variable; its value is returned as the value of
the whole function.

You can try this function by installing it in the usual fashion.  Then
place your cursor after the following expression and type @kbd{C-x
C-e} (@code{eval-last-sexp}).

@c !!! 22.1.1 lisp sources location here
@smallexample
(lengths-list-file
 "/usr/local/share/emacs/22.1.1/lisp/emacs-lisp/debug.el")
@end smallexample

@noindent
(You may need to change the pathname of the file; the one here is for
GNU Emacs version 22.1.1.  To change the expression, copy it to
the @file{*scratch*} buffer and edit it.

@need 1200
@noindent
(Also, to see the full length of the list, rather than a truncated
version, you may have to evaluate the following:

@smallexample
(custom-set-variables '(eval-expression-print-length nil))
@end smallexample

@noindent
(@xref{defcustom, , Specifying Variables using @code{defcustom}}.
Then evaluate the @code{lengths-list-file} expression.)

@need 1200
The lengths' list for @file{debug.el} takes less than a second to
produce and looks like this in GNU Emacs 22:

@smallexample
(83 113 105 144 289 22 30 97 48 89 25 52 52 88 28 29 77 49 43 290 232 587)
@end smallexample

@need 1500
(Using my old machine, the version 19 lengths' list for @file{debug.el}
took seven seconds to produce and looked like this:

@smallexample
(75 41 80 62 20 45 44 68 45 12 34 235)
@end smallexample

(The newer version of @file{debug.el} contains more defuns than the
earlier one; and my new machine is much faster than the old one.)

Note that the length of the last definition in the file is first in
the list.


@node Several files, Several files recursively, lengths-list-file, Words in a defun
@section Count Words in @code{defuns} in Different Files

In the previous section, we created a function that returns a list of
the lengths of each definition in a file.  Now, we want to define a
function to return a master list of the lengths of the definitions in
a list of files.

Working on each of a list of files is a repetitious act, so we can use
either a @code{while} loop or recursion.

@menu
* lengths-list-many-files::     Return a list of the lengths of defuns.
* append::                      Attach one list to another.
@end menu

@node lengths-list-many-files, append, Several files, Several files
@ifnottex
@unnumberedsubsec Determine the lengths of @code{defuns}
@end ifnottex

The design using a @code{while} loop is routine.  The argument passed
the function is a list of files.  As we saw earlier (@pxref{Loop
Example}), you can write a @code{while} loop so that the body of the
loop is evaluated if such a list contains elements, but to exit the
loop if the list is empty.  For this design to work, the body of the
loop must contain an expression that shortens the list each time the
body is evaluated, so that eventually the list is empty.  The usual
technique is to set the value of the list to the value of the @sc{cdr}
of the list each time the body is evaluated.

@need 800
The template looks like this:

@smallexample
@group
(while @var{test-whether-list-is-empty}
  @var{body}@dots{}
  @var{set-list-to-cdr-of-list})
@end group
@end smallexample

Also, we remember that a @code{while} loop returns @code{nil} (the
result of evaluating the true-or-false-test), not the result of any
evaluation within its body.  (The evaluations within the body of the
loop are done for their side effects.)  However, the expression that
sets the lengths' list is part of the body---and that is the value
that we want returned by the function as a whole.  To do this, we
enclose the @code{while} loop within a @code{let} expression, and
arrange that the last element of the @code{let} expression contains
the value of the lengths' list.  (@xref{Incrementing Example, , Loop
Example with an Incrementing Counter}.)

@findex lengths-list-many-files
@need 1250
These considerations lead us directly to the function itself:

@smallexample
@group
;;; @r{Use @code{while} loop.}
(defun lengths-list-many-files (list-of-files)
  "Return list of lengths of defuns in LIST-OF-FILES."
@end group
@group
  (let (lengths-list)

;;; @r{true-or-false-test}
    (while list-of-files
      (setq lengths-list
            (append
             lengths-list

;;; @r{Generate a lengths' list.}
             (lengths-list-file
              (expand-file-name (car list-of-files)))))
@end group

@group
;;; @r{Make files' list shorter.}
      (setq list-of-files (cdr list-of-files)))

;;; @r{Return final value of lengths' list.}
    lengths-list))
@end group
@end smallexample

@code{expand-file-name} is a built-in function that converts a file
name to the absolute, long, path name form.  The function employs the
name of the directory in which the function is called.

@c !!! 22.1.1 lisp sources location here
@need 1500
Thus, if @code{expand-file-name} is called on @code{debug.el} when
Emacs is visiting the
@file{/usr/local/share/emacs/22.1.1/lisp/emacs-lisp/} directory,

@smallexample
debug.el
@end smallexample

@need 800
@noindent
becomes

@c !!! 22.1.1 lisp sources location here
@smallexample
/usr/local/share/emacs/22.1.1/lisp/emacs-lisp/debug.el
@end smallexample

The only other new element of this function definition is the as yet
unstudied function @code{append}, which merits a short section for
itself.

@node append,  , lengths-list-many-files, Several files
@subsection The @code{append} Function

@need 800
The @code{append} function attaches one list to another.  Thus,

@smallexample
(append '(1 2 3 4) '(5 6 7 8))
@end smallexample

@need 800
@noindent
produces the list

@smallexample
(1 2 3 4 5 6 7 8)
@end smallexample

This is exactly how we want to attach two lengths' lists produced by
@code{lengths-list-file} to each other.  The results contrast with
@code{cons},

@smallexample
(cons '(1 2 3 4) '(5 6 7 8))
@end smallexample

@need 1250
@noindent
which constructs a new list in which the first argument to @code{cons}
becomes the first element of the new list:

@smallexample
((1 2 3 4) 5 6 7 8)
@end smallexample


@node Several files recursively, Prepare the data, Several files, Words in a defun
@section Recursively Count Words in Different Files

Besides a @code{while} loop, you can work on each of a list of files
with recursion.  A recursive version of @code{lengths-list-many-files}
is short and simple.

The recursive function has the usual parts: the `do-again-test', the
`next-step-expression', and the recursive call.  The `do-again-test'
determines whether the function should call itself again, which it
will do if the @code{list-of-files} contains any remaining elements;
the `next-step-expression' resets the @code{list-of-files} to the
@sc{cdr} of itself, so eventually the list will be empty; and the
recursive call calls itself on the shorter list.  The complete
function is shorter than this description!
@findex recursive-lengths-list-many-files

@smallexample
@group
(defun recursive-lengths-list-many-files (list-of-files)
  "Return list of lengths of each defun in LIST-OF-FILES."
  (if list-of-files                     ; @r{do-again-test}
      (append
       (lengths-list-file
        (expand-file-name (car list-of-files)))
       (recursive-lengths-list-many-files
        (cdr list-of-files)))))
@end group
@end smallexample

@noindent
In a sentence, the function returns the lengths' list for the first of
the @code{list-of-files} appended to the result of calling itself on
the rest of the @code{list-of-files}.

Here is a test of @code{recursive-lengths-list-many-files}, along with
the results of running @code{lengths-list-file} on each of the files
individually.

Install @code{recursive-lengths-list-many-files} and
@code{lengths-list-file}, if necessary, and then evaluate the
following expressions.  You may need to change the files' pathnames;
those here work when this Info file and the Emacs sources are located
in their customary places.  To change the expressions, copy them to
the @file{*scratch*} buffer, edit them, and then evaluate them.

The results are shown after the @samp{@result{}}.  (These results are
for files from Emacs version 22.1.1; files from other versions of
Emacs may produce different results.)

@c !!! 22.1.1 lisp sources location here
@smallexample
@group
(cd "/usr/local/share/emacs/22.1.1/")

(lengths-list-file "./lisp/macros.el")
     @result{} (283 263 480 90)
@end group

@group
(lengths-list-file "./lisp/mail/mailalias.el")
     @result{} (38 32 29 95 178 180 321 218 324)
@end group

@group
(lengths-list-file "./lisp/makesum.el")
     @result{} (85 181)
@end group

@group
  (recursive-lengths-list-many-files
   '("./lisp/macros.el"
     "./lisp/mail/mailalias.el"
     "./lisp/makesum.el"))
       @result{} (283 263 480 90 38 32 29 95 178 180 321 218 324 85 181)
@end group
@end smallexample

The @code{recursive-lengths-list-many-files} function produces the
output we want.

The next step is to prepare the data in the list for display in a graph.


@node Prepare the data,  , Several files recursively, Words in a defun
@section Prepare the Data for Display in a Graph

The @code{recursive-lengths-list-many-files} function returns a list
of numbers.  Each number records the length of a function definition.
What we need to do now is transform this data into a list of numbers
suitable for generating a graph.  The new list will tell how many
functions definitions contain less than 10 words and
symbols, how many contain between 10 and 19 words and symbols, how
many contain between 20 and 29 words and symbols, and so on.

In brief, we need to go through the lengths' list produced by the
@code{recursive-lengths-list-many-files} function and count the number
of defuns within each range of lengths, and produce a list of those
numbers.

@menu
* Data for Display in Detail::
* Sorting::                     Sorting lists.
* Files List::                  Making a list of files.
* Counting function definitions::
@end menu

@node Data for Display in Detail, Sorting, Prepare the data, Prepare the data
@ifnottex
@unnumberedsubsec The Data for Display in Detail
@end ifnottex

Based on what we have done before, we can readily foresee that it
should not be too hard to write a function that `@sc{cdr}s' down the
lengths' list, looks at each element, determines which length range it
is in, and increments a counter for that range.

However, before beginning to write such a function, we should consider
the advantages of sorting the lengths' list first, so the numbers are
ordered from smallest to largest.  First, sorting will make it easier
to count the numbers in each range, since two adjacent numbers will
either be in the same length range or in adjacent ranges.  Second, by
inspecting a sorted list, we can discover the highest and lowest
number, and thereby determine the largest and smallest length range
that we will need.

@node Sorting, Files List, Data for Display in Detail, Prepare the data
@subsection Sorting Lists
@findex sort

Emacs contains a function to sort lists, called (as you might guess)
@code{sort}.  The @code{sort} function takes two arguments, the list
to be sorted, and a predicate that determines whether the first of
two list elements is ``less'' than the second.

As we saw earlier (@pxref{Wrong Type of Argument, , Using the Wrong
Type Object as an Argument}), a predicate is a function that
determines whether some property is true or false.  The @code{sort}
function will reorder a list according to whatever property the
predicate uses; this means that @code{sort} can be used to sort
non-numeric lists by non-numeric criteria---it can, for example,
alphabetize a list.

@need 1250
The @code{<} function is used when sorting a numeric list.  For example,

@smallexample
(sort '(4 8 21 17 33 7 21 7) '<)
@end smallexample

@need 800
@noindent
produces this:

@smallexample
(4 7 7 8 17 21 21 33)
@end smallexample

@noindent
(Note that in this example, both the arguments are quoted so that the
symbols are not evaluated before being passed to @code{sort} as
arguments.)

Sorting the list returned by the
@code{recursive-lengths-list-many-files} function is straightforward;
it uses the @code{<} function:

@ignore
2006 Oct 29
In GNU Emacs 22,  eval
(progn
  (cd "/usr/local/share/emacs/22.0.50/")
  (sort
   (recursive-lengths-list-many-files
    '("./lisp/macros.el"
      "./lisp/mail/mailalias.el"
      "./lisp/makesum.el"))
   '<))

@end ignore

@smallexample
@group
(sort
 (recursive-lengths-list-many-files
  '("./lisp/macros.el"
    "./lisp/mailalias.el"
    "./lisp/makesum.el"))
 '<)
@end group
@end smallexample

@need 800
@noindent
which produces:

@smallexample
(29 32 38 85 90 95 178 180 181 218 263 283 321 324 480)
@end smallexample

@noindent
(Note that in this example, the first argument to @code{sort} is not
quoted, since the expression must be evaluated so as to produce the
list that is passed to @code{sort}.)

@node Files List, Counting function definitions, Sorting, Prepare the data
@subsection Making a List of Files

The @code{recursive-lengths-list-many-files} function requires a list
of files as its argument.  For our test examples, we constructed such
a list by hand; but the Emacs Lisp source directory is too large for
us to do for that.  Instead, we will write a function to do the job
for us.  In this function, we will use both a @code{while} loop and a
recursive call.

@findex directory-files
We did not have to write a function like this for older versions of
GNU Emacs, since they placed all the @samp{.el} files in one
directory.  Instead, we were able to use the @code{directory-files}
function, which lists the names of files that match a specified
pattern within a single directory.

However, recent versions of Emacs place Emacs Lisp files in
sub-directories of the top level @file{lisp} directory.  This
re-arrangement eases navigation.  For example, all the mail related
files are in a @file{lisp} sub-directory called @file{mail}.  But at
the same time, this arrangement forces us to create a file listing
function that descends into the sub-directories.

@findex files-in-below-directory
We can create this function, called @code{files-in-below-directory},
using familiar functions such as @code{car}, @code{nthcdr}, and
@code{substring} in conjunction with an existing function called
@code{directory-files-and-attributes}.  This latter function not only
lists all the filenames in a directory, including the names
of sub-directories, but also their attributes.

To restate our goal: to create a function that will enable us
to feed filenames to @code{recursive-lengths-list-many-files}
as a list that looks like this (but with more elements):

@smallexample
@group
("./lisp/macros.el"
 "./lisp/mail/rmail.el"
 "./lisp/makesum.el")
@end group
@end smallexample

The @code{directory-files-and-attributes} function returns a list of
lists.  Each of the lists within the main list consists of 13
elements.  The first element is a string that contains the name of the
file -- which, in GNU/Linux, may be a `directory file', that is to
say, a file with the special attributes of a directory.  The second
element of the list is @code{t} for a directory, a string
for symbolic link (the string is the name linked to), or @code{nil}.

For example, the first @samp{.el} file in the @file{lisp/} directory
is @file{abbrev.el}.  Its name is
@file{/usr/local/share/emacs/22.1.1/lisp/abbrev.el} and it is not a
directory or a symbolic link.

@need 1000
This is how @code{directory-files-and-attributes} lists that file and
its attributes:

@smallexample
@group
("abbrev.el"
nil
1
1000
100
@end group
@group
(17733 259)
(17491 28834)
(17596 62124)
13157
"-rw-rw-r--"
@end group
@group
nil
2971624
773)
@end group
@end smallexample

@need 1200
On the other hand, @file{mail/} is a directory within the @file{lisp/}
directory.  The beginning of its listing looks like this:

@smallexample
@group
("mail"
t
@dots{}
)
@end group
@end smallexample

(To learn about the different attributes, look at the documentation of
@code{file-attributes}.  Bear in mind that the @code{file-attributes}
function does not list the filename, so its first element is
@code{directory-files-and-attributes}'s second element.)

We will want our new function, @code{files-in-below-directory}, to
list the @samp{.el} files in the directory it is told to check, and in
any directories below that directory.

This gives us a hint on how to construct
@code{files-in-below-directory}:  within a directory, the function
should add @samp{.el} filenames to a list; and if, within a directory,
the function comes upon a sub-directory, it should go into that
sub-directory and repeat its actions.

However, we should note that every directory contains a name that
refers to itself, called @file{.}, (``dot'') and a name that refers to
its parent directory, called @file{..} (``double dot'').  (In
@file{/}, the root directory, @file{..} refers to itself, since
@file{/} has no parent.)  Clearly, we do not want our
@code{files-in-below-directory} function to enter those directories,
since they always lead us, directly or indirectly, to the current
directory.

Consequently, our @code{files-in-below-directory} function must do
several tasks:

@itemize @bullet
@item
Check to see whether it is looking at a filename that ends in
@samp{.el}; and if so, add its name to a list.

@item
Check to see whether it is looking at a filename that is the name of a
directory; and if so,

@itemize @minus
@item
Check to see whether it is looking at @file{.}  or @file{..}; and if
so skip it.

@item
Or else, go into that directory and repeat the process.
@end itemize
@end itemize

Let's write a function definition to do these tasks.  We will use a
@code{while} loop to move from one filename to another within a
directory, checking what needs to be done; and we will use a recursive
call to repeat the actions on each sub-directory.  The recursive
pattern is `accumulate'
(@pxref{Accumulate, , Recursive Pattern: @emph{accumulate}}),
using @code{append} as the combiner.

@ignore
(directory-files "/usr/local/src/emacs/lisp/" t "\\.el$")
(shell-command "find /usr/local/src/emacs/lisp/ -name '*.el'")

(directory-files "/usr/local/share/emacs/22.1.1/lisp/" t "\\.el$")
(shell-command "find /usr/local/share/emacs/22.1.1/lisp/ -name '*.el'")
@end ignore

@c  /usr/local/share/emacs/22.1.1/lisp/

@need 800
Here is the function:

@smallexample
@group
(defun files-in-below-directory (directory)
  "List the .el files in DIRECTORY and in its sub-directories."
  ;; Although the function will be used non-interactively,
  ;; it will be easier to test if we make it interactive.
  ;; The directory will have a name such as
  ;;  "/usr/local/share/emacs/22.1.1/lisp/"
  (interactive "DDirectory name: ")
@end group
@group
  (let (el-files-list
        (current-directory-list
         (directory-files-and-attributes directory t)))
    ;; while we are in the current directory
    (while current-directory-list
@end group
@group
      (cond
       ;; check to see whether filename ends in `.el'
       ;; and if so, append its name to a list.
       ((equal ".el" (substring (car (car current-directory-list)) -3))
        (setq el-files-list
              (cons (car (car current-directory-list)) el-files-list)))
@end group
@group
       ;; check whether filename is that of a directory
       ((eq t (car (cdr (car current-directory-list))))
        ;; decide whether to skip or recurse
        (if
            (equal "."
                   (substring (car (car current-directory-list)) -1))
            ;; then do nothing since filename is that of
            ;;   current directory or parent, "." or ".."
            ()
@end group
@group
          ;; else descend into the directory and repeat the process
          (setq el-files-list
                (append
                 (files-in-below-directory
                  (car (car current-directory-list)))
                 el-files-list)))))
      ;; move to the next filename in the list; this also
      ;; shortens the list so the while loop eventually comes to an end
      (setq current-directory-list (cdr current-directory-list)))
    ;; return the filenames
    el-files-list))
@end group
@end smallexample

@c (files-in-below-directory "/usr/local/src/emacs/lisp/")
@c (files-in-below-directory "/usr/local/share/emacs/22.1.1/lisp/")

The @code{files-in-below-directory} @code{directory-files} function
takes one argument, the name of a directory.

@need 1250
Thus, on my system,

@c (length (files-in-below-directory "/usr/local/src/emacs/lisp/"))

@c !!! 22.1.1 lisp sources location here
@smallexample
@group
(length
 (files-in-below-directory "/usr/local/share/emacs/22.1.1/lisp/"))
@end group
@end smallexample

@noindent
tells me that in and below my Lisp sources directory are 1031
@samp{.el} files.

@code{files-in-below-directory} returns a list in reverse alphabetical
order.  An expression to sort the list in alphabetical order looks
like this:

@smallexample
@group
(sort
 (files-in-below-directory "/usr/local/share/emacs/22.1.1/lisp/")
 'string-lessp)
@end group
@end smallexample

@ignore
(defun test ()
  "Test how long it takes to find lengths of all sorted elisp defuns."
  (insert "\n" (current-time-string) "\n")
  (sit-for 0)
  (sort
   (recursive-lengths-list-many-files
    (files-in-below-directory "/usr/local/src/emacs/lisp/"))
   '<)
  (insert (format "%s" (current-time-string))))
@end ignore

@node Counting function definitions,  , Files List, Prepare the data
@subsection Counting function definitions

Our immediate goal is to generate a list that tells us how many
function definitions contain fewer than 10 words and symbols, how many
contain between 10 and 19 words and symbols, how many contain between
20 and 29 words and symbols, and so on.

With a sorted list of numbers, this is easy: count how many elements
of the list are smaller than 10, then, after moving past the numbers
just counted, count how many are smaller than 20, then, after moving
past the numbers just counted, count how many are smaller than 30, and
so on.  Each of the numbers, 10, 20, 30, 40, and the like, is one
larger than the top of that range.  We can call the list of such
numbers the @code{top-of-ranges} list.

@need 1200
If we wished, we could generate this list automatically, but it is
simpler to write a list manually.  Here it is:
@vindex top-of-ranges

@smallexample
@group
(defvar top-of-ranges
 '(10  20  30  40  50
   60  70  80  90 100
  110 120 130 140 150
  160 170 180 190 200
  210 220 230 240 250
  260 270 280 290 300)
 "List specifying ranges for `defuns-per-range'.")
@end group
@end smallexample

To change the ranges, we edit this list.

Next, we need to write the function that creates the list of the
number of definitions within each range.  Clearly, this function must
take the @code{sorted-lengths} and the @code{top-of-ranges} lists
as arguments.

The @code{defuns-per-range} function must do two things again and
again: it must count the number of definitions within a range
specified by the current top-of-range value; and it must shift to the
next higher value in the @code{top-of-ranges} list after counting the
number of definitions in the current range.  Since each of these
actions is repetitive, we can use @code{while} loops for the job.
One loop counts the number of definitions in the range defined by the
current top-of-range value, and the other loop selects each of the
top-of-range values in turn.

Several entries of the @code{sorted-lengths} list are counted for each
range; this means that the loop for the @code{sorted-lengths} list
will be inside the loop for the @code{top-of-ranges} list, like a
small gear inside a big gear.

The inner loop counts the number of definitions within the range.  It
is a simple counting loop of the type we have seen before.
(@xref{Incrementing Loop, , A loop with an incrementing counter}.)
The true-or-false test of the loop tests whether the value from the
@code{sorted-lengths} list is smaller than the current value of the
top of the range.  If it is, the function increments the counter and
tests the next value from the @code{sorted-lengths} list.

@need 1250
The inner loop looks like this:

@smallexample
@group
(while @var{length-element-smaller-than-top-of-range}
  (setq number-within-range (1+ number-within-range))
  (setq sorted-lengths (cdr sorted-lengths)))
@end group
@end smallexample

The outer loop must start with the lowest value of the
@code{top-of-ranges} list, and then be set to each of the succeeding
higher values in turn.  This can be done with a loop like this:

@smallexample
@group
(while top-of-ranges
  @var{body-of-loop}@dots{}
  (setq top-of-ranges (cdr top-of-ranges)))
@end group
@end smallexample

@need 1200
Put together, the two loops look like this:

@smallexample
@group
(while top-of-ranges

  ;; @r{Count the number of elements within the current range.}
  (while @var{length-element-smaller-than-top-of-range}
    (setq number-within-range (1+ number-within-range))
    (setq sorted-lengths (cdr sorted-lengths)))

  ;; @r{Move to next range.}
  (setq top-of-ranges (cdr top-of-ranges)))
@end group
@end smallexample

In addition, in each circuit of the outer loop, Emacs should record
the number of definitions within that range (the value of
@code{number-within-range}) in a list.  We can use @code{cons} for
this purpose.  (@xref{cons, , @code{cons}}.)

The @code{cons} function works fine, except that the list it
constructs will contain the number of definitions for the highest
range at its beginning and the number of definitions for the lowest
range at its end.  This is because @code{cons} attaches new elements
of the list to the beginning of the list, and since the two loops are
working their way through the lengths' list from the lower end first,
the @code{defuns-per-range-list} will end up largest number first.
But we will want to print our graph with smallest values first and the
larger later.  The solution is to reverse the order of the
@code{defuns-per-range-list}.  We can do this using the
@code{nreverse} function, which reverses the order of a list.
@findex nreverse

@need 800
For example,

@smallexample
(nreverse '(1 2 3 4))
@end smallexample

@need 800
@noindent
produces:

@smallexample
(4 3 2 1)
@end smallexample

Note that the @code{nreverse} function is ``destructive''---that is,
it changes the list to which it is applied; this contrasts with the
@code{car} and @code{cdr} functions, which are non-destructive.  In
this case, we do not want the original @code{defuns-per-range-list},
so it does not matter that it is destroyed.  (The @code{reverse}
function provides a reversed copy of a list, leaving the original list
as is.)
@findex reverse

@need 1250
Put all together, the @code{defuns-per-range} looks like this:

@smallexample
@group
(defun defuns-per-range (sorted-lengths top-of-ranges)
  "SORTED-LENGTHS defuns in each TOP-OF-RANGES range."
  (let ((top-of-range (car top-of-ranges))
        (number-within-range 0)
        defuns-per-range-list)
@end group

@group
    ;; @r{Outer loop.}
    (while top-of-ranges
@end group

@group
      ;; @r{Inner loop.}
      (while (and
              ;; @r{Need number for numeric test.}
              (car sorted-lengths)
              (< (car sorted-lengths) top-of-range))
@end group

@group
        ;; @r{Count number of definitions within current range.}
        (setq number-within-range (1+ number-within-range))
        (setq sorted-lengths (cdr sorted-lengths)))

      ;; @r{Exit inner loop but remain within outer loop.}
@end group

@group
      (setq defuns-per-range-list
            (cons number-within-range defuns-per-range-list))
      (setq number-within-range 0)      ; @r{Reset count to zero.}
@end group

@group
      ;; @r{Move to next range.}
      (setq top-of-ranges (cdr top-of-ranges))
      ;; @r{Specify next top of range value.}
      (setq top-of-range (car top-of-ranges)))
@end group

@group
    ;; @r{Exit outer loop and count the number of defuns larger than}
    ;; @r{  the largest top-of-range value.}
    (setq defuns-per-range-list
          (cons
           (length sorted-lengths)
           defuns-per-range-list))
@end group

@group
    ;; @r{Return a list of the number of definitions within each range,}
    ;; @r{  smallest to largest.}
    (nreverse defuns-per-range-list)))
@end group
@end smallexample

@need 1200
@noindent
The function is straightforward except for one subtle feature.  The
true-or-false test of the inner loop looks like this:

@smallexample
@group
(and (car sorted-lengths)
     (< (car sorted-lengths) top-of-range))
@end group
@end smallexample

@need 800
@noindent
instead of like this:

@smallexample
(< (car sorted-lengths) top-of-range)
@end smallexample

The purpose of the test is to determine whether the first item in the
@code{sorted-lengths} list is less than the value of the top of the
range.

The simple version of the test works fine unless the
@code{sorted-lengths} list has a @code{nil} value.  In that case, the
@code{(car sorted-lengths)} expression function returns
@code{nil}.  The @code{<} function cannot compare a number to
@code{nil}, which is an empty list, so Emacs signals an error and
stops the function from attempting to continue to execute.

The @code{sorted-lengths} list always becomes @code{nil} when the
counter reaches the end of the list.  This means that any attempt to
use the @code{defuns-per-range} function with the simple version of
the test will fail.

We solve the problem by using the @code{(car sorted-lengths)}
expression in conjunction with the @code{and} expression.  The
@code{(car sorted-lengths)} expression returns a non-@code{nil}
value so long as the list has at least one number within it, but
returns @code{nil} if the list is empty.  The @code{and} expression
first evaluates the @code{(car sorted-lengths)} expression, and
if it is @code{nil}, returns false @emph{without} evaluating the
@code{<} expression.  But if the @code{(car sorted-lengths)}
expression returns a non-@code{nil} value, the @code{and} expression
evaluates the @code{<} expression, and returns that value as the value
of the @code{and} expression.

@c colon in printed section title causes problem in Info cross reference
This way, we avoid an error.
@iftex
@noindent
(For information about @code{and}, see
@ref{kill-new function, , The @code{kill-new} function}.)
@end iftex
@ifinfo
@noindent
(@xref{kill-new function, , The @code{kill-new} function}, for
information about @code{and}.)
@end ifinfo

Here is a short test of the @code{defuns-per-range} function.  First,
evaluate the expression that binds (a shortened)
@code{top-of-ranges} list to the list of values, then evaluate the
expression for binding the @code{sorted-lengths} list, and then
evaluate the @code{defuns-per-range} function.

@smallexample
@group
;; @r{(Shorter list than we will use later.)}
(setq top-of-ranges
 '(110 120 130 140 150
   160 170 180 190 200))

(setq sorted-lengths
      '(85 86 110 116 122 129 154 176 179 200 265 300 300))

(defuns-per-range sorted-lengths top-of-ranges)
@end group
@end smallexample

@need 800
@noindent
The list returned looks like this:

@smallexample
(2 2 2 0 0 1 0 2 0 0 4)
@end smallexample

@noindent
Indeed, there are two elements of the @code{sorted-lengths} list
smaller than 110, two elements between 110 and 119, two elements
between 120 and 129, and so on.  There are four elements with a value
of 200 or larger.


@c The next step is to turn this numbers' list into a graph.
@node Readying a Graph, Emacs Initialization, Words in a defun, Top
@chapter Readying a Graph
@cindex Readying a graph
@cindex Graph prototype
@cindex Prototype graph
@cindex Body of graph

Our goal is to construct a graph showing the numbers of function
definitions of various lengths in the Emacs lisp sources.

As a practical matter, if you were creating a graph, you would
probably use a program such as @code{gnuplot} to do the job.
(@code{gnuplot} is nicely integrated into GNU Emacs.)  In this case,
however, we create one from scratch, and in the process we will
re-acquaint ourselves with some of what we learned before and learn
more.

In this chapter, we will first write a simple graph printing function.
This first definition will be a @dfn{prototype}, a rapidly written
function that enables us to reconnoiter this unknown graph-making
territory.  We will discover dragons, or find that they are myth.
After scouting the terrain, we will feel more confident and enhance
the function to label the axes automatically.

@menu
* Columns of a graph::
* graph-body-print::            How to print the body of a graph.
* recursive-graph-body-print::
* Printed Axes::
* Line Graph Exercise::
@end menu

@node Columns of a graph, graph-body-print, Readying a Graph, Readying a Graph
@ifnottex
@unnumberedsec Printing the Columns of a Graph
@end ifnottex

Since Emacs is designed to be flexible and work with all kinds of
terminals, including character-only terminals, the graph will need to
be made from one of the `typewriter' symbols.  An asterisk will do; as
we enhance the graph-printing function, we can make the choice of
symbol a user option.

We can call this function @code{graph-body-print}; it will take a
@code{numbers-list} as its only argument.  At this stage, we will not
label the graph, but only print its body.

The @code{graph-body-print} function inserts a vertical column of
asterisks for each element in the @code{numbers-list}.  The height of
each line is determined by the value of that element of the
@code{numbers-list}.

Inserting columns is a repetitive act; that means that this function can
be written either with a @code{while} loop or recursively.

Our first challenge is to discover how to print a column of asterisks.
Usually, in Emacs, we print characters onto a screen horizontally,
line by line, by typing.  We have two routes we can follow: write our
own column-insertion function or discover whether one exists in Emacs.

To see whether there is one in Emacs, we can use the @kbd{M-x apropos}
command.  This command is like the @kbd{C-h a} (@code{command-apropos})
command, except that the latter finds only those functions that are
commands.  The @kbd{M-x apropos} command lists all symbols that match
a regular expression, including functions that are not interactive.
@findex apropos

What we want to look for is some command that prints or inserts
columns.  Very likely, the name of the function will contain either
the word `print' or the word `insert' or the word `column'.
Therefore, we can simply type @kbd{M-x apropos RET
print\|insert\|column RET} and look at the result.  On my system, this
command once too takes quite some time, and then produced a list of 79
functions and variables.  Now it does not take much time at all and
produces a list of 211 functions and variables.  Scanning down the
list, the only function that looks as if it might do the job is
@code{insert-rectangle}.

@need 1200
Indeed, this is the function we want; its documentation says:

@smallexample
@group
insert-rectangle:
Insert text of RECTANGLE with upper left corner at point.
RECTANGLE's first line is inserted at point,
its second line is inserted at a point vertically under point, etc.
RECTANGLE should be a list of strings.
After this command, the mark is at the upper left corner
and point is at the lower right corner.
@end group
@end smallexample

We can run a quick test, to make sure it does what we expect of it.

Here is the result of placing the cursor after the
@code{insert-rectangle} expression and typing @kbd{C-u C-x C-e}
(@code{eval-last-sexp}).  The function inserts the strings
@samp{"first"}, @samp{"second"}, and @samp{"third"} at and below
point.  Also the function returns @code{nil}.

@smallexample
@group
(insert-rectangle '("first" "second" "third"))first
                                              second
                                              thirdnil
@end group
@end smallexample

@noindent
Of course, we won't be inserting the text of the
@code{insert-rectangle} expression itself into the buffer in which we
are making the graph, but will call the function from our program.  We
shall, however, have to make sure that point is in the buffer at the
place where the @code{insert-rectangle} function will insert its
column of strings.

If you are reading this in Info, you can see how this works by
switching to another buffer, such as the @file{*scratch*} buffer,
placing point somewhere in the buffer, typing @kbd{M-:}, typing the
@code{insert-rectangle} expression into the minibuffer at the prompt,
and then typing @key{RET}.  This causes Emacs to evaluate the
expression in the minibuffer, but to use as the value of point the
position of point in the @file{*scratch*} buffer.  (@kbd{M-:}  is the
keybinding for @code{eval-expression}. Also, @code{nil} does not
appear in the @file{*scratch*} buffer since the expression is
evaluated in the minibuffer.)

We find when we do this that point ends up at the end of the last
inserted line---that is to say, this function moves point as a
side-effect.  If we were to repeat the command, with point at this
position, the next insertion would be below and to the right of the
previous insertion.  We don't want this!  If we are going to make a
bar graph, the columns need to be beside each other.

So we discover that each cycle of the column-inserting @code{while}
loop must reposition point to the place we want it, and that place
will be at the top, not the bottom, of the column.  Moreover, we
remember that when we print a graph, we do not expect all the columns
to be the same height.  This means that the top of each column may be
at a different height from the previous one.  We cannot simply
reposition point to the same line each time, but moved over to the
right---or perhaps we can@dots{}

We are planning to make the columns of the bar graph out of asterisks.
The number of asterisks in the column is the number specified by the
current element of the @code{numbers-list}.  We need to construct a
list of asterisks of the right length for each call to
@code{insert-rectangle}.  If this list consists solely of the requisite
number of asterisks, then we will have position point the right number
of lines above the base for the graph to print correctly.  This could
be difficult.

Alternatively, if we can figure out some way to pass
@code{insert-rectangle} a list of the same length each time, then we
can place point on the same line each time, but move it over one
column to the right for each new column.  If we do this, however, some
of the entries in the list passed to @code{insert-rectangle} must be
blanks rather than asterisks.  For example, if the maximum height of
the graph is 5, but the height of the column is 3, then
@code{insert-rectangle} requires an argument that looks like this:

@smallexample
(" " " " "*" "*" "*")
@end smallexample

This last proposal is not so difficult, so long as we can determine
the column height.  There are two ways for us to specify the column
height: we can arbitrarily state what it will be, which would work
fine for graphs of that height; or we can search through the list of
numbers and use the maximum height of the list as the maximum height
of the graph.  If the latter operation were difficult, then the former
procedure would be easiest, but there is a function built into Emacs
that determines the maximum of its arguments.  We can use that
function.  The function is called @code{max} and it returns the
largest of all its arguments, which must be numbers.  Thus, for
example,

@smallexample
(max  3 4 6 5 7 3)
@end smallexample

@noindent
returns 7.  (A corresponding function called @code{min} returns the
smallest of all its arguments.)
@findex max
@findex min

However, we cannot simply call @code{max} on the @code{numbers-list};
the @code{max} function expects numbers as its argument, not a list of
numbers.  Thus, the following expression,

@smallexample
(max  '(3 4 6 5 7 3))
@end smallexample

@need 800
@noindent
produces the following error message;

@smallexample
Wrong type of argument:  number-or-marker-p, (3 4 6 5 7 3)
@end smallexample

@findex apply
We need a function that passes a list of arguments to a function.
This function is @code{apply}.  This function `applies' its first
argument (a function) to its remaining arguments, the last of which
may be a list.

@need 1250
For example,

@smallexample
(apply 'max 3 4 7 3 '(4 8 5))
@end smallexample

@noindent
returns 8.

(Incidentally, I don't know how you would learn of this function
without a book such as this.  It is possible to discover other
functions, like @code{search-forward} or @code{insert-rectangle}, by
guessing at a part of their names and then using @code{apropos}.  Even
though its base in metaphor is clear---`apply' its first argument to
the rest---I doubt a novice would come up with that particular word
when using @code{apropos} or other aid.  Of course, I could be wrong;
after all, the function was first named by someone who had to invent
it.)

The second and subsequent arguments to @code{apply} are optional, so
we can use @code{apply} to call a function and pass the elements of a
list to it, like this, which also returns 8:

@smallexample
(apply 'max '(4 8 5))
@end smallexample

This latter way is how we will use @code{apply}.  The
@code{recursive-lengths-list-many-files} function returns a numbers'
list to which we can apply @code{max} (we could also apply @code{max} to
the sorted numbers' list; it does not matter whether the list is
sorted or not.)

@need 800
Hence, the operation for finding the maximum height of the graph is this:

@smallexample
(setq max-graph-height (apply 'max numbers-list))
@end smallexample

Now we can return to the question of how to create a list of strings
for a column of the graph.  Told the maximum height of the graph
and the number of asterisks that should appear in the column, the
function should return a list of strings for the
@code{insert-rectangle} command to insert.

Each column is made up of asterisks or blanks.  Since the function is
passed the value of the height of the column and the number of
asterisks in the column, the number of blanks can be found by
subtracting the number of asterisks from the height of the column.
Given the number of blanks and the number of asterisks, two
@code{while} loops can be used to construct the list:

@smallexample
@group
;;; @r{First version.}
(defun column-of-graph (max-graph-height actual-height)
  "Return list of strings that is one column of a graph."
  (let ((insert-list nil)
        (number-of-top-blanks
         (- max-graph-height actual-height)))
@end group

@group
    ;; @r{Fill in asterisks.}
    (while (> actual-height 0)
      (setq insert-list (cons "*" insert-list))
      (setq actual-height (1- actual-height)))
@end group

@group
    ;; @r{Fill in blanks.}
    (while (> number-of-top-blanks 0)
      (setq insert-list (cons " " insert-list))
      (setq number-of-top-blanks
            (1- number-of-top-blanks)))
@end group

@group
    ;; @r{Return whole list.}
    insert-list))
@end group
@end smallexample

If you install this function and then evaluate the following
expression you will see that it returns the list as desired:

@smallexample
(column-of-graph 5 3)
@end smallexample

@need 800
@noindent
returns

@smallexample
(" " " " "*" "*" "*")
@end smallexample

As written, @code{column-of-graph} contains a major flaw: the symbols
used for the blank and for the marked entries in the column are
`hard-coded' as a space and asterisk.  This is fine for a prototype,
but you, or another user, may wish to use other symbols.  For example,
in testing the graph function, you many want to use a period in place
of the space, to make sure the point is being repositioned properly
each time the @code{insert-rectangle} function is called; or you might
want to substitute a @samp{+} sign or other symbol for the asterisk.
You might even want to make a graph-column that is more than one
display column wide.  The program should be more flexible.  The way to
do that is to replace the blank and the asterisk with two variables
that we can call @code{graph-blank} and @code{graph-symbol} and define
those variables separately.

Also, the documentation is not well written.  These considerations
lead us to the second version of the function:

@smallexample
@group
(defvar graph-symbol "*"
  "String used as symbol in graph, usually an asterisk.")
@end group

@group
(defvar graph-blank " "
  "String used as blank in graph, usually a blank space.
graph-blank must be the same number of columns wide
as graph-symbol.")
@end group
@end smallexample

@noindent
(For an explanation of @code{defvar}, see
@ref{defvar, , Initializing a Variable with @code{defvar}}.)

@smallexample
@group
;;; @r{Second version.}
(defun column-of-graph (max-graph-height actual-height)
  "Return MAX-GRAPH-HEIGHT strings; ACTUAL-HEIGHT are graph-symbols.

@end group
@group
The graph-symbols are contiguous entries at the end
of the list.
The list will be inserted as one column of a graph.
The strings are either graph-blank or graph-symbol."
@end group

@group
  (let ((insert-list nil)
        (number-of-top-blanks
         (- max-graph-height actual-height)))
@end group

@group
    ;; @r{Fill in @code{graph-symbols}.}
    (while (> actual-height 0)
      (setq insert-list (cons graph-symbol insert-list))
      (setq actual-height (1- actual-height)))
@end group

@group
    ;; @r{Fill in @code{graph-blanks}.}
    (while (> number-of-top-blanks 0)
      (setq insert-list (cons graph-blank insert-list))
      (setq number-of-top-blanks
            (1- number-of-top-blanks)))

    ;; @r{Return whole list.}
    insert-list))
@end group
@end smallexample

If we wished, we could rewrite @code{column-of-graph} a third time to
provide optionally for a line graph as well as for a bar graph.  This
would not be hard to do.  One way to think of a line graph is that it
is no more than a bar graph in which the part of each bar that is
below the top is blank.  To construct a column for a line graph, the
function first constructs a list of blanks that is one shorter than
the value, then it uses @code{cons} to attach a graph symbol to the
list; then it uses @code{cons} again to attach the `top blanks' to
the list.

It is easy to see how to write such a function, but since we don't
need it, we will not do it.  But the job could be done, and if it were
done, it would be done with @code{column-of-graph}.  Even more
important, it is worth noting that few changes would have to be made
anywhere else.  The enhancement, if we ever wish to make it, is
simple.

Now, finally, we come to our first actual graph printing function.
This prints the body of a graph, not the labels for the vertical and
horizontal axes, so we can call this @code{graph-body-print}.


@node graph-body-print, recursive-graph-body-print, Columns of a graph, Readying a Graph
@section The @code{graph-body-print} Function
@findex graph-body-print

After our preparation in the preceding section, the
@code{graph-body-print} function is straightforward.  The function
will print column after column of asterisks and blanks, using the
elements of a numbers' list to specify the number of asterisks in each
column.  This is a repetitive act, which means we can use a
decrementing @code{while} loop or recursive function for the job.  In
this section, we will write the definition using a @code{while} loop.

The @code{column-of-graph} function requires the height of the graph
as an argument, so we should determine and record that as a local variable.

This leads us to the following template for the @code{while} loop
version of this function:

@smallexample
@group
(defun graph-body-print (numbers-list)
  "@var{documentation}@dots{}"
  (let ((height  @dots{}
         @dots{}))
@end group

@group
    (while numbers-list
      @var{insert-columns-and-reposition-point}
      (setq numbers-list (cdr numbers-list)))))
@end group
@end smallexample

@noindent
We need to fill in the slots of the template.

Clearly, we can use the @code{(apply 'max numbers-list)} expression to
determine the height of the graph.

The @code{while} loop will cycle through the @code{numbers-list} one
element at a time.  As it is shortened by the @code{(setq numbers-list
(cdr numbers-list))} expression, the @sc{car} of each instance of the
list is the value of the argument for @code{column-of-graph}.

At each cycle of the @code{while} loop, the @code{insert-rectangle}
function inserts the list returned by @code{column-of-graph}.  Since
the @code{insert-rectangle} function moves point to the lower right of
the inserted rectangle, we need to save the location of point at the
time the rectangle is inserted, move back to that position after the
rectangle is inserted, and then move horizontally to the next place
from which @code{insert-rectangle} is called.

If the inserted columns are one character wide, as they will be if
single blanks and asterisks are used, the repositioning command is
simply @code{(forward-char 1)}; however, the width of a column may be
greater than one.  This means that the repositioning command should be
written @code{(forward-char symbol-width)}.  The @code{symbol-width}
itself is the length of a @code{graph-blank} and can be found using
the expression @code{(length graph-blank)}.  The best place to bind
the @code{symbol-width} variable to the value of the width of graph
column is in the varlist of the @code{let} expression.

@need 1250
These considerations lead to the following function definition:

@smallexample
@group
(defun graph-body-print (numbers-list)
  "Print a bar graph of the NUMBERS-LIST.
The numbers-list consists of the Y-axis values."

  (let ((height (apply 'max numbers-list))
        (symbol-width (length graph-blank))
        from-position)
@end group

@group
    (while numbers-list
      (setq from-position (point))
      (insert-rectangle
       (column-of-graph height (car numbers-list)))
      (goto-char from-position)
      (forward-char symbol-width)
@end group
@group
      ;; @r{Draw graph column by column.}
      (sit-for 0)
      (setq numbers-list (cdr numbers-list)))
@end group
@group
    ;; @r{Place point for X axis labels.}
    (forward-line height)
    (insert "\n")
))
@end group
@end smallexample

@noindent
The one unexpected expression in this function is the
@w{@code{(sit-for 0)}} expression in the @code{while} loop.  This
expression makes the graph printing operation more interesting to
watch than it would be otherwise.  The expression causes Emacs to
`sit' or do nothing for a zero length of time and then redraw the
screen.  Placed here, it causes Emacs to redraw the screen column by
column.  Without it, Emacs would not redraw the screen until the
function exits.

We can test @code{graph-body-print} with a short list of numbers.

@enumerate
@item
Install @code{graph-symbol}, @code{graph-blank},
@code{column-of-graph}, which are in
@iftex
@ref{Readying a Graph, , Readying a Graph},
@end iftex
@ifinfo
@ref{Columns of a graph},
@end ifinfo
and @code{graph-body-print}.

@need 800
@item
Copy the following expression:

@smallexample
(graph-body-print '(1 2 3 4 6 4 3 5 7 6 5 2 3))
@end smallexample

@item
Switch to the @file{*scratch*} buffer and place the cursor where you
want the graph to start.

@item
Type @kbd{M-:} (@code{eval-expression}).

@item
Yank the @code{graph-body-print} expression into the minibuffer
with @kbd{C-y} (@code{yank)}.

@item
Press @key{RET} to evaluate the @code{graph-body-print} expression.
@end enumerate

@need 800
Emacs will print a graph like this:

@smallexample
@group
                    *
                *   **
                *  ****
               *** ****
              ********* *
             ************
            *************
@end group
@end smallexample


@node recursive-graph-body-print, Printed Axes, graph-body-print, Readying a Graph
@section The @code{recursive-graph-body-print} Function
@findex recursive-graph-body-print

The @code{graph-body-print} function may also be written recursively.
The recursive solution is divided into two parts: an outside `wrapper'
that uses a @code{let} expression to determine the values of several
variables that need only be found once, such as the maximum height of
the graph, and an inside function that is called recursively to print
the graph.

@need 1250
The `wrapper' is uncomplicated:

@smallexample
@group
(defun recursive-graph-body-print (numbers-list)
  "Print a bar graph of the NUMBERS-LIST.
The numbers-list consists of the Y-axis values."
  (let ((height (apply 'max numbers-list))
        (symbol-width (length graph-blank))
        from-position)
    (recursive-graph-body-print-internal
     numbers-list
     height
     symbol-width)))
@end group
@end smallexample

The recursive function is a little more difficult.  It has four parts:
the `do-again-test', the printing code, the recursive call, and the
`next-step-expression'.  The `do-again-test' is a @code{when}
expression that determines whether the @code{numbers-list} contains
any remaining elements; if it does, the function prints one column of
the graph using the printing code and calls itself again.  The
function calls itself again according to the value produced by the
`next-step-expression' which causes the call to act on a shorter
version of the @code{numbers-list}.

@smallexample
@group
(defun recursive-graph-body-print-internal
  (numbers-list height symbol-width)
  "Print a bar graph.
Used within recursive-graph-body-print function."
@end group

@group
  (when numbers-list
        (setq from-position (point))
        (insert-rectangle
         (column-of-graph height (car numbers-list)))
@end group
@group
        (goto-char from-position)
        (forward-char symbol-width)
        (sit-for 0)     ; @r{Draw graph column by column.}
        (recursive-graph-body-print-internal
         (cdr numbers-list) height symbol-width)))
@end group
@end smallexample

@need 1250
After installation, this expression can be tested; here is a sample:

@smallexample
(recursive-graph-body-print '(3 2 5 6 7 5 3 4 6 4 3 2 1))
@end smallexample

@need 800
Here is what @code{recursive-graph-body-print} produces:

@smallexample
@group
                *
               **   *
              ****  *
              **** ***
            * *********
            ************
            *************
@end group
@end smallexample

Either of these two functions, @code{graph-body-print} or
@code{recursive-graph-body-print}, create the body of a graph.


@node Printed Axes, Line Graph Exercise, recursive-graph-body-print, Readying a Graph
@section Need for Printed Axes

A graph needs printed axes, so you can orient yourself.  For a do-once
project, it may be reasonable to draw the axes by hand using Emacs'
Picture mode; but a graph drawing function may be used more than once.

For this reason, I have written enhancements to the basic
@code{print-graph-body} function that automatically print labels for
the horizontal and vertical axes.  Since the label printing functions
do not contain much new material, I have placed their description in
an appendix.  @xref{Full Graph, , A Graph with Labelled Axes}.

@node Line Graph Exercise,  , Printed Axes, Readying a Graph
@section Exercise

Write a line graph version of the graph printing functions.


@node Emacs Initialization, Debugging, Readying a Graph, Top
@chapter Your @file{.emacs} File
@cindex @file{.emacs} file
@cindex Customizing your @file{.emacs} file
@cindex Initialization file

``You don't have to like Emacs to like it'' -- this seemingly
paradoxical statement is the secret of GNU Emacs.  The plain, `out of
the box' Emacs is a generic tool.  Most people who use it, customize
it to suit themselves.

GNU Emacs is mostly written in Emacs Lisp; this means that by writing
expressions in Emacs Lisp you can change or extend Emacs.

@menu
* Default Configuration::
* Site-wide Init::              You can write site-wide init files.
* defcustom::                   Emacs will write code for you.
* Beginning a .emacs File::     How to write a @code{.emacs file}.
* Text and Auto-fill::          Automatically wrap lines.
* Mail Aliases::                Use abbreviations for email addresses.
* Indent Tabs Mode::            Don't use tabs with @TeX{}
* Keybindings::                 Create some personal keybindings.
* Keymaps::                     More about key binding.
* Loading Files::               Load (i.e., evaluate) files automatically.
* Autoload::                    Make functions available.
* Simple Extension::            Define a function; bind it to a key.
* X11 Colors::                  Colors in X.
* Miscellaneous::
* Mode Line::                   How to customize your mode line.
@end menu

@node Default Configuration, Site-wide Init, Emacs Initialization, Emacs Initialization
@ifnottex
@unnumberedsec Emacs' Default Configuration
@end ifnottex

There are those who appreciate Emacs' default configuration.  After
all, Emacs starts you in C mode when you edit a C file, starts you in
Fortran mode when you edit a Fortran file, and starts you in
Fundamental mode when you edit an unadorned file.  This all makes
sense, if you do not know who is going to use Emacs.  Who knows what a
person hopes to do with an unadorned file?  Fundamental mode is the
right default for such a file, just as C mode is the right default for
editing C code.  (Enough programming languages have syntaxes
that enable them to share or nearly share features, so C mode is
now provided by CC mode, the `C Collection'.)

But when you do know who is going to use Emacs---you,
yourself---then it makes sense to customize Emacs.

For example, I seldom want Fundamental mode when I edit an
otherwise undistinguished file; I want Text mode.  This is why I
customize Emacs: so it suits me.

You can customize and extend Emacs by writing or adapting a
@file{~/.emacs} file.  This is your personal initialization file; its
contents, written in Emacs Lisp, tell Emacs what to do.@footnote{You
may also add @file{.el} to @file{~/.emacs} and call it a
@file{~/.emacs.el} file.  In the past, you were forbidden to type the
extra keystrokes that the name @file{~/.emacs.el} requires, but now
you may.  The new format is consistent with the Emacs Lisp file
naming conventions; the old format saves typing.}

A @file{~/.emacs} file contains Emacs Lisp code.  You can write this
code yourself; or you can use Emacs' @code{customize} feature to write
the code for you.  You can combine your own expressions and
auto-written Customize expressions in your @file{.emacs} file.

(I myself prefer to write my own expressions, except for those,
particularly fonts, that I find easier to manipulate using the
@code{customize} command.  I combine the two methods.)

Most of this chapter is about writing expressions yourself.  It
describes a simple @file{.emacs} file; for more information, see
@ref{Init File, , The Init File, emacs, The GNU Emacs Manual}, and
@ref{Init File, , The Init File, elisp, The GNU Emacs Lisp Reference
Manual}.


@node Site-wide Init, defcustom, Default Configuration, Emacs Initialization
@section Site-wide Initialization Files

@cindex @file{default.el} init file
@cindex @file{site-init.el} init file
@cindex @file{site-load.el} init file
In addition to your personal initialization file, Emacs automatically
loads various site-wide initialization files, if they exist.  These
have the same form as your @file{.emacs} file, but are loaded by
everyone.

Two site-wide initialization files, @file{site-load.el} and
@file{site-init.el}, are loaded into Emacs and then `dumped' if a
`dumped' version of Emacs is created, as is most common.  (Dumped
copies of Emacs load more quickly.  However, once a file is loaded and
dumped, a change to it does not lead to a change in Emacs unless you
load it yourself or re-dump Emacs.  @xref{Building Emacs, , Building
Emacs, elisp, The GNU Emacs Lisp Reference Manual}, and the
@file{INSTALL} file.)

Three other site-wide initialization files are loaded automatically
each time you start Emacs, if they exist.  These are
@file{site-start.el}, which is loaded @emph{before} your @file{.emacs}
file, and @file{default.el}, and the terminal type file, which are both
loaded @emph{after} your @file{.emacs} file.

Settings and definitions in your @file{.emacs} file will overwrite
conflicting settings and definitions in a @file{site-start.el} file,
if it exists; but the settings and definitions in a @file{default.el}
or terminal type file will overwrite those in your @file{.emacs} file.
(You can prevent interference from a terminal type file by setting
@code{term-file-prefix} to @code{nil}.  @xref{Simple Extension, , A
Simple Extension}.)

@c Rewritten to avoid overfull hbox.
The @file{INSTALL} file that comes in the distribution contains
descriptions of the @file{site-init.el} and @file{site-load.el} files.

The @file{loadup.el}, @file{startup.el}, and @file{loaddefs.el} files
control loading.  These files are in the @file{lisp} directory of the
Emacs distribution and are worth perusing.

The @file{loaddefs.el} file contains a good many suggestions as to
what to put into your own @file{.emacs} file, or into a site-wide
initialization file.


@node defcustom, Beginning a .emacs File, Site-wide Init, Emacs Initialization
@section Specifying Variables using @code{defcustom}
@findex defcustom

You can specify variables using @code{defcustom} so that you and
others can then use Emacs' @code{customize} feature to set their
values.  (You cannot use @code{customize} to write function
definitions; but you can write @code{defuns} in your @file{.emacs}
file.  Indeed, you can write any Lisp expression in your @file{.emacs}
file.)

The @code{customize} feature depends on the @code{defcustom} special
form.  Although you can use @code{defvar} or @code{setq} for variables
that users set, the @code{defcustom} special form is designed for the
job.

You can use your knowledge of @code{defvar} for writing the
first three arguments for @code{defcustom}.  The first argument to
@code{defcustom} is the name of the variable.  The second argument is
the variable's initial value, if any; and this value is set only if
the value has not already been set.  The third argument is the
documentation.

The fourth and subsequent arguments to @code{defcustom} specify types
and options; these are not featured in @code{defvar}.  (These
arguments are optional.)

Each of these arguments consists of a keyword followed by a value.
Each keyword starts with the colon character @samp{:}.

@need 1250
For example, the customizable user option variable
@code{text-mode-hook} looks like this:

@smallexample
@group
(defcustom text-mode-hook nil
  "Normal hook run when entering Text mode and many related modes."
  :type 'hook
  :options '(turn-on-auto-fill flyspell-mode)
  :group 'data)
@end group
@end smallexample

@noindent
The name of the variable is @code{text-mode-hook}; it has no default
value; and its documentation string tells you what it does.

The @code{:type} keyword tells Emacs the kind of data to which
@code{text-mode-hook} should be set and how to display the value in a
Customization buffer.

The @code{:options} keyword specifies a suggested list of values for
the variable.  Usually, @code{:options} applies to a hook.
The list is only a suggestion; it is not exclusive; a person who sets
the variable may set it to other values; the list shown following the
@code{:options} keyword is intended to offer convenient choices to a
user.

Finally, the @code{:group} keyword tells the Emacs Customization
command in which group the variable is located.  This tells where to
find it.

The @code{defcustom} function recognizes more than a dozen keywords.
For more information, see @ref{Customization, , Writing Customization
Definitions, elisp, The GNU Emacs Lisp Reference Manual}.

Consider @code{text-mode-hook} as an example.

There are two ways to customize this variable.  You can use the
customization command or write the appropriate expressions yourself.

@need 800
Using the customization command,  you can type:

@smallexample
M-x customize
@end smallexample

@noindent
and find that the group for editing files of data is called `data'.
Enter that group.  Text Mode Hook is the first member.  You can click
on its various options, such as @code{turn-on-auto-fill}, to set the
values.  After you click on the button to

@smallexample
Save for Future Sessions
@end smallexample

@noindent
Emacs will write an expression into your @file{.emacs} file.
It will look like this:

@smallexample
@group
(custom-set-variables
  ;; custom-set-variables was added by Custom.
  ;; If you edit it by hand, you could mess it up, so be careful.
  ;; Your init file should contain only one such instance.
  ;; If there is more than one, they won't work right.
 '(text-mode-hook (quote (turn-on-auto-fill text-mode-hook-identify))))
@end group
@end smallexample

@noindent
(The @code{text-mode-hook-identify} function tells
@code{toggle-text-mode-auto-fill} which buffers are in Text mode.
It comes on automatically.)

The @code{custom-set-variables} function works somewhat differently
than a @code{setq}.  While I have never learned the differences, I
modify the @code{custom-set-variables} expressions in my @file{.emacs}
file by hand:  I make the changes in what appears to me to be a
reasonable manner and have not had any problems.  Others prefer to use
the Customization command and let Emacs do the work for them.

Another @code{custom-set-@dots{}} function is @code{custom-set-faces}.
This function sets the various font faces.  Over time, I have set a
considerable number of faces.  Some of the time, I re-set them using
@code{customize}; other times, I simply edit the
@code{custom-set-faces} expression in my @file{.emacs} file itself.

The second way to customize your @code{text-mode-hook} is to set it
yourself in your @file{.emacs} file using code that has nothing to do
with the @code{custom-set-@dots{}} functions.

@need 800
When you do this, and later use @code{customize}, you will see a
message that says

@smallexample
CHANGED outside Customize; operating on it here may be unreliable.
@end smallexample

@need 800
This message is only a warning.  If you click on the button to

@smallexample
Save for Future Sessions
@end smallexample

@noindent
Emacs will write a @code{custom-set-@dots{}} expression near the end
of your @file{.emacs} file that will be evaluated after your
hand-written expression.  It will, therefore, overrule your
hand-written expression.  No harm will be done.  When you do this,
however, be careful to remember which expression is active; if you
forget, you may confuse yourself.

So long as you remember where the values are set, you will have no
trouble.  In any event, the values are always set in your
initialization file, which is usually called @file{.emacs}.

I myself use @code{customize} for hardly anything.  Mostly, I write
expressions myself.

@findex defsubst
@findex defconst
Incidentally, to be more complete concerning defines:  @code{defsubst}
defines an inline function.  The syntax is just like that of
@code{defun}.  @code{defconst} defines a symbol as a constant.  The
intent is that neither programs nor users should ever change a value
set by @code{defconst}.  (You can change it; the value set is a
variable; but please do not.)


@node Beginning a .emacs File, Text and Auto-fill, defcustom, Emacs Initialization
@section Beginning a @file{.emacs} File
@cindex @file{.emacs} file, beginning of

When you start Emacs, it loads your @file{.emacs} file unless you tell
it not to by specifying @samp{-q} on the command line.  (The
@code{emacs -q} command gives you a plain, out-of-the-box Emacs.)

A @file{.emacs} file contains Lisp expressions.  Often, these are no
more than expressions to set values; sometimes they are function
definitions.

@xref{Init File, , The Init File @file{~/.emacs}, emacs, The GNU Emacs
Manual}, for a short description of initialization files.

This chapter goes over some of the same ground, but is a walk among
extracts from a complete, long-used @file{.emacs} file---my own.

The first part of the file consists of comments: reminders to myself.
By now, of course, I remember these things, but when I started, I did
not.

@need 1200
@smallexample
@group
;;;; Bob's .emacs file
; Robert J. Chassell
; 26 September 1985
@end group
@end smallexample

@noindent
Look at that date!  I started this file a long time ago.  I have been
adding to it ever since.

@smallexample
@group
; Each section in this file is introduced by a
; line beginning with four semicolons; and each
; entry is introduced by a line beginning with
; three semicolons.
@end group
@end smallexample

@noindent
This describes the usual conventions for comments in Emacs Lisp.
Everything on a line that follows a semicolon is a comment.  Two,
three, and four semicolons are used as subsection and section markers.
(@xref{Comments, ,, elisp, The GNU Emacs Lisp Reference Manual}, for
more about comments.)

@smallexample
@group
;;;; The Help Key
; Control-h is the help key;
; after typing control-h, type a letter to
; indicate the subject about which you want help.
; For an explanation of the help facility,
; type control-h two times in a row.
@end group
@end smallexample

@noindent
Just remember: type @kbd{C-h} two times for help.

@smallexample
@group
; To find out about any mode, type control-h m
; while in that mode.  For example, to find out
; about mail mode, enter mail mode and then type
; control-h m.
@end group
@end smallexample

@noindent
`Mode help', as I call this, is very helpful.  Usually, it tells you
all you need to know.

Of course, you don't need to include comments like these in your
@file{.emacs} file.  I included them in mine because I kept forgetting
about Mode help or the conventions for comments---but I was able to
remember to look here to remind myself.


@node Text and Auto-fill, Mail Aliases, Beginning a .emacs File, Emacs Initialization
@section Text and Auto Fill Mode

Now we come to the part that `turns on' Text mode and
Auto Fill mode.

@smallexample
@group
;;; Text mode and Auto Fill mode
;; The next two lines put Emacs into Text mode
;; and Auto Fill mode, and are for writers who
;; want to start writing prose rather than code.
(setq-default major-mode 'text-mode)
(add-hook 'text-mode-hook 'turn-on-auto-fill)
@end group
@end smallexample

Here is the first part of this @file{.emacs} file that does something
besides remind a forgetful human!

The first of the two lines in parentheses tells Emacs to turn on Text
mode when you find a file, @emph{unless} that file should go into some
other mode, such as C mode.

@cindex Per-buffer, local variables list
@cindex Local variables list, per-buffer,
@cindex Automatic mode selection
@cindex Mode selection, automatic
When Emacs reads a file, it looks at the extension to the file name,
if any.  (The extension is the part that comes after a @samp{.}.)  If
the file ends with a @samp{.c} or @samp{.h} extension then Emacs turns
on C mode.  Also, Emacs looks at first nonblank line of the file; if
the line says @w{@samp{-*- C -*-}}, Emacs turns on C mode.  Emacs
possesses a list of extensions and specifications that it uses
automatically.  In addition, Emacs looks near the last page for a
per-buffer, ``local variables list'', if any.

@ifinfo
@xref{Choosing Modes, , How Major Modes are Chosen, emacs, The GNU
Emacs Manual}.

@xref{File Variables, , Local Variables in Files, emacs, The GNU Emacs
Manual}.
@end ifinfo
@iftex
See sections ``How Major Modes are Chosen'' and ``Local Variables in
Files'' in @cite{The GNU Emacs Manual}.
@end iftex

Now, back to the @file{.emacs} file.

@need 800
Here is the line again; how does it work?

@cindex Text Mode turned on
@smallexample
(setq major-mode 'text-mode)
@end smallexample

@noindent
This line is a short, but complete Emacs Lisp expression.

We are already familiar with @code{setq}.  It sets the following variable,
@code{major-mode}, to the subsequent value, which is @code{text-mode}.
The single quote mark before @code{text-mode} tells Emacs to deal directly
with the @code{text-mode} symbol, not with whatever it might stand for.
@xref{set & setq, , 변수에 값 설정하기},
for a reminder of how @code{setq} works.
The main point is that there is no difference between the procedure you
use to set a value in your @file{.emacs} file and the procedure you use
anywhere else in Emacs.

@need 800
Here is the next line:

@cindex Auto Fill mode turned on
@findex add-hook
@smallexample
(add-hook 'text-mode-hook 'turn-on-auto-fill)
@end smallexample

@noindent
In this line, the @code{add-hook} command adds
@code{turn-on-auto-fill} to the variable.

@code{turn-on-auto-fill} is the name of a program, that, you guessed
it!, turns on Auto Fill mode.

Every time Emacs turns on Text mode, Emacs runs the commands `hooked'
onto Text mode.  So every time Emacs turns on Text mode, Emacs also
turns on Auto Fill mode.

In brief, the first line causes Emacs to enter Text mode when you edit a
file, unless the file name extension, a first non-blank line, or local
variables to tell Emacs otherwise.

Text mode among other actions, sets the syntax table to work
conveniently for writers.  In Text mode, Emacs considers an apostrophe
as part of a word like a letter; but Emacs does not consider a period
or a space as part of a word.  Thus, @kbd{M-f} moves you over
@samp{it's}.  On the other hand, in C mode, @kbd{M-f} stops just after
the @samp{t} of @samp{it's}.

The second line causes Emacs to turn on Auto Fill mode when it turns
on Text mode.  In Auto Fill mode, Emacs automatically breaks a line
that is too wide and brings the excessively wide part of the line down
to the next line.  Emacs breaks lines between words, not within them.

When Auto Fill mode is turned off, lines continue to the right as you
type them.  Depending on how you set the value of
@code{truncate-lines}, the words you type either disappear off the
right side of the screen, or else are shown, in a rather ugly and
unreadable manner, as a continuation line on the screen.

@need 1250
In addition, in this part of my @file{.emacs} file, I tell the Emacs
fill commands to insert two spaces after a colon:

@smallexample
(setq colon-double-space t)
@end smallexample


@node Mail Aliases, Indent Tabs Mode, Text and Auto-fill, Emacs Initialization
@section Mail Aliases

Here is a @code{setq} that `turns on' mail aliases, along with more
reminders.

@smallexample
@group
;;; Mail mode
; To enter mail mode, type `C-x m'
; To enter RMAIL (for reading mail),
; type `M-x rmail'
(setq mail-aliases t)
@end group
@end smallexample

@cindex Mail aliases
@noindent
This @code{setq} command sets the value of the variable
@code{mail-aliases} to @code{t}.  Since @code{t} means true, the line
says, in effect, ``Yes, use mail aliases.''

Mail aliases are convenient short names for long email addresses or
for lists of email addresses.  The file where you keep your `aliases'
is @file{~/.mailrc}.  You write an alias like this:

@smallexample
alias geo george@@foobar.wiz.edu
@end smallexample

@noindent
When you write a message to George, address it to @samp{geo}; the
mailer will automatically expand @samp{geo} to the full address.


@node Indent Tabs Mode, Keybindings, Mail Aliases, Emacs Initialization
@section Indent Tabs Mode
@cindex Tabs, preventing
@findex indent-tabs-mode

By default, Emacs inserts tabs in place of multiple spaces when it
formats a region.  (For example, you might indent many lines of text
all at once with the @code{indent-region} command.)  Tabs look fine on
a terminal or with ordinary printing, but they produce badly indented
output when you use @TeX{} or Texinfo since @TeX{} ignores tabs.

@need 1250
The following turns off Indent Tabs mode:

@smallexample
@group
;;; Prevent Extraneous Tabs
(setq-default indent-tabs-mode nil)
@end group
@end smallexample

Note that this line uses @code{setq-default} rather than the
@code{setq} command that we have seen before.  The @code{setq-default}
command sets values only in buffers that do not have their own local
values for the variable.

@ifinfo
@xref{Just Spaces, , Tabs vs. Spaces, emacs, The GNU Emacs Manual}.

@xref{File Variables, , Local Variables in Files, emacs, The GNU Emacs
Manual}.
@end ifinfo
@iftex
See sections ``Tabs vs.@: Spaces'' and ``Local Variables in
Files'' in @cite{The GNU Emacs Manual}.
@end iftex


@need 1700
@node Keybindings, Keymaps, Indent Tabs Mode, Emacs Initialization
@section Some Keybindings

Now for some personal keybindings:

@smallexample
@group
;;; Compare windows
(global-set-key "\C-cw" 'compare-windows)
@end group
@end smallexample

@findex compare-windows
@code{compare-windows} is a nifty command that compares the text in
your current window with text in the next window.  It makes the
comparison by starting at point in each window, moving over text in
each window as far as they match.  I use this command all the time.

This also shows how to set a key globally, for all modes.

@cindex Setting a key globally
@cindex Global set key
@cindex Key setting globally
@findex global-set-key
The command is @code{global-set-key}.  It is followed by the
keybinding.  In a @file{.emacs} file, the keybinding is written as
shown: @code{\C-c} stands for `control-c', which means `press the
control key and the @key{c} key at the same time'.  The @code{w} means
`press the @key{w} key'.  The keybinding is surrounded by double
quotation marks.  In documentation, you would write this as
@w{@kbd{C-c w}}.  (If you were binding a @key{META} key, such as
@kbd{M-c}, rather than a @key{CTRL} key, you would write
@w{@code{\M-c}} in your @file{.emacs} file.  @xref{Init Rebinding, ,
Rebinding Keys in Your Init File, emacs, The GNU Emacs Manual}, for
details.)

The command invoked by the keys is @code{compare-windows}.  Note that
@code{compare-windows} is preceded by a single quote; otherwise, Emacs
would first try to evaluate the symbol to determine its value.

These three things, the double quotation marks, the backslash before
the @samp{C}, and the single quote mark are necessary parts of
keybinding that I tend to forget.  Fortunately, I have come to
remember that I should look at my existing @file{.emacs} file, and
adapt what is there.

As for the keybinding itself: @kbd{C-c w}.  This combines the prefix
key, @kbd{C-c}, with a single character, in this case, @kbd{w}.  This
set of keys, @kbd{C-c} followed by a single character, is strictly
reserved for individuals' own use.  (I call these `own' keys, since
these are for my own use.)  You should always be able to create such a
keybinding for your own use without stomping on someone else's
keybinding.  If you ever write an extension to Emacs, please avoid
taking any of these keys for public use.  Create a key like @kbd{C-c
C-w} instead.  Otherwise, we will run out of `own' keys.

@need 1250
Here is another keybinding, with a comment:

@smallexample
@group
;;; Keybinding for `occur'
; I use occur a lot, so let's bind it to a key:
(global-set-key "\C-co" 'occur)
@end group
@end smallexample

@findex occur
The @code{occur} command shows all the lines in the current buffer
that contain a match for a regular expression.  Matching lines are
shown in a buffer called @file{*Occur*}.  That buffer serves as a menu
to jump to occurrences.

@findex global-unset-key
@cindex Unbinding key
@cindex Key unbinding
@need 1250
Here is how to unbind a key, so it does not
work:

@smallexample
@group
;;; Unbind `C-x f'
(global-unset-key "\C-xf")
@end group
@end smallexample

There is a reason for this unbinding: I found I inadvertently typed
@w{@kbd{C-x f}} when I meant to type @kbd{C-x C-f}.  Rather than find a
file, as I intended, I accidentally set the width for filled text,
almost always to a width I did not want.  Since I hardly ever reset my
default width, I simply unbound the key.

@findex list-buffers, @r{rebound}
@findex buffer-menu, @r{bound to key}
@need 1250
The following rebinds an existing key:

@smallexample
@group
;;; Rebind `C-x C-b' for `buffer-menu'
(global-set-key "\C-x\C-b" 'buffer-menu)
@end group
@end smallexample

By default, @kbd{C-x C-b} runs the
@code{list-buffers} command.  This command lists
your buffers in @emph{another} window.  Since I
almost always want to do something in that
window, I prefer the  @code{buffer-menu}
command, which not only lists the buffers,
but moves point into that window.


@node Keymaps, Loading Files, Keybindings, Emacs Initialization
@section Keymaps
@cindex Keymaps
@cindex Rebinding keys

Emacs uses @dfn{keymaps} to record which keys call which commands.
When you use @code{global-set-key} to set the keybinding for a single
command in all parts of Emacs, you are specifying the keybinding in
@code{current-global-map}.

Specific modes, such as C mode or Text mode, have their own keymaps;
the mode-specific keymaps override the global map that is shared by
all buffers.

The @code{global-set-key} function binds, or rebinds, the global
keymap.  For example, the following binds the key @kbd{C-x C-b} to the
function @code{buffer-menu}:

@smallexample
(global-set-key "\C-x\C-b" 'buffer-menu)
@end smallexample

Mode-specific keymaps are bound using the @code{define-key} function,
which takes a specific keymap as an argument, as well as the key and
the command.  For example, my @file{.emacs} file contains the
following expression to bind the @code{texinfo-insert-@@group} command
to @kbd{C-c C-c g}:

@smallexample
@group
(define-key texinfo-mode-map "\C-c\C-cg" 'texinfo-insert-@@group)
@end group
@end smallexample

@noindent
The @code{texinfo-insert-@@group} function itself is a little extension
to Texinfo mode that inserts @samp{@@group} into a Texinfo file.  I
use this command all the time and prefer to type the three strokes
@kbd{C-c C-c g} rather than the six strokes @kbd{@@ g r o u p}.
(@samp{@@group} and its matching @samp{@@end group} are commands that
keep all enclosed text together on one page; many multi-line examples
in this book are surrounded by @samp{@@group @dots{} @@end group}.)

@need 1250
Here is the @code{texinfo-insert-@@group} function definition:

@smallexample
@group
(defun texinfo-insert-@@group ()
  "Insert the string @@group in a Texinfo buffer."
  (interactive)
  (beginning-of-line)
  (insert "@@group\n"))
@end group
@end smallexample

(Of course, I could have used Abbrev mode to save typing, rather than
write a function to insert a word; but I prefer key strokes consistent
with other Texinfo mode key bindings.)

You will see numerous @code{define-key} expressions in
@file{loaddefs.el} as well as in the various mode libraries, such as
@file{cc-mode.el} and @file{lisp-mode.el}.

@xref{Key Bindings, , Customizing Key Bindings, emacs, The GNU Emacs
Manual}, and @ref{Keymaps, , Keymaps, elisp, The GNU Emacs Lisp
Reference Manual}, for more information about keymaps.


@node Loading Files, Autoload, Keymaps, Emacs Initialization
@section Loading Files
@cindex Loading files
@c findex load

Many people in the GNU Emacs community have written extensions to
Emacs.  As time goes by, these extensions are often included in new
releases.  For example, the Calendar and Diary packages are now part
of the standard GNU Emacs, as is Calc.

You can use a @code{load} command to evaluate a complete file and
thereby install all the functions and variables in the file into Emacs.
For example:

@c (auto-compression-mode t)

@smallexample
(load "~/emacs/slowsplit")
@end smallexample

This evaluates, i.e.@: loads, the @file{slowsplit.el} file or if it
exists, the faster, byte compiled @file{slowsplit.elc} file from the
@file{emacs} sub-directory of your home directory.  The file contains
the function @code{split-window-quietly}, which John Robinson wrote in
1989.

The @code{split-window-quietly} function splits a window with the
minimum of redisplay.  I installed it in 1989 because it worked well
with the slow 1200 baud terminals I was then using.  Nowadays, I only
occasionally come across such a slow connection, but I continue to use
the function because I like the way it leaves the bottom half of a
buffer in the lower of the new windows and the top half in the upper
window.

@need 1250
To replace the key binding for the default
@code{split-window-vertically}, you must also unset that key and bind
the keys to @code{split-window-quietly}, like this:

@smallexample
@group
(global-unset-key "\C-x2")
(global-set-key "\C-x2" 'split-window-quietly)
@end group
@end smallexample

@vindex load-path
If you load many extensions, as I do, then instead of specifying the
exact location of the extension file, as shown above, you can specify
that directory as part of Emacs' @code{load-path}.  Then, when Emacs
loads a file, it will search that directory as well as its default
list of directories.  (The default list is specified in @file{paths.h}
when Emacs is built.)

@need 1250
The following command adds your @file{~/emacs} directory to the
existing load path:

@smallexample
@group
;;; Emacs Load Path
(setq load-path (cons "~/emacs" load-path))
@end group
@end smallexample

Incidentally, @code{load-library} is an interactive interface to the
@code{load} function.  The complete function looks like this:

@findex load-library
@smallexample
@group
(defun load-library (library)
  "Load the library named LIBRARY.
This is an interface to the function `load'."
  (interactive
   (list (completing-read "Load library: "
			  (apply-partially 'locate-file-completion-table
                                           load-path
                                           (get-load-suffixes)))))
  (load library))
@end group
@end smallexample

The name of the function, @code{load-library}, comes from the use of
`library' as a conventional synonym for `file'.  The source for the
@code{load-library} command is in the @file{files.el} library.

Another interactive command that does a slightly different job is
@code{load-file}.  @xref{Lisp Libraries, , Libraries of Lisp Code for
Emacs, emacs, The GNU Emacs Manual}, for information on the
distinction between @code{load-library} and this command.


@node Autoload, Simple Extension, Loading Files, Emacs Initialization
@section Autoloading
@findex autoload

Instead of installing a function by loading the file that contains it,
or by evaluating the function definition, you can make the function
available but not actually install it until it is first called.  This
is called @dfn{autoloading}.

When you execute an autoloaded function, Emacs automatically evaluates
the file that contains the definition, and then calls the function.

Emacs starts quicker with autoloaded functions, since their libraries
are not loaded right away; but you need to wait a moment when you
first use such a function, while its containing file is evaluated.

Rarely used functions are frequently autoloaded.  The
@file{loaddefs.el} library contains hundreds of autoloaded functions,
from @code{bookmark-set} to @code{wordstar-mode}.  Of course, you may
come to use a `rare' function frequently.  When you do, you should
load that function's file with a @code{load} expression in your
@file{.emacs} file.

In my @file{.emacs} file, I load 14 libraries that contain functions
that would otherwise be autoloaded.  (Actually, it would have been
better to include these files in my `dumped' Emacs, but I forgot.
@xref{Building Emacs, , Building Emacs, elisp, The GNU Emacs Lisp
Reference Manual}, and the @file{INSTALL} file for more about
dumping.)

You may also want to include autoloaded expressions in your @file{.emacs}
file.  @code{autoload} is a built-in function that takes up to five
arguments, the final three of which are optional.  The first argument
is the name of the function to be autoloaded; the second is the name
of the file to be loaded.  The third argument is documentation for the
function, and the fourth tells whether the function can be called
interactively.  The fifth argument tells what type of
object---@code{autoload} can handle a keymap or macro as well as a
function (the default is a function).

@need 800
Here is a typical example:

@smallexample
@group
(autoload 'html-helper-mode
  "html-helper-mode" "Edit HTML documents" t)
@end group
@end smallexample

@noindent
(@code{html-helper-mode} is an older alternative to @code{html-mode},
which is a standard part of the distribution.)

@noindent
This expression autoloads the @code{html-helper-mode} function.  It
takes it from the @file{html-helper-mode.el} file (or from the byte
compiled version @file{html-helper-mode.elc}, if that exists.)  The
file must be located in a directory specified by @code{load-path}.
The documentation says that this is a mode to help you edit documents
written in the HyperText Markup Language.  You can call this mode
interactively by typing @kbd{M-x html-helper-mode}.  (You need to
duplicate the function's regular documentation in the autoload
expression because the regular function is not yet loaded, so its
documentation is not available.)

@xref{Autoload, , Autoload, elisp, The GNU Emacs Lisp Reference
Manual}, for more information.


@node Simple Extension, X11 Colors, Autoload, Emacs Initialization
@section A Simple Extension: @code{line-to-top-of-window}
@findex line-to-top-of-window
@cindex Simple extension in @file{.emacs} file

Here is a simple extension to Emacs that moves the line point is on to
the top of the window.  I use this all the time, to make text easier
to read.

You can put the following code into a separate file and then load it
from your @file{.emacs} file, or you can include it within your
@file{.emacs} file.

@need 1250
Here is the definition:

@smallexample
@group
;;; Line to top of window;
;;; replace three keystroke sequence  C-u 0 C-l
(defun line-to-top-of-window ()
  "Move the line point is on to top of window."
  (interactive)
  (recenter 0))
@end group
@end smallexample

@need 1250
Now for the keybinding.

Nowadays, function keys as well as mouse button events and
non-@sc{ascii} characters are written within square brackets, without
quotation marks.  (In Emacs version 18 and before, you had to write
different function key bindings for each different make of terminal.)

I bind @code{line-to-top-of-window} to my @key{F6} function key like
this:

@smallexample
(global-set-key [f6] 'line-to-top-of-window)
@end smallexample

For more information, see @ref{Init Rebinding, , Rebinding Keys in
Your Init File, emacs, The GNU Emacs Manual}.

@cindex Conditional 'twixt two versions of Emacs
@cindex Version of Emacs, choosing
@cindex Emacs version, choosing
If you run two versions of GNU Emacs, such as versions 22 and 23, and
use one @file{.emacs} file, you can select which code to evaluate with
the following conditional:

@smallexample
@group
(cond
 ((= 22 emacs-major-version)
  ;; evaluate version 22 code
  ( @dots{} ))
 ((= 23 emacs-major-version)
  ;; evaluate version 23 code
  ( @dots{} )))
@end group
@end smallexample

For example, in contrast to version 20, more recent versions blink
their cursors by default.  I hate such blinking, as well as other
features, so I placed the following in my @file{.emacs}
file@footnote{When I start instances of Emacs that do not load my
@file{.emacs} file or any site file, I also turn off blinking:

@smallexample
emacs -q --no-site-file -eval '(blink-cursor-mode nil)'

@exdent Or nowadays, using an even more sophisticated set of options,

emacs -Q - D
@end smallexample
}:

@smallexample
@group
(when (>= emacs-major-version 21)
  (blink-cursor-mode 0)
  ;; Insert newline when you press `C-n' (next-line)
  ;; at the end of the buffer
  (setq next-line-add-newlines t)
@end group
@group
  ;; Turn on image viewing
  (auto-image-file-mode t)
@end group
@group
  ;; Turn on menu bar (this bar has text)
  ;; (Use numeric argument to turn on)
  (menu-bar-mode 1)
@end group
@group
  ;; Turn off tool bar (this bar has icons)
  ;; (Use numeric argument to turn on)
  (tool-bar-mode nil)
@end group
@group
  ;; Turn off tooltip mode for tool bar
  ;; (This mode causes icon explanations to pop up)
  ;; (Use numeric argument to turn on)
  (tooltip-mode nil)
  ;; If tooltips turned on, make tips appear promptly
  (setq tooltip-delay 0.1)  ; default is 0.7 second
   )
@end group
@end smallexample


@node X11 Colors, Miscellaneous, Simple Extension, Emacs Initialization
@section X11 Colors

You can specify colors when you use Emacs with the MIT X Windowing
system.

I dislike the default colors and specify my own.

@need 1250
Here are the expressions in my @file{.emacs}
file that set values:

@smallexample
@group
;; Set cursor color
(set-cursor-color "white")

;; Set mouse color
(set-mouse-color "white")

;; Set foreground and background
(set-foreground-color "white")
(set-background-color "darkblue")
@end group

@group
;;; Set highlighting colors for isearch and drag
(set-face-foreground 'highlight "white")
(set-face-background 'highlight "blue")
@end group

@group
(set-face-foreground 'region "cyan")
(set-face-background 'region "blue")
@end group

@group
(set-face-foreground 'secondary-selection "skyblue")
(set-face-background 'secondary-selection "darkblue")
@end group

@group
;; Set calendar highlighting colors
(setq calendar-load-hook
      '(lambda ()
         (set-face-foreground 'diary-face   "skyblue")
         (set-face-background 'holiday-face "slate blue")
         (set-face-foreground 'holiday-face "white")))
@end group
@end smallexample

The various shades of blue soothe my eye and prevent me from seeing
the screen flicker.

Alternatively, I could have set my specifications in various X
initialization files.  For example, I could set the foreground,
background, cursor, and pointer (i.e., mouse) colors in my
@file{~/.Xresources} file like this:

@smallexample
@group
Emacs*foreground:   white
Emacs*background:   darkblue
Emacs*cursorColor:  white
Emacs*pointerColor: white
@end group
@end smallexample

In any event, since it is not part of Emacs, I set the root color of
my X window in my @file{~/.xinitrc} file, like this@footnote{I also
run more modern window managers, such as Enlightenment, Gnome, or KDE;
in those cases, I often specify an image rather than a plain color.}:

@smallexample
xsetroot -solid Navy -fg white &
@end smallexample

@need 1700
@node Miscellaneous, Mode Line, X11 Colors, Emacs Initialization
@section Miscellaneous Settings for a @file{.emacs} File

@need 1250
Here are a few miscellaneous settings:
@sp 1

@itemize @minus
@item
Set the shape and color of the mouse cursor:

@smallexample
@group
; Cursor shapes are defined in
; `/usr/include/X11/cursorfont.h';
; for example, the `target' cursor is number 128;
; the `top_left_arrow' cursor is number 132.
@end group

@group
(let ((mpointer (x-get-resource "*mpointer"
                                "*emacs*mpointer")))
  ;; If you have not set your mouse pointer
  ;;     then set it, otherwise leave as is:
  (if (eq mpointer nil)
      (setq mpointer "132")) ; top_left_arrow
@end group
@group
  (setq x-pointer-shape (string-to-int mpointer))
  (set-mouse-color "white"))
@end group
@end smallexample

@item
Or you can set the values of a variety of features in an alist, like
this:

@smallexample
@group
(setq-default
 default-frame-alist
 '((cursor-color . "white")
   (mouse-color . "white")
   (foreground-color . "white")
   (background-color . "DodgerBlue4")
   ;; (cursor-type . bar)
   (cursor-type . box)
@end group
@group
   (tool-bar-lines . 0)
   (menu-bar-lines . 1)
   (width . 80)
   (height . 58)
   (font .
         "-Misc-Fixed-Medium-R-Normal--20-200-75-75-C-100-ISO8859-1")
   ))
@end group
@end smallexample

@item
Convert @kbd{@key{CTRL}-h} into @key{DEL} and @key{DEL}
into @kbd{@key{CTRL}-h}.@*
(Some older keyboards needed this, although I have not seen the
problem recently.)

@smallexample
@group
;; Translate `C-h' to <DEL>.
; (keyboard-translate ?\C-h ?\C-?)

;; Translate <DEL> to `C-h'.
(keyboard-translate ?\C-? ?\C-h)
@end group
@end smallexample

@item Turn off a blinking cursor!

@smallexample
@group
(if (fboundp 'blink-cursor-mode)
    (blink-cursor-mode -1))
@end group
@end smallexample

@noindent
or start GNU Emacs with the command @code{emacs -nbc}.

@need 1250
@item When using `grep'@*
@samp{-i}@w{  }   Ignore case distinctions@*
@samp{-n}@w{  }   Prefix each line of output with line number@*
@samp{-H}@w{  }   Print the filename for each match.@*
@samp{-e}@w{  }   Protect patterns beginning with a hyphen character, @samp{-}

@smallexample
(setq grep-command "grep -i -nH -e ")
@end smallexample

@ignore
@c Evidently, no longer needed in GNU Emacs 22

item Automatically uncompress compressed files when visiting them

smallexample
(load "uncompress")
end smallexample

@end ignore

@item Find an existing buffer, even if it has a different name@*
This avoids problems with symbolic links.

@smallexample
(setq find-file-existing-other-name t)
@end smallexample

@item Set your language environment and default input method

@smallexample
@group
(set-language-environment "latin-1")
;; Remember you can enable or disable multilingual text input
;; with the @code{toggle-input-method'} (@kbd{C-\}) command
(setq default-input-method "latin-1-prefix")
@end group
@end smallexample

If you want to write with Chinese `GB' characters, set this instead:

@smallexample
@group
(set-language-environment "Chinese-GB")
(setq default-input-method "chinese-tonepy")
@end group
@end smallexample
@end itemize

@subsubheading Fixing Unpleasant Key Bindings
@cindex Key bindings, fixing
@cindex Bindings, key, fixing unpleasant

Some systems bind keys unpleasantly.  Sometimes, for example, the
@key{CTRL} key appears in an awkward spot rather than at the far left
of the home row.

Usually, when people fix these sorts of keybindings, they do not
change their @file{~/.emacs} file.  Instead, they bind the proper keys
on their consoles with the @code{loadkeys} or @code{install-keymap}
commands in their boot script and then include @code{xmodmap} commands
in their @file{.xinitrc} or @file{.Xsession} file for X Windows.

@need 1250
@noindent
For a boot script:

@smallexample
@group
loadkeys /usr/share/keymaps/i386/qwerty/emacs2.kmap.gz
@exdent or
install-keymap emacs2
@end group
@end smallexample

@need 1250
@noindent
For a @file{.xinitrc} or @file{.Xsession} file when the @key{Caps
Lock} key is at the far left of the home row:

@smallexample
@group
# Bind the key labeled `Caps Lock' to `Control'
# (Such a broken user interface suggests that keyboard manufacturers
# think that computers are typewriters from 1885.)

xmodmap -e "clear Lock"
xmodmap -e "add Control = Caps_Lock"
@end group
@end smallexample

@need 1250
@noindent
In a @file{.xinitrc} or @file{.Xsession} file, to convert an @key{ALT}
key to a @key{META} key:

@smallexample
@group
# Some ill designed keyboards have a key labeled ALT and no Meta
xmodmap -e "keysym Alt_L = Meta_L Alt_L"
@end group
@end smallexample

@need 1700
@node Mode Line,  , Miscellaneous, Emacs Initialization
@section A Modified Mode Line
@vindex mode-line-format
@cindex Mode line format

Finally, a feature I really like: a modified mode line.

When I work over a network, I forget which machine I am using.  Also,
I tend to I lose track of where I am, and which line point is on.

So I reset my mode line to look like this:

@smallexample
-:-- foo.texi   rattlesnake:/home/bob/  Line 1  (Texinfo Fill) Top
@end smallexample

I am visiting a file called @file{foo.texi}, on my machine
@file{rattlesnake} in my @file{/home/bob} buffer.  I am on line 1, in
Texinfo mode, and am at the top of the buffer.

@need 1200
My @file{.emacs} file has a section that looks like this:

@smallexample
@group
;; Set a Mode Line that tells me which machine, which directory,
;; and which line I am on, plus the other customary information.
(setq-default mode-line-format
 (quote
  (#("-" 0 1
     (help-echo
      "mouse-1: select window, mouse-2: delete others ..."))
   mode-line-mule-info
   mode-line-modified
   mode-line-frame-identification
   "    "
@end group
@group
   mode-line-buffer-identification
   "    "
   (:eval (substring
           (system-name) 0 (string-match "\\..+" (system-name))))
   ":"
   default-directory
   #(" " 0 1
     (help-echo
      "mouse-1: select window, mouse-2: delete others ..."))
   (line-number-mode " Line %l ")
   global-mode-string
@end group
@group
   #("   %[(" 0 6
     (help-echo
      "mouse-1: select window, mouse-2: delete others ..."))
   (:eval (mode-line-mode-name))
   mode-line-process
   minor-mode-alist
   #("%n" 0 2 (help-echo "mouse-2: widen" local-map (keymap ...)))
   ")%] "
   (-3 . "%P")
   ;;   "-%-"
   )))
@end group
@end smallexample

@noindent
Here, I redefine the default mode line.  Most of the parts are from
the original; but I make a few changes.  I set the @emph{default} mode
line format so as to permit various modes, such as Info, to override
it.

Many elements in the list are self-explanatory:
@code{mode-line-modified} is a variable that tells whether the buffer
has been modified, @code{mode-name} tells the name of the mode, and so
on.  However, the format looks complicated because of two features we
have not discussed.

@cindex Properties, in mode line example
The first string in the mode line is a dash or hyphen, @samp{-}.  In
the old days, it would have been specified simply as @code{"-"}.  But
nowadays, Emacs can add properties to a string, such as highlighting
or, as in this case, a help feature.  If you place your mouse cursor
over the hyphen, some help information appears (By default, you must
wait seven-tenths of a second before the information appears.  You can
change that timing by changing the value of @code{tooltip-delay}.)

@need 1000
The new string format has a special syntax:

@smallexample
#("-" 0 1 (help-echo "mouse-1: select window, ..."))
@end smallexample

@noindent
The @code{#(} begins a list.  The first element of the list is the
string itself, just one @samp{-}.  The second and third
elements specify the range over which the fourth element applies.  A
range starts @emph{after} a character, so a zero means the range
starts just before the first character; a 1 means that the range ends
just after the first character.  The third element is the property for
the range.  It consists of a property list,  a
property name, in this case, @samp{help-echo}, followed by a value, in this
case, a string.  The second, third, and fourth elements of this new
string format can be repeated.

@xref{Text Properties, , Text Properties, elisp, The GNU Emacs Lisp
Reference Manual}, and see @ref{Mode Line Format, , Mode Line Format,
elisp, The GNU Emacs Lisp Reference Manual}, for more information.

@code{mode-line-buffer-identification}
displays the current buffer name.  It is a list
beginning @code{(#("%12b" 0 4 @dots{}}.
The @code{#(} begins the list.

The @samp{"%12b"} displays the current buffer name, using the
@code{buffer-name} function with which we are familiar; the `12'
specifies the maximum number of characters that will be displayed.
When a name has fewer characters, whitespace is added to fill out to
this number.  (Buffer names can and often should be longer than 12
characters; this length works well in a typical 80 column wide
window.)

@code{:eval} says to evaluate the following form and use the result as
a string to display.  In this case, the expression displays the first
component of the full system name.  The end of the first component is
a @samp{.} (`period'), so I use the @code{string-match} function to
tell me the length of the first component.  The substring from the
zeroth character to that length is the name of the machine.

@need 1250
This is the expression:

@smallexample
@group
(:eval (substring
        (system-name) 0 (string-match "\\..+" (system-name))))
@end group
@end smallexample

@samp{%[} and @samp{%]} cause a pair of square brackets
to appear for each recursive editing level.  @samp{%n} says `Narrow'
when narrowing is in effect.  @samp{%P} tells you the percentage of
the buffer that is above the bottom of the window, or `Top', `Bottom',
or `All'.  (A lower case @samp{p} tell you the percentage above the
@emph{top} of the window.)  @samp{%-} inserts enough dashes to fill
out the line.

Remember, ``You don't have to like Emacs to like it'' --- your own
Emacs can have different colors, different commands, and different
keys than a default Emacs.

On the other hand, if you want to bring up a plain `out of the box'
Emacs, with no customization, type:

@smallexample
emacs -q
@end smallexample

@noindent
This will start an Emacs that does @emph{not} load your
@file{~/.emacs} initialization file.  A plain, default Emacs.  Nothing
more.


@node Debugging, Conclusion, Emacs Initialization, Top
@chapter Debugging
@cindex debugging

GNU Emacs has two debuggers, @code{debug} and @code{edebug}.  The
first is built into the internals of Emacs and is always with you;
the second requires that you instrument a function before you can use it.

Both debuggers are described extensively in @ref{Debugging, ,
Debugging Lisp Programs, elisp, The GNU Emacs Lisp Reference Manual}.
In this chapter, I will walk through a short example of each.

@menu
* debug::                       How to use the built-in debugger.
* debug-on-entry::              Start debugging when you call a function.
* debug-on-quit::               Start debugging when you quit with @kbd{C-g}.
* edebug::                      How to use Edebug, a source level debugger.
* Debugging Exercises::
@end menu


@node debug, debug-on-entry, Debugging, Debugging
@section @code{debug}
@findex debug

Suppose you have written a function definition that is intended to
return the sum of the numbers 1 through a given number.  (This is the
@code{triangle} function discussed earlier.  @xref{Decrementing
Example, , Example with Decrementing Counter}, for a discussion.)
@c xref{Decrementing Loop,, Loop with a Decrementing Counter}, for a discussion.)

However, your function definition has a bug.  You have mistyped
@samp{1=} for @samp{1-}.  Here is the broken definition:

@findex triangle-bugged
@smallexample
@group
(defun triangle-bugged (number)
  "Return sum of numbers 1 through NUMBER inclusive."
  (let ((total 0))
    (while (> number 0)
      (setq total (+ total number))
      (setq number (1= number)))      ; @r{Error here.}
    total))
@end group
@end smallexample

If you are reading this in Info, you can evaluate this definition in
the normal fashion.  You will see @code{triangle-bugged} appear in the
echo area.

@need 1250
Now evaluate the @code{triangle-bugged} function with an
argument of 4:

@smallexample
(triangle-bugged 4)
@end smallexample

@noindent
In a recent GNU Emacs, you will create and enter a @file{*Backtrace*}
buffer that says:

@noindent
@smallexample
@group
---------- Buffer: *Backtrace* ----------
Debugger entered--Lisp error: (void-function 1=)
  (1= number)
  (setq number (1= number))
  (while (> number 0) (setq total (+ total number))
        (setq number (1= number)))
  (let ((total 0)) (while (> number 0) (setq total ...)
    (setq number ...)) total)
  triangle-bugged(4)
@end group
@group
  eval((triangle-bugged 4))
  eval-last-sexp-1(nil)
  eval-last-sexp(nil)
  call-interactively(eval-last-sexp)
---------- Buffer: *Backtrace* ----------
@end group
@end smallexample

@noindent
(I have reformatted this example slightly; the debugger does not fold
long lines.  As usual, you can quit the debugger by typing @kbd{q} in
the @file{*Backtrace*} buffer.)

In practice, for a bug as simple as this, the `Lisp error' line will
tell you what you need to know to correct the definition.  The
function @code{1=} is `void'.

@ignore
@need 800
In GNU Emacs 20 and before, you will see:

@smallexample
Symbol's function definition is void:@: 1=
@end smallexample

@noindent
which has the same meaning as the @file{*Backtrace*} buffer line in
version 21.
@end ignore

However, suppose you are not quite certain what is going on?
You can read the complete backtrace.

In this case, you need to run a recent GNU Emacs, which automatically
starts the debugger that puts you in the @file{*Backtrace*} buffer; or
else, you need to start the debugger manually as described below.

Read the @file{*Backtrace*} buffer from the bottom up; it tells you
what Emacs did that led to the error.  Emacs made an interactive call
to @kbd{C-x C-e} (@code{eval-last-sexp}), which led to the evaluation
of the @code{triangle-bugged} expression.  Each line above tells you
what the Lisp interpreter evaluated next.

@need 1250
The third line from the top of the buffer is

@smallexample
(setq number (1= number))
@end smallexample

@noindent
Emacs tried to evaluate this expression; in order to do so, it tried
to evaluate the inner expression shown on the second line from the
top:

@smallexample
(1= number)
@end smallexample

@need 1250
@noindent
This is where the error occurred; as the top line says:

@smallexample
Debugger entered--Lisp error: (void-function 1=)
@end smallexample

@noindent
You can correct the mistake, re-evaluate the function definition, and
then run your test again.


@node debug-on-entry, debug-on-quit, debug, Debugging
@section @code{debug-on-entry}
@findex debug-on-entry

A recent GNU Emacs starts the debugger automatically when your
function has an error.

@ignore
GNU Emacs version 20 and before did not; it simply
presented you with an error message.  You had to start the debugger
manually.
@end ignore

Incidentally, you can start the debugger manually for all versions of
Emacs; the advantage is that the debugger runs even if you do not have
a bug in your code.  Sometimes your code will be free of bugs!

You can enter the debugger when you call the function by calling
@code{debug-on-entry}.

@need 1250
@noindent
Type:

@smallexample
M-x debug-on-entry RET triangle-bugged RET
@end smallexample

@need 1250
@noindent
Now, evaluate the following:

@smallexample
(triangle-bugged 5)
@end smallexample

@noindent
All versions of Emacs will create a @file{*Backtrace*} buffer and tell
you that it is beginning to evaluate the @code{triangle-bugged}
function:

@smallexample
@group
---------- Buffer: *Backtrace* ----------
Debugger entered--entering a function:
* triangle-bugged(5)
  eval((triangle-bugged 5))
@end group
@group
  eval-last-sexp-1(nil)
  eval-last-sexp(nil)
  call-interactively(eval-last-sexp)
---------- Buffer: *Backtrace* ----------
@end group
@end smallexample

In the @file{*Backtrace*} buffer, type @kbd{d}.  Emacs will evaluate
the first expression in @code{triangle-bugged}; the buffer will look
like this:

@smallexample
@group
---------- Buffer: *Backtrace* ----------
Debugger entered--beginning evaluation of function call form:
* (let ((total 0)) (while (> number 0) (setq total ...)
        (setq number ...)) total)
* triangle-bugged(5)
  eval((triangle-bugged 5))
@end group
@group
  eval-last-sexp-1(nil)
  eval-last-sexp(nil)
  call-interactively(eval-last-sexp)
---------- Buffer: *Backtrace* ----------
@end group
@end smallexample

@noindent
Now, type @kbd{d} again, eight times, slowly.  Each time you type
@kbd{d}, Emacs will evaluate another expression in the function
definition.

@need 1750
Eventually, the buffer will look like this:

@smallexample
@group
---------- Buffer: *Backtrace* ----------
Debugger entered--beginning evaluation of function call form:
* (setq number (1= number))
* (while (> number 0) (setq total (+ total number))
        (setq number (1= number)))
@group
@end group
* (let ((total 0)) (while (> number 0) (setq total ...)
        (setq number ...)) total)
* triangle-bugged(5)
  eval((triangle-bugged 5))
@group
@end group
  eval-last-sexp-1(nil)
  eval-last-sexp(nil)
  call-interactively(eval-last-sexp)
---------- Buffer: *Backtrace* ----------
@end group
@end smallexample

@need 1500
@noindent
Finally, after you type @kbd{d} two more times, Emacs will reach the
error, and the top two lines of the @file{*Backtrace*} buffer will look
like this:

@smallexample
@group
---------- Buffer: *Backtrace* ----------
Debugger entered--Lisp error: (void-function 1=)
* (1= number)
@dots{}
---------- Buffer: *Backtrace* ----------
@end group
@end smallexample

By typing @kbd{d}, you were able to step through the function.

You can quit a @file{*Backtrace*} buffer by typing @kbd{q} in it; this
quits the trace, but does not cancel @code{debug-on-entry}.

@findex cancel-debug-on-entry
To cancel the effect of @code{debug-on-entry}, call
@code{cancel-debug-on-entry} and the name of the function, like this:

@smallexample
M-x cancel-debug-on-entry RET triangle-bugged RET
@end smallexample

@noindent
(If you are reading this in Info, cancel @code{debug-on-entry} now.)


@node debug-on-quit, edebug, debug-on-entry, Debugging
@section @code{debug-on-quit} and @code{(debug)}

In addition to setting @code{debug-on-error} or calling @code{debug-on-entry},
there are two other ways to start @code{debug}.

@findex debug-on-quit
You can start @code{debug} whenever you type @kbd{C-g}
(@code{keyboard-quit}) by setting the variable @code{debug-on-quit} to
@code{t}.  This is useful for debugging infinite loops.

@need 1500
@cindex @code{(debug)} in code
Or, you can insert a line that says @code{(debug)} into your code
where you want the debugger to start, like this:

@smallexample
@group
(defun triangle-bugged (number)
  "Return sum of numbers 1 through NUMBER inclusive."
  (let ((total 0))
    (while (> number 0)
      (setq total (+ total number))
      (debug)                         ; @r{Start debugger.}
      (setq number (1= number)))      ; @r{Error here.}
    total))
@end group
@end smallexample

The @code{debug} function is described in detail in @ref{Debugger, ,
The Lisp Debugger, elisp, The GNU Emacs Lisp Reference Manual}.


@node edebug, Debugging Exercises, debug-on-quit, Debugging
@section The @code{edebug} Source Level Debugger
@cindex Source level debugger
@findex edebug

Edebug is a source level debugger.  Edebug normally displays the
source of the code you are debugging, with an arrow at the left that
shows which line you are currently executing.

You can walk through the execution of a function, line by line, or run
quickly until reaching a @dfn{breakpoint} where execution stops.

Edebug is described in @ref{edebug, , Edebug, elisp, The GNU Emacs
Lisp Reference Manual}.

@need 1250
Here is a bugged function definition for @code{triangle-recursively}.
@xref{Recursive triangle function, , Recursion in place of a counter},
for a review of it.

@smallexample
@group
(defun triangle-recursively-bugged (number)
  "Return sum of numbers 1 through NUMBER inclusive.
Uses recursion."
  (if (= number 1)
      1
    (+ number
       (triangle-recursively-bugged
        (1= number)))))               ; @r{Error here.}
@end group
@end smallexample

@noindent
Normally, you would install this definition by positioning your cursor
after the function's closing parenthesis and typing @kbd{C-x C-e}
(@code{eval-last-sexp}) or else by positioning your cursor within the
definition and typing @kbd{C-M-x} (@code{eval-defun}).  (By default,
the @code{eval-defun} command works only in Emacs Lisp mode or in Lisp
Interaction mode.)

@need 1500
However, to prepare this function definition for Edebug, you must
first @dfn{instrument} the code using a different command.  You can do
this by positioning your cursor within or just after the definition
and typing

@smallexample
M-x edebug-defun RET
@end smallexample

@noindent
This will cause Emacs to load Edebug automatically if it is not
already loaded, and properly instrument the function.

After instrumenting the function, place your cursor after the
following expression and type @kbd{C-x C-e} (@code{eval-last-sexp}):

@smallexample
(triangle-recursively-bugged 3)
@end smallexample

@noindent
You will be jumped back to the source for
@code{triangle-recursively-bugged} and the cursor positioned at the
beginning of the @code{if} line of the function.  Also, you will see
an arrowhead at the left hand side of that line.  The arrowhead marks
the line where the function is executing.  (In the following examples,
we show the arrowhead with @samp{=>}; in a windowing system, you may
see the arrowhead as a solid triangle in the window `fringe'.)

@smallexample
=>@point{}(if (= number 1)
@end smallexample

@noindent
@iftex
In the example, the location of point is displayed with a star,
@samp{@point{}} (in Info, it is displayed as @samp{-!-}).
@end iftex
@ifnottex
In the example, the location of point is displayed as @samp{@point{}}
(in a printed book, it is displayed with a five pointed star).
@end ifnottex

If you now press @key{SPC}, point will move to the next expression to
be executed; the line will look like this:

@smallexample
=>(if @point{}(= number 1)
@end smallexample

@noindent
As you continue to press @key{SPC}, point will move from expression to
expression.  At the same time, whenever an expression returns a value,
that value will be displayed in the echo area.  For example, after you
move point past @code{number}, you will see the following:

@smallexample
Result: 3 (#o3, #x3, ?\C-c)
@end smallexample

@noindent
This means the value of @code{number} is 3, which is octal three,
hexadecimal three, and @sc{ascii} `control-c' (the third letter of the
alphabet, in case you need to know this information).

You can continue moving through the code until you reach the line with
the error.  Before evaluation, that line looks like this:

@smallexample
=>        @point{}(1= number)))))               ; @r{Error here.}
@end smallexample

@need 1250
@noindent
When you press @key{SPC} once again, you will produce an error message
that says:

@smallexample
Symbol's function definition is void:@: 1=
@end smallexample

@noindent
This is the bug.

Press @kbd{q} to quit Edebug.

To remove instrumentation from a function definition, simply
re-evaluate it with a command that does not instrument it.
For example, you could place your cursor after the definition's
closing parenthesis and type @kbd{C-x C-e}.

Edebug does a great deal more than walk with you through a function.
You can set it so it races through on its own, stopping only at an
error or at specified stopping points; you can cause it to display the
changing values of various expressions; you can find out how many
times a function is called, and more.

Edebug is described in @ref{edebug, , Edebug, elisp, The GNU Emacs
Lisp Reference Manual}.


@need 1500
@node Debugging Exercises,  , edebug, Debugging
@section Debugging Exercises

@itemize @bullet
@item
Install the @code{count-words-region} function and then cause it to
enter the built-in debugger when you call it.  Run the command on a
region containing two words.  You will need to press @kbd{d} a
remarkable number of times.  On your system, is a `hook' called after
the command finishes?  (For information on hooks, see @ref{Command
Overview, , Command Loop Overview, elisp, The GNU Emacs Lisp Reference
Manual}.)

@item
Copy @code{count-words-region} into the @file{*scratch*} buffer,
instrument the function for Edebug, and walk through its execution.
The function does not need to have a bug, although you can introduce
one if you wish.  If the function lacks a bug, the walk-through
completes without problems.

@item
While running Edebug, type @kbd{?} to see a list of all the Edebug commands.
(The @code{global-edebug-prefix} is usually @kbd{C-x X}, i.e.@:
@kbd{@key{CTRL}-x} followed by an upper case @kbd{X}; use this prefix
for commands made outside of the Edebug debugging buffer.)

@item
In the Edebug debugging buffer, use the @kbd{p}
(@code{edebug-bounce-point}) command to see where in the region the
@code{count-words-region} is working.

@item
Move point to some spot further down the function and then type the
@kbd{h} (@code{edebug-goto-here}) command to jump to that location.

@item
Use the @kbd{t} (@code{edebug-trace-mode}) command to cause Edebug to
walk through the function on its own; use an upper case @kbd{T} for
@code{edebug-Trace-fast-mode}.

@item
Set a breakpoint, then run Edebug in Trace mode until it reaches the
stopping point.
@end itemize


@node Conclusion, the-the, Debugging, Top
@chapter Conclusion

We have now reached the end of this Introduction.  You have now
learned enough about programming in Emacs Lisp to set values, to write
simple @file{.emacs} files for yourself and your friends, and write
simple customizations and extensions to Emacs.

This is a place to stop.  Or, if you wish, you can now go onward, and
teach yourself.

You have learned some of the basic nuts and bolts of programming.  But
only some.  There are a great many more brackets and hinges that are
easy to use that we have not touched.

A path you can follow right now lies among the sources to GNU Emacs
and in
@ifnotinfo
@cite{The GNU Emacs Lisp Reference Manual}.
@end ifnotinfo
@ifinfo
@ref{Top, , The GNU Emacs Lisp Reference Manual, elisp, The GNU
Emacs Lisp Reference Manual}.
@end ifinfo

The Emacs Lisp sources are an adventure.  When you read the sources and
come across a function or expression that is unfamiliar, you need to
figure out or find out what it does.

Go to the Reference Manual.  It is a thorough, complete, and fairly
easy-to-read description of Emacs Lisp.  It is written not only for
experts, but for people who know what you know.  (The @cite{Reference
Manual} comes with the standard GNU Emacs distribution.  Like this
introduction, it comes as a Texinfo source file, so you can read it
on-line and as a typeset, printed book.)

Go to the other on-line help that is part of GNU Emacs: the on-line
documentation for all functions and variables, and @code{find-tag},
the program that takes you to sources.

Here is an example of how I explore the sources.  Because of its name,
@file{simple.el} is the file I looked at first, a long time ago.  As
it happens some of the functions in @file{simple.el} are complicated,
or at least look complicated at first sight.  The @code{open-line}
function, for example, looks complicated.

You may want to walk through this function slowly, as we did with the
@code{forward-sentence} function.  (@xref{forward-sentence, The
@code{forward-sentence} function}.)  Or you may want to skip that
function and look at another, such as @code{split-line}.  You don't
need to read all the functions.  According to
@code{count-words-in-defun}, the @code{split-line} function contains
102 words and symbols.

Even though it is short, @code{split-line} contains  expressions
we have not studied: @code{skip-chars-forward}, @code{indent-to},
@code{current-column} and @code{insert-and-inherit}.

Consider the @code{skip-chars-forward} function.  (It is part of the
function definition for @code{back-to-indentation}, which is shown in
@ref{Review, , Review}.)

In GNU Emacs, you can find out more about @code{skip-chars-forward} by
typing @kbd{C-h f} (@code{describe-function}) and the name of the
function.  This gives you the function documentation.

You may be able to guess what is done by a well named function such as
@code{indent-to}; or you can look it up, too.  Incidentally, the
@code{describe-function} function itself is in @file{help.el}; it is
one of those long, but decipherable functions.  You can look up
@code{describe-function} using the @kbd{C-h f} command!

In this instance, since the code is Lisp, the @file{*Help*} buffer
contains the name of the library containing the function's source.
You can put point over the name of the library and press the RET key,
which in this situation is bound to @code{help-follow}, and be taken
directly to the source, in the same way as @kbd{M-.}
(@code{find-tag}).

The definition for @code{describe-function} illustrates how to
customize the @code{interactive} expression without using the standard
character codes; and it shows how to create a temporary buffer.

(The @code{indent-to} function is written in C rather than Emacs Lisp;
it is a `built-in' function.  @code{help-follow} takes you to its
source as does @code{find-tag}, when properly set up.)

You can look at a function's source using @code{find-tag}, which is
bound to @kbd{M-.}  Finally, you can find out what the Reference
Manual has to say by visiting the manual in Info, and typing @kbd{i}
(@code{Info-index}) and the name of the function, or by looking up the
function in the index to a printed copy of the manual.

Similarly, you can find out what is meant by
@code{insert-and-inherit}.

Other interesting source files include @file{paragraphs.el},
@file{loaddefs.el}, and @file{loadup.el}.  The @file{paragraphs.el}
file includes short, easily understood functions as well as longer
ones.  The @file{loaddefs.el} file contains the many standard
autoloads and many keymaps.  I have never looked at it all; only at
parts.  @file{loadup.el} is the file that loads the standard parts of
Emacs; it tells you a great deal about how Emacs is built.
(@xref{Building Emacs, , Building Emacs, elisp, The GNU Emacs Lisp
Reference Manual}, for more about building.)

As I said, you have learned some nuts and bolts; however, and very
importantly, we have hardly touched major aspects of programming; I
have said nothing about how to sort information, except to use the
predefined @code{sort} function; I have said nothing about how to store
information, except to use variables and lists; I have said nothing
about how to write programs that write programs.  These are topics for
another, and different kind of book, a different kind of learning.

What you have done is learn enough for much practical work with GNU
Emacs.  What you have done is get started.  This is the end of a
beginning.

@c ================ Appendix ================

@node the-the, Kill Ring, Conclusion, Top
@appendix The @code{the-the} Function
@findex the-the
@cindex Duplicated words function
@cindex Words, duplicated

Sometimes when you you write text, you duplicate words---as with ``you
you'' near the beginning of this sentence.  I find that most
frequently, I duplicate ``the''; hence, I call the function for
detecting duplicated words, @code{the-the}.

@need 1250
As a first step, you could use the following regular expression to
search for duplicates:

@smallexample
\\(\\w+[ \t\n]+\\)\\1
@end smallexample

@noindent
This regexp matches one or more word-constituent characters followed
by one or more spaces, tabs, or newlines.  However, it does not detect
duplicated words on different lines, since the ending of the first
word, the end of the line, is different from the ending of the second
word, a space.  (For more information about regular expressions, see
@ref{Regexp Search, , Regular Expression Searches}, as well as
@ref{Regexps, , Syntax of Regular Expressions, emacs, The GNU Emacs
Manual}, and @ref{Regular Expressions, , Regular Expressions, elisp,
The GNU Emacs Lisp Reference Manual}.)

You might try searching just for duplicated word-constituent
characters but that does not work since the pattern detects doubles
such as the two occurrences of `th' in `with the'.

Another possible regexp searches for word-constituent characters
followed by non-word-constituent characters, reduplicated.  Here,
@w{@samp{\\w+}} matches one or more word-constituent characters and
@w{@samp{\\W*}} matches zero or more non-word-constituent characters.

@smallexample
\\(\\(\\w+\\)\\W*\\)\\1
@end smallexample

@noindent
Again, not useful.

Here is the pattern that I use.  It is not perfect, but good enough.
@w{@samp{\\b}} matches the empty string, provided it is at the beginning
or end of a word; @w{@samp{[^@@ \n\t]+}} matches one or more occurrences of
any characters that are @emph{not} an @@-sign, space, newline, or tab.

@smallexample
\\b\\([^@@ \n\t]+\\)[ \n\t]+\\1\\b
@end smallexample

One can write more complicated expressions, but I found that this
expression is good enough, so I use it.

Here is the @code{the-the} function, as I include it in my
@file{.emacs} file, along with a handy global key binding:

@smallexample
@group
(defun the-the ()
  "Search forward for for a duplicated word."
  (interactive)
  (message "Searching for for duplicated words ...")
  (push-mark)
@end group
@group
  ;; This regexp is not perfect
  ;; but is fairly good over all:
  (if (re-search-forward
       "\\b\\([^@@ \n\t]+\\)[ \n\t]+\\1\\b" nil 'move)
      (message "Found duplicated word.")
    (message "End of buffer")))
@end group

@group
;; Bind `the-the' to  C-c \
(global-set-key "\C-c\\" 'the-the)
@end group
@end smallexample

@sp 1
Here is test text:

@smallexample
@group
one two two three four five
five six seven
@end group
@end smallexample

You can substitute the other regular expressions shown above in the
function definition and try each of them on this list.


@node Kill Ring, Full Graph, the-the, Top
@appendix Handling the Kill Ring
@cindex Kill ring handling
@cindex Handling the kill ring
@cindex Ring, making a list like a

The kill ring is a list that is transformed into a ring by the
workings of the @code{current-kill} function.  The @code{yank} and
@code{yank-pop} commands use the @code{current-kill} function.

This appendix describes the @code{current-kill} function as well as
both the @code{yank} and the @code{yank-pop} commands, but first,
consider the workings of the kill ring.

@menu
* What the Kill Ring Does::
* current-kill::
* yank::                        Paste a copy of a clipped element.
* yank-pop::                    Insert element pointed to.
* ring file::
@end menu

@node What the Kill Ring Does, current-kill, Kill Ring, Kill Ring
@ifnottex
@unnumberedsec What the Kill Ring Does
@end ifnottex

@need 1250
The kill ring has a default maximum length of sixty items; this number
is too large for an explanation.  Instead, set it to four.  Please
evaluate the following:

@smallexample
@group
(setq old-kill-ring-max kill-ring-max)
(setq kill-ring-max 4)
@end group
@end smallexample

@noindent
Then, please copy each line of the following indented example into the
kill ring.  You may kill each line with @kbd{C-k} or mark it and copy
it with @kbd{M-w}.

@noindent
(In a read-only buffer, such as the @file{*info*} buffer, the kill
command, @kbd{C-k} (@code{kill-line}), will not remove the text,
merely copy it to the kill ring.  However, your machine may beep at
you.  Alternatively, for silence, you may copy the region of each line
with the @kbd{M-w} (@code{kill-ring-save}) command.  You must mark
each line for this command to succeed, but it does not matter at which
end you put point or mark.)

@need 1250
@noindent
Please invoke the calls in order, so that five elements attempt to
fill the kill ring:

@smallexample
@group
first some text
second piece of text
third line
fourth line of text
fifth bit of text
@end group
@end smallexample

@need 1250
@noindent
Then find the value of @code{kill-ring} by evaluating

@smallexample
kill-ring
@end smallexample

@need 800
@noindent
It is:

@smallexample
@group
("fifth bit of text" "fourth line of text"
"third line" "second piece of text")
@end group
@end smallexample

@noindent
The first element, @samp{first some text}, was dropped.

@need 1250
To return to the old value for the length of the kill ring, evaluate:

@smallexample
(setq kill-ring-max old-kill-ring-max)
@end smallexample


@node current-kill, yank, What the Kill Ring Does, Kill Ring
@comment  node-name,  next,  previous,  up
@appendixsec The @code{current-kill} Function
@findex current-kill

The @code{current-kill} function changes the element in the kill ring
to which @code{kill-ring-yank-pointer} points.  (Also, the
@code{kill-new} function sets @code{kill-ring-yank-pointer} to point
to the latest element of the kill ring.  The @code{kill-new}
function is used directly or indirectly by @code{kill-append},
@code{copy-region-as-kill}, @code{kill-ring-save}, @code{kill-line},
and @code{kill-region}.)

@menu
* Code for current-kill::
* Understanding current-kill::
@end menu

@node Code for current-kill, Understanding current-kill, current-kill, current-kill
@ifnottex
@unnumberedsubsec The code for @code{current-kill}
@end ifnottex


@need 1500
The @code{current-kill} function is used by @code{yank} and by
@code{yank-pop}.  Here is the code for @code{current-kill}:

@smallexample
@group
(defun current-kill (n &optional do-not-move)
  "Rotate the yanking point by N places, and then return that kill.
If N is zero, `interprogram-paste-function' is set, and calling it
returns a string, then that string is added to the front of the
kill ring and returned as the latest kill.
@end group
@group
If optional arg DO-NOT-MOVE is non-nil, then don't actually move the
yanking point; just return the Nth kill forward."
  (let ((interprogram-paste (and (= n 0)
                                 interprogram-paste-function
                                 (funcall interprogram-paste-function))))
@end group
@group
    (if interprogram-paste
        (progn
          ;; Disable the interprogram cut function when we add the new
          ;; text to the kill ring, so Emacs doesn't try to own the
          ;; selection, with identical text.
          (let ((interprogram-cut-function nil))
            (kill-new interprogram-paste))
          interprogram-paste)
@end group
@group
      (or kill-ring (error "Kill ring is empty"))
      (let ((ARGth-kill-element
             (nthcdr (mod (- n (length kill-ring-yank-pointer))
                          (length kill-ring))
                     kill-ring)))
        (or do-not-move
            (setq kill-ring-yank-pointer ARGth-kill-element))
        (car ARGth-kill-element)))))
@end group
@end smallexample

Remember also that the @code{kill-new} function sets
@code{kill-ring-yank-pointer} to the latest element of the kill
ring, which means that all the functions that call it set the value
indirectly: @code{kill-append}, @code{copy-region-as-kill},
@code{kill-ring-save}, @code{kill-line}, and @code{kill-region}.

@need 1500
Here is the line in @code{kill-new}, which is explained in
@ref{kill-new function, , The @code{kill-new} function}.

@smallexample
(setq kill-ring-yank-pointer kill-ring)
@end smallexample

@node Understanding current-kill,  , Code for current-kill, current-kill
@ifnottex
@unnumberedsubsec @code{current-kill} in Outline
@end ifnottex

The @code{current-kill} function looks complex, but as usual, it can
be understood by taking it apart piece by piece.  First look at it in
skeletal form:

@smallexample
@group
(defun current-kill (n &optional do-not-move)
  "Rotate the yanking point by N places, and then return that kill."
  (let @var{varlist}
    @var{body}@dots{})
@end group
@end smallexample

This function takes two arguments, one of which is optional.  It has a
documentation string.  It is @emph{not} interactive.

@menu
* Body of current-kill::
* Digression concerning error::  How to mislead humans, but not computers.
* Determining the Element::
@end menu

@node Body of current-kill, Digression concerning error, Understanding current-kill, Understanding current-kill
@ifnottex
@unnumberedsubsubsec The Body of @code{current-kill}
@end ifnottex

The body of the function definition is a @code{let} expression, which
itself has a body as well as a @var{varlist}.

The @code{let} expression declares a variable that will be only usable
within the bounds of this function.  This variable is called
@code{interprogram-paste} and is for copying to another program.  It
is not for copying within this instance of GNU Emacs.  Most window
systems provide a facility for interprogram pasting.  Sadly, that
facility usually provides only for the last element.  Most windowing
systems have not adopted a ring of many possibilities, even though
Emacs has provided it for decades.

The @code{if} expression has two parts, one if there exists
@code{interprogram-paste} and one if not.

@need 2000
Let us consider the `if not' or else-part of the @code{current-kill}
function.  (The then-part uses the @code{kill-new} function, which
we have already described.  @xref{kill-new function, , The
@code{kill-new} function}.)

@smallexample
@group
(or kill-ring (error "Kill ring is empty"))
(let ((ARGth-kill-element
       (nthcdr (mod (- n (length kill-ring-yank-pointer))
                    (length kill-ring))
               kill-ring)))
  (or do-not-move
      (setq kill-ring-yank-pointer ARGth-kill-element))
  (car ARGth-kill-element))
@end group
@end smallexample

@noindent
The code first checks whether the kill ring has content; otherwise it
signals an error.

@need 1000
Note that the @code{or} expression is very similar to testing length
with an @code{if}:

@findex zerop
@findex error
@smallexample
@group
(if (zerop (length kill-ring))          ; @r{if-part}
    (error "Kill ring is empty"))       ; @r{then-part}
  ;; No else-part
@end group
@end smallexample

@noindent
If there is not anything in the kill ring, its length must be zero and
an error message sent to the user: @samp{Kill ring is empty}.  The
@code{current-kill} function uses an @code{or} expression which is
simpler.  But an @code{if} expression reminds us what goes on.

This @code{if} expression uses the function @code{zerop} which returns
true if the value it is testing is zero.  When @code{zerop} tests
true, the then-part of the @code{if} is evaluated.  The then-part is a
list starting with the function @code{error}, which is a function that
is similar to the @code{message} function
(@pxref{message, , The @code{message} Function}) in that
it prints a one-line message in the echo area.  However, in addition
to printing a message, @code{error} also stops evaluation of the
function within which it is embedded.  This means that the rest of the
function will not be evaluated if the length of the kill ring is zero.

Then the @code{current-kill} function selects the element to return.
The selection depends on the number of places that @code{current-kill}
rotates and on where @code{kill-ring-yank-pointer} points.

Next, either the optional @code{do-not-move} argument is true or the
current value of @code{kill-ring-yank-pointer} is set to point to the
list.  Finally, another expression returns the first element of the
list even if the @code{do-not-move} argument is true.

@node Digression concerning error, Determining the Element, Body of current-kill, Understanding current-kill
@ifnottex
@unnumberedsubsubsec Digression about the word `error'
@end ifnottex

In my opinion, it is slightly misleading, at least to humans, to use
the term `error' as the name of the @code{error} function.  A better
term would be `cancel'.  Strictly speaking, of course, you cannot
point to, much less rotate a pointer to a list that has no length, so
from the point of view of the computer, the word `error' is correct.
But a human expects to attempt this sort of thing, if only to find out
whether the kill ring is full or empty.  This is an act of
exploration.

From the human point of view, the act of exploration and discovery is
not necessarily an error, and therefore should not be labelled as one,
even in the bowels of a computer.  As it is, the code in Emacs implies
that a human who is acting virtuously, by exploring his or her
environment, is making an error.  This is bad.  Even though the computer
takes the same steps as it does when there is an `error', a term such as
`cancel' would have a clearer connotation.

@node Determining the Element,  , Digression concerning error, Understanding current-kill
@ifnottex
@unnumberedsubsubsec Determining the Element
@end ifnottex

Among other actions, the else-part of the @code{if} expression sets
the value of @code{kill-ring-yank-pointer} to
@code{ARGth-kill-element} when the kill ring has something in it and
the value of @code{do-not-move} is @code{nil}.

@need 800
The code looks like this:

@smallexample
@group
(nthcdr (mod (- n (length kill-ring-yank-pointer))
             (length kill-ring))
        kill-ring)))
@end group
@end smallexample

This needs some examination.  Unless it is not supposed to move the
pointer, the @code{current-kill} function changes where
@code{kill-ring-yank-pointer} points.
That is what the
@w{@code{(setq kill-ring-yank-pointer ARGth-kill-element))}}
expression does.  Also, clearly, @code{ARGth-kill-element} is being
set to be equal to some @sc{cdr} of the kill ring, using the
@code{nthcdr} function that is described in an earlier section.
(@xref{copy-region-as-kill}.)  How does it do this?

As we have seen before (@pxref{nthcdr}), the @code{nthcdr} function
works by repeatedly taking the @sc{cdr} of a list---it takes the
@sc{cdr} of the @sc{cdr} of the @sc{cdr} @dots{}

@need 800
The two following expressions produce the same result:

@smallexample
@group
(setq kill-ring-yank-pointer (cdr kill-ring))

(setq kill-ring-yank-pointer (nthcdr 1 kill-ring))
@end group
@end smallexample

However, the @code{nthcdr} expression is more complicated.  It uses
the @code{mod} function to determine which @sc{cdr} to select.

(You will remember to look at inner functions first; indeed, we will
have to go inside the @code{mod}.)

The @code{mod} function returns the value of its first argument modulo
the second; that is to say, it returns the remainder after dividing
the first argument by the second.  The value returned has the same
sign as the second argument.

@need 800
Thus,

@smallexample
@group
(mod 12 4)
  @result{} 0  ;; @r{because there is no remainder}
(mod 13 4)
  @result{} 1
@end group
@end smallexample

@need 1250
In this case, the first argument is often smaller than the second.
That is fine.

@smallexample
@group
(mod 0 4)
  @result{} 0
(mod 1 4)
  @result{} 1
@end group
@end smallexample

We can guess what the @code{-} function does.  It is like @code{+} but
subtracts instead of adds; the @code{-} function subtracts its second
argument from its first.  Also, we already know what the @code{length}
function does (@pxref{length}).  It returns the length of a list.

And @code{n} is the name of the required argument to the
@code{current-kill} function.

@need 1250
So when the first argument to @code{nthcdr} is zero, the @code{nthcdr}
expression returns the whole list, as you can see by evaluating the
following:

@smallexample
@group
;; kill-ring-yank-pointer @r{and} kill-ring @r{have a length of four}
;; @r{and} (mod (- 0 4) 4) @result{} 0
(nthcdr (mod (- 0 4) 4)
        '("fourth line of text"
          "third line"
          "second piece of text"
          "first some text"))
@end group
@end smallexample

@need 1250
When the first argument to the @code{current-kill} function is one,
the @code{nthcdr} expression returns the list without its first
element.

@smallexample
@group
(nthcdr (mod (- 1 4) 4)
        '("fourth line of text"
          "third line"
          "second piece of text"
          "first some text"))
@end group
@end smallexample

@cindex @samp{global variable} defined
@cindex @samp{variable, global}, defined
Incidentally, both @code{kill-ring} and @code{kill-ring-yank-pointer}
are @dfn{global variables}.  That means that any expression in Emacs
Lisp can access them.  They are not like the local variables set by
@code{let} or like the symbols in an argument list.
Local variables can only be accessed
within the @code{let} that defines them or the function that specifies
them in an argument list (and within expressions called by them).

@ignore
@c texi2dvi fails when the name of the section is within ifnottex ...
(@xref{Prevent confusion, , @code{let} Prevents Confusion}, and
@ref{defun, , 특별한 형식 @code{defun}}.)
@end ignore

@node yank, yank-pop, current-kill, Kill Ring
@comment  node-name,  next,  previous,  up
@appendixsec @code{yank}
@findex yank

After learning about @code{current-kill}, the code for the
@code{yank} function is almost easy.

The @code{yank} function does not use the
@code{kill-ring-yank-pointer} variable directly.  It calls
@code{insert-for-yank} which calls @code{current-kill} which sets the
@code{kill-ring-yank-pointer} variable.

@need 1250
The code looks like this:

@c in GNU Emacs 22
@smallexample
@group
(defun yank (&optional arg)
  "Reinsert (\"paste\") the last stretch of killed text.
More precisely, reinsert the stretch of killed text most recently
killed OR yanked.  Put point at end, and set mark at beginning.
With just \\[universal-argument] as argument, same but put point at
beginning (and mark at end).  With argument N, reinsert the Nth most
recently killed stretch of killed text.

When this command inserts killed text into the buffer, it honors
`yank-excluded-properties' and `yank-handler' as described in the
doc string for `insert-for-yank-1', which see.

See also the command \\[yank-pop]."
@end group
@group
  (interactive "*P")
  (setq yank-window-start (window-start))
  ;; If we don't get all the way thru, make last-command indicate that
  ;; for the following command.
  (setq this-command t)
  (push-mark (point))
@end group
@group
  (insert-for-yank (current-kill (cond
                                  ((listp arg) 0)
                                  ((eq arg '-) -2)
                                  (t (1- arg)))))
  (if (consp arg)
      ;; This is like exchange-point-and-mark,
      ;;     but doesn't activate the mark.
      ;; It is cleaner to avoid activation, even though the command
      ;; loop would deactivate the mark because we inserted text.
      (goto-char (prog1 (mark t)
                   (set-marker (mark-marker) (point) (current-buffer)))))
@end group
@group
  ;; If we do get all the way thru, make this-command indicate that.
  (if (eq this-command t)
      (setq this-command 'yank))
  nil)
@end group
@end smallexample

The key expression is @code{insert-for-yank}, which inserts the string
returned by @code{current-kill}, but removes some text properties from
it.

However, before getting to that expression, the function sets the value
of @code{yank-window-start} to the position returned by the
@code{(window-start)} expression, the position at which the display
currently starts.  The @code{yank} function also sets
@code{this-command} and pushes the mark.

After it yanks the appropriate element, if the optional argument is a
@sc{cons} rather than a number or nothing, it puts point at beginning
of the yanked text and mark at its end.

(The @code{prog1} function is like @code{progn} but returns the value
of its first argument rather than the value of its last argument.  Its
first argument is forced to return the buffer's mark as an integer.
You can see the documentation for these functions by placing point
over them in this buffer and then typing @kbd{C-h f}
(@code{describe-function}) followed by a @kbd{RET}; the default is the
function.)

The last part of the function tells what to do when it succeeds.

@node yank-pop, ring file, yank, Kill Ring
@comment  node-name,  next,  previous,  up
@appendixsec @code{yank-pop}
@findex yank-pop

After understanding @code{yank} and @code{current-kill}, you know how
to approach the @code{yank-pop} function.  Leaving out the
documentation to save space, it looks like this:

@c GNU Emacs 22
@smallexample
@group
(defun yank-pop (&optional arg)
  "@dots{}"
  (interactive "*p")
  (if (not (eq last-command 'yank))
      (error "Previous command was not a yank"))
@end group
@group
  (setq this-command 'yank)
  (unless arg (setq arg 1))
  (let ((inhibit-read-only t)
        (before (< (point) (mark t))))
@end group
@group
    (if before
        (funcall (or yank-undo-function 'delete-region) (point) (mark t))
      (funcall (or yank-undo-function 'delete-region) (mark t) (point)))
    (setq yank-undo-function nil)
@end group
@group
    (set-marker (mark-marker) (point) (current-buffer))
    (insert-for-yank (current-kill arg))
    ;; Set the window start back where it was in the yank command,
    ;; if possible.
    (set-window-start (selected-window) yank-window-start t)
@end group
@group
    (if before
        ;; This is like exchange-point-and-mark,
        ;;     but doesn't activate the mark.
        ;; It is cleaner to avoid activation, even though the command
        ;; loop would deactivate the mark because we inserted text.
        (goto-char (prog1 (mark t)
                     (set-marker (mark-marker)
                                 (point)
                                 (current-buffer))))))
  nil)
@end group
@end smallexample

The function is interactive with a small @samp{p} so the prefix
argument is processed and passed to the function.  The command can
only be used after a previous yank; otherwise an error message is
sent.  This check uses the variable @code{last-command} which is set
by @code{yank} and is discussed elsewhere.
(@xref{copy-region-as-kill}.)

The @code{let} clause sets the variable @code{before} to true or false
depending whether point is before or after mark and then the region
between point and mark is deleted.  This is the region that was just
inserted by the previous yank and it is this text that will be
replaced.

@code{funcall} calls its first argument as a function, passing
remaining arguments to it.  The first argument is whatever the
@code{or} expression returns.  The two remaining arguments are the
positions of point and mark set by the preceding @code{yank} command.

There is more, but that is the hardest part.

@node ring file,  , yank-pop, Kill Ring
@comment  node-name,  next,  previous,  up
@appendixsec The @file{ring.el} File
@cindex @file{ring.el} file

Interestingly, GNU Emacs posses a file called @file{ring.el} that
provides many of the features we just discussed.  But functions such
as @code{kill-ring-yank-pointer} do not use this library, possibly
because they were written earlier.


@node Full Graph, Free Software and Free Manuals, Kill Ring, Top
@appendix A Graph with Labelled Axes

Printed axes help you understand a graph.  They convey scale.  In an
earlier chapter (@pxref{Readying a Graph, ,  Readying a Graph}), we
wrote the code to print the body of a graph.  Here we write the code
for printing and labelling vertical and horizontal axes, along with the
body itself.

@menu
* Labelled Example::
* print-graph Varlist::         @code{let} expression in @code{print-graph}.
* print-Y-axis::                Print a label for the vertical axis.
* print-X-axis::                Print a horizontal label.
* Print Whole Graph::           The function to print a complete graph.
@end menu

@node Labelled Example, print-graph Varlist, Full Graph, Full Graph
@ifnottex
@unnumberedsec Labelled Example Graph
@end ifnottex

Since insertions fill a buffer to the right and below point, the new
graph printing function should first print the Y or vertical axis,
then the body of the graph, and finally the X or horizontal axis.
This sequence lays out for us the contents of the function:

@enumerate
@item
Set up code.

@item
Print Y axis.

@item
Print body of graph.

@item
Print X axis.
@end enumerate

@need 800
Here is an example of how a finished graph should look:

@smallexample
@group
    10 -
                  *
                  *  *
                  *  **
                  *  ***
     5 -      *   *******
            * *** *******
            *************
          ***************
     1 - ****************
         |   |    |    |
         1   5   10   15
@end group
@end smallexample

@noindent
In this graph, both the vertical and the horizontal axes are labelled
with numbers.  However, in some graphs, the horizontal axis is time
and would be better labelled with months, like this:

@smallexample
@group
     5 -      *
            * ** *
            *******
          ********** **
     1 - **************
         |    ^      |
         Jan  June   Jan
@end group
@end smallexample

Indeed, with a little thought, we can easily come up with a variety of
vertical and horizontal labelling schemes.  Our task could become
complicated.  But complications breed confusion.  Rather than permit
this, it is better choose a simple labelling scheme for our first
effort, and to modify or replace it later.

@need 1200
These considerations suggest the following outline for the
@code{print-graph} function:

@smallexample
@group
(defun print-graph (numbers-list)
  "@var{documentation}@dots{}"
  (let ((height  @dots{}
        @dots{}))
@end group
@group
    (print-Y-axis height @dots{} )
    (graph-body-print numbers-list)
    (print-X-axis @dots{} )))
@end group
@end smallexample

We can work on each part of the @code{print-graph} function definition
in turn.

@node print-graph Varlist, print-Y-axis, Labelled Example, Full Graph
@comment  node-name,  next,  previous,  up
@appendixsec The @code{print-graph} Varlist
@cindex @code{print-graph} varlist

In writing the @code{print-graph} function, the first task is to write
the varlist in the @code{let} expression.  (We will leave aside for the
moment any thoughts about making the function interactive or about the
contents of its documentation string.)

The varlist should set several values.  Clearly, the top of the label
for the vertical axis must be at least the height of the graph, which
means that we must obtain this information here.  Note that the
@code{print-graph-body} function also requires this information.  There
is no reason to calculate the height of the graph in two different
places, so we should change @code{print-graph-body} from the way we
defined it earlier to take advantage of the calculation.

Similarly, both the function for printing the X axis labels and the
@code{print-graph-body} function need to learn the value of the width of
each symbol.  We can perform the calculation here and change the
definition for @code{print-graph-body} from the way we defined it in the
previous chapter.

The length of the label for the horizontal axis must be at least as long
as the graph.  However, this information is used only in the function
that prints the horizontal axis, so it does not need to be calculated here.

These thoughts lead us directly to the following form for the varlist
in the @code{let} for @code{print-graph}:

@smallexample
@group
(let ((height (apply 'max numbers-list)) ; @r{First version.}
      (symbol-width (length graph-blank)))
@end group
@end smallexample

@noindent
As we shall see, this expression is not quite right.

@need 2000
@node print-Y-axis, print-X-axis, print-graph Varlist, Full Graph
@comment  node-name,  next,  previous,  up
@appendixsec The @code{print-Y-axis} Function
@cindex Axis, print vertical
@cindex Y axis printing
@cindex Vertical axis printing
@cindex Print vertical axis

The job of the @code{print-Y-axis} function is to print a label for
the vertical axis that looks like this:

@smallexample
@group
    10 -




     5 -



     1 -
@end group
@end smallexample

@noindent
The function should be passed the height of the graph, and then should
construct and insert the appropriate numbers and marks.

@menu
* print-Y-axis in Detail::
* Height of label::             What height for the Y axis?
* Compute a Remainder::         How to compute the remainder of a division.
* Y Axis Element::              Construct a line for the Y axis.
* Y-axis-column::               Generate a list of Y axis labels.
* print-Y-axis Penultimate::    A not quite final version.
@end menu

@node print-Y-axis in Detail, Height of label, print-Y-axis, print-Y-axis
@ifnottex
@unnumberedsubsec The @code{print-Y-axis} Function in Detail
@end ifnottex

It is easy enough to see in the figure what the Y axis label should
look like; but to say in words, and then to write a function
definition to do the job is another matter.  It is not quite true to
say that we want a number and a tic every five lines: there are only
three lines between the @samp{1} and the @samp{5} (lines 2, 3, and 4),
but four lines between the @samp{5} and the @samp{10} (lines 6, 7, 8,
and 9).  It is better to say that we want a number and a tic mark on
the base line (number 1) and then that we want a number and a tic on
the fifth line from the bottom and on every line that is a multiple of
five.

@node Height of label, Compute a Remainder, print-Y-axis in Detail, print-Y-axis
@ifnottex
@unnumberedsubsec What height should the label be?
@end ifnottex

The next issue is what height the label should be?  Suppose the maximum
height of tallest column of the graph is seven.  Should the highest
label on the Y axis be @samp{5 -}, and should the graph stick up above
the label?  Or should the highest label be @samp{7 -}, and mark the peak
of the graph?  Or should the highest label be @code{10 -}, which is a
multiple of five, and be higher than the topmost value of the graph?

The latter form is preferred.  Most graphs are drawn within rectangles
whose sides are an integral number of steps long---5, 10, 15, and so
on for a step distance of five.  But as soon as we decide to use a
step height for the vertical axis, we discover that the simple
expression in the varlist for computing the height is wrong.  The
expression is @code{(apply 'max numbers-list)}.  This returns the
precise height, not the maximum height plus whatever is necessary to
round up to the nearest multiple of five.  A more complex expression
is required.

As usual in cases like this, a complex problem becomes simpler if it is
divided into several smaller problems.

First, consider the case when the highest value of the graph is an
integral multiple of five---when it is 5, 10, 15, or some higher
multiple of five.  We can use this value as the Y axis height.

A fairly simply way to determine whether a number is a multiple of
five is to divide it by five and see if the division results in a
remainder.  If there is no remainder, the number is a multiple of
five.  Thus, seven divided by five has a remainder of two, and seven
is not an integral multiple of five.  Put in slightly different
language, more reminiscent of the classroom, five goes into seven
once, with a remainder of two.  However, five goes into ten twice,
with no remainder: ten is an integral multiple of five.

@node Compute a Remainder, Y Axis Element, Height of label, print-Y-axis
@appendixsubsec Side Trip: Compute a Remainder

@findex % @r{(remainder function)}
@cindex Remainder function, @code{%}
In Lisp, the function for computing a remainder is @code{%}.  The
function returns the remainder of its first argument divided by its
second argument.  As it happens, @code{%} is a function in Emacs Lisp
that you cannot discover using @code{apropos}: you find nothing if you
type @kbd{M-x apropos @key{RET} remainder @key{RET}}.  The only way to
learn of the existence of @code{%} is to read about it in a book such
as this or in the Emacs Lisp sources.

You can try the @code{%} function by evaluating the following two
expressions:

@smallexample
@group
(% 7 5)

(% 10 5)
@end group
@end smallexample

@noindent
The first expression returns 2 and the second expression returns 0.

To test whether the returned value is zero or some other number, we
can use the @code{zerop} function.  This function returns @code{t} if
its argument, which must be a number, is zero.

@smallexample
@group
(zerop (% 7 5))
     @result{} nil

(zerop (% 10 5))
     @result{} t
@end group
@end smallexample

Thus, the following expression will return @code{t} if the height
of the graph is evenly divisible by five:

@smallexample
(zerop (% height 5))
@end smallexample

@noindent
(The value of @code{height}, of course, can be found from @code{(apply
'max numbers-list)}.)

On the other hand, if the value of @code{height} is not a multiple of
five, we want to reset the value to the next higher multiple of five.
This is straightforward arithmetic using functions with which we are
already familiar.  First, we divide the value of @code{height} by five
to determine how many times five goes into the number.  Thus, five
goes into twelve twice.  If we add one to this quotient and multiply by
five, we will obtain the value of the next multiple of five that is
larger than the height.  Five goes into twelve twice.  Add one to two,
and multiply by five; the result is fifteen, which is the next multiple
of five that is higher than twelve.  The Lisp expression for this is:

@smallexample
(* (1+ (/ height 5)) 5)
@end smallexample

@noindent
For example, if you evaluate the following, the result is 15:

@smallexample
(* (1+ (/ 12 5)) 5)
@end smallexample

All through this discussion, we have been using `five' as the value
for spacing labels on the Y axis; but we may want to use some other
value.  For generality, we should replace `five' with a variable to
which we can assign a value.  The best name I can think of for this
variable is @code{Y-axis-label-spacing}.

@need 1250
Using this term, and an @code{if} expression, we produce the
following:

@smallexample
@group
(if (zerop (% height Y-axis-label-spacing))
    height
  ;; @r{else}
  (* (1+ (/ height Y-axis-label-spacing))
     Y-axis-label-spacing))
@end group
@end smallexample

@noindent
This expression returns the value of @code{height} itself if the height
is an even multiple of the value of the @code{Y-axis-label-spacing} or
else it computes and returns a value of @code{height} that is equal to
the next higher multiple of the value of the @code{Y-axis-label-spacing}.

We can now include this expression in the @code{let} expression of the
@code{print-graph} function (after first setting the value of
@code{Y-axis-label-spacing}):
@vindex Y-axis-label-spacing

@smallexample
@group
(defvar Y-axis-label-spacing 5
  "Number of lines from one Y axis label to next.")
@end group

@group
@dots{}
(let* ((height (apply 'max numbers-list))
       (height-of-top-line
        (if (zerop (% height Y-axis-label-spacing))
            height
@end group
@group
          ;; @r{else}
          (* (1+ (/ height Y-axis-label-spacing))
             Y-axis-label-spacing)))
       (symbol-width (length graph-blank))))
@dots{}
@end group
@end smallexample

@noindent
(Note use of the  @code{let*} function: the initial value of height is
computed once by the @code{(apply 'max numbers-list)} expression and
then the resulting value of  @code{height} is used to compute its
final value.  @xref{fwd-para let, , The @code{let*} expression}, for
more about @code{let*}.)

@node Y Axis Element, Y-axis-column, Compute a Remainder, print-Y-axis
@appendixsubsec Construct a Y Axis Element

When we print the vertical axis, we want to insert strings such as
@w{@samp{5 -}} and @w{@samp{10 - }} every five lines.
Moreover, we want the numbers and dashes to line up, so shorter
numbers must be padded with leading spaces.  If some of the strings
use two digit numbers, the strings with single digit numbers must
include a leading blank space before the number.

@findex number-to-string
To figure out the length of the number, the @code{length} function is
used.  But the @code{length} function works only with a string, not with
a number.  So the number has to be converted from being a number to
being a string.  This is done with the @code{number-to-string} function.
For example,

@smallexample
@group
(length (number-to-string 35))
     @result{} 2

(length (number-to-string 100))
     @result{} 3
@end group
@end smallexample

@noindent
(@code{number-to-string} is also called @code{int-to-string}; you will
see this alternative name in various sources.)

In addition, in each label, each number is followed by a string such
as @w{@samp{ - }}, which we will call the @code{Y-axis-tic} marker.
This variable is defined with @code{defvar}:

@vindex Y-axis-tic
@smallexample
@group
(defvar Y-axis-tic " - "
   "String that follows number in a Y axis label.")
@end group
@end smallexample

The length of the Y label is the sum of the length of the Y axis tic
mark and the length of the number of the top of the graph.

@smallexample
(length (concat (number-to-string height) Y-axis-tic)))
@end smallexample

This value will be calculated by the @code{print-graph} function in
its varlist as @code{full-Y-label-width} and passed on.  (Note that we
did not think to include this in the varlist when we first proposed it.)

To make a complete vertical axis label, a tic mark is concatenated
with a number; and the two together may be preceded by one or more
spaces depending on how long the number is.  The label consists of
three parts: the (optional) leading spaces, the number, and the tic
mark.  The function is passed the value of the number for the specific
row, and the value of the width of the top line, which is calculated
(just once) by @code{print-graph}.

@smallexample
@group
(defun Y-axis-element (number full-Y-label-width)
  "Construct a NUMBERed label element.
A numbered element looks like this `  5 - ',
and is padded as needed so all line up with
the element for the largest number."
@end group
@group
  (let* ((leading-spaces
         (- full-Y-label-width
            (length
             (concat (number-to-string number)
                     Y-axis-tic)))))
@end group
@group
    (concat
     (make-string leading-spaces ? )
     (number-to-string number)
     Y-axis-tic)))
@end group
@end smallexample

The @code{Y-axis-element} function concatenates together the leading
spaces, if any; the number, as a string; and the tic mark.

To figure out how many leading spaces the label will need, the
function subtracts the actual length of the label---the length of the
number plus the length of the tic mark---from the desired label width.

@findex make-string
Blank spaces are inserted using the @code{make-string} function.  This
function takes two arguments: the first tells it how long the string
will be and the second is a symbol for the character to insert, in a
special format.  The format is a question mark followed by a blank
space, like this, @samp{? }.  @xref{Character Type, , Character Type,
elisp, The GNU Emacs Lisp Reference Manual}, for a description of the
syntax for characters.  (Of course, you might want to replace the
blank space by some other character @dots{}  You know what to do.)

The @code{number-to-string} function is used in the concatenation
expression, to convert the number to a string that is concatenated
with the leading spaces and the tic mark.

@node Y-axis-column, print-Y-axis Penultimate, Y Axis Element, print-Y-axis
@appendixsubsec Create a Y Axis Column

The preceding functions provide all the tools needed to construct a
function that generates a list of numbered and blank strings to insert
as the label for the vertical axis:

@findex Y-axis-column
@smallexample
@group
(defun Y-axis-column (height width-of-label)
  "Construct list of Y axis labels and blank strings.
For HEIGHT of line above base and WIDTH-OF-LABEL."
  (let (Y-axis)
@group
@end group
    (while (> height 1)
      (if (zerop (% height Y-axis-label-spacing))
          ;; @r{Insert label.}
          (setq Y-axis
                (cons
                 (Y-axis-element height width-of-label)
                 Y-axis))
@group
@end group
        ;; @r{Else, insert blanks.}
        (setq Y-axis
              (cons
               (make-string width-of-label ? )
               Y-axis)))
      (setq height (1- height)))
    ;; @r{Insert base line.}
    (setq Y-axis
          (cons (Y-axis-element 1 width-of-label) Y-axis))
    (nreverse Y-axis)))
@end group
@end smallexample

In this function, we start with the value of @code{height} and
repetitively subtract one from its value.  After each subtraction, we
test to see whether the value is an integral multiple of the
@code{Y-axis-label-spacing}.  If it is, we construct a numbered label
using the @code{Y-axis-element} function; if not, we construct a
blank label using the @code{make-string} function.  The base line
consists of the number one followed by a tic mark.

@need 2000
@node print-Y-axis Penultimate,  , Y-axis-column, print-Y-axis
@appendixsubsec The Not Quite Final Version of @code{print-Y-axis}

The list constructed by the @code{Y-axis-column} function is passed to
the @code{print-Y-axis} function, which inserts the list as a column.

@findex print-Y-axis
@smallexample
@group
(defun print-Y-axis (height full-Y-label-width)
  "Insert Y axis using HEIGHT and FULL-Y-LABEL-WIDTH.
Height must be the maximum height of the graph.
Full width is the width of the highest label element."
;; Value of height and full-Y-label-width
;; are passed by `print-graph'.
@end group
@group
  (let ((start (point)))
    (insert-rectangle
     (Y-axis-column height full-Y-label-width))
    ;; @r{Place point ready for inserting graph.}
    (goto-char start)
    ;; @r{Move point forward by value of} full-Y-label-width
    (forward-char full-Y-label-width)))
@end group
@end smallexample

The @code{print-Y-axis} uses the @code{insert-rectangle} function to
insert the Y axis labels created by the @code{Y-axis-column} function.
In addition, it places point at the correct position for printing the body of
the graph.

You can test @code{print-Y-axis}:

@enumerate
@item
Install

@smallexample
@group
Y-axis-label-spacing
Y-axis-tic
Y-axis-element
Y-axis-column
print-Y-axis
@end group
@end smallexample

@item
Copy the following expression:

@smallexample
(print-Y-axis 12 5)
@end smallexample

@item
Switch to the @file{*scratch*} buffer and place the cursor where you
want the axis labels to start.

@item
Type @kbd{M-:} (@code{eval-expression}).

@item
Yank the @code{graph-body-print} expression into the minibuffer
with @kbd{C-y} (@code{yank)}.

@item
Press @key{RET} to evaluate the expression.
@end enumerate

Emacs will print labels vertically, the top one being @w{@samp{10 -@w{
}}}.  (The @code{print-graph} function will pass the value of
@code{height-of-top-line}, which in this case will end up as 15,
thereby getting rid of what might appear as a bug.)

@need 2000
@node print-X-axis, Print Whole Graph, print-Y-axis, Full Graph
@appendixsec The @code{print-X-axis} Function
@cindex Axis, print horizontal
@cindex X axis printing
@cindex Print horizontal axis
@cindex Horizontal axis printing

X axis labels are much like Y axis labels, except that the ticks are on a
line above the numbers.  Labels should look like this:

@smallexample
@group
    |   |    |    |
    1   5   10   15
@end group
@end smallexample

The first tic is under the first column of the graph and is preceded by
several blank spaces.  These spaces provide room in rows above for the Y
axis labels.  The second, third, fourth, and subsequent ticks are all
spaced equally, according to the value of @code{X-axis-label-spacing}.

The second row of the X axis consists of numbers, preceded by several
blank spaces and also separated according to the value of the variable
@code{X-axis-label-spacing}.

The value of the variable @code{X-axis-label-spacing} should itself be
measured in units of @code{symbol-width}, since you may want to change
the width of the symbols that you are using to print the body of the
graph without changing the ways the graph is labelled.

@menu
* Similarities differences::    Much like @code{print-Y-axis}, but not exactly.
* X Axis Tic Marks::            Create tic marks for the horizontal axis.
@end menu

@node Similarities differences, X Axis Tic Marks, print-X-axis, print-X-axis
@ifnottex
@unnumberedsubsec Similarities and differences
@end ifnottex

The @code{print-X-axis} function is constructed in more or less the
same fashion as the @code{print-Y-axis} function except that it has
two lines: the line of tic marks and the numbers.  We will write a
separate function to print each line and then combine them within the
@code{print-X-axis} function.

This is a three step process:

@enumerate
@item
Write a function to print the X axis tic marks, @code{print-X-axis-tic-line}.

@item
Write a function to print the X numbers, @code{print-X-axis-numbered-line}.

@item
Write a function to print both lines, the @code{print-X-axis} function,
using @code{print-X-axis-tic-line} and
@code{print-X-axis-numbered-line}.
@end enumerate

@node X Axis Tic Marks,  , Similarities differences, print-X-axis
@appendixsubsec X Axis Tic Marks

The first function should print the X axis tic marks.  We must specify
the tic marks themselves and their spacing:

@smallexample
@group
(defvar X-axis-label-spacing
  (if (boundp 'graph-blank)
      (* 5 (length graph-blank)) 5)
  "Number of units from one X axis label to next.")
@end group
@end smallexample

@noindent
(Note that the value of @code{graph-blank} is set by another
@code{defvar}.  The @code{boundp} predicate checks whether it has
already been set; @code{boundp} returns @code{nil} if it has not.  If
@code{graph-blank} were unbound and we did not use this conditional
construction, in a recent GNU Emacs, we would enter the debugger and
see an error message saying @samp{@w{Debugger entered--Lisp error:}
@w{(void-variable graph-blank)}}.)

@need 1200
Here is the @code{defvar} for @code{X-axis-tic-symbol}:

@smallexample
@group
(defvar X-axis-tic-symbol "|"
  "String to insert to point to a column in X axis.")
@end group
@end smallexample

@need 1250
The goal is to make a line that looks like this:

@smallexample
       |   |    |    |
@end smallexample

The first tic is indented so that it is under the first column, which is
indented to provide space for the Y axis labels.

A tic element consists of the blank spaces that stretch from one tic to
the next plus a tic symbol.  The number of blanks is determined by the
width of the tic symbol and the @code{X-axis-label-spacing}.

@need 1250
The code looks like this:

@smallexample
@group
;;; X-axis-tic-element
@dots{}
(concat
 (make-string
  ;; @r{Make a string of blanks.}
  (-  (* symbol-width X-axis-label-spacing)
      (length X-axis-tic-symbol))
  ? )
 ;; @r{Concatenate blanks with tic symbol.}
 X-axis-tic-symbol)
@dots{}
@end group
@end smallexample

Next, we determine how many blanks are needed to indent the first tic
mark to the first column of the graph.  This uses the value of
@code{full-Y-label-width} passed it by the @code{print-graph} function.

@need 1250
The code to make @code{X-axis-leading-spaces}
looks like this:

@smallexample
@group
;; X-axis-leading-spaces
@dots{}
(make-string full-Y-label-width ? )
@dots{}
@end group
@end smallexample

We also need to determine the length of the horizontal axis, which is
the length of the numbers list, and the number of ticks in the horizontal
axis:

@smallexample
@group
;; X-length
@dots{}
(length numbers-list)
@end group

@group
;; tic-width
@dots{}
(* symbol-width X-axis-label-spacing)
@end group

@group
;; number-of-X-ticks
(if (zerop (% (X-length tic-width)))
    (/ (X-length tic-width))
  (1+ (/ (X-length tic-width))))
@end group
@end smallexample

@need 1250
All this leads us directly to the function for printing the X axis tic line:

@findex print-X-axis-tic-line
@smallexample
@group
(defun print-X-axis-tic-line
  (number-of-X-tics X-axis-leading-spaces X-axis-tic-element)
  "Print ticks for X axis."
    (insert X-axis-leading-spaces)
    (insert X-axis-tic-symbol)  ; @r{Under first column.}
@end group
@group
    ;; @r{Insert second tic in the right spot.}
    (insert (concat
             (make-string
              (-  (* symbol-width X-axis-label-spacing)
                  ;; @r{Insert white space up to second tic symbol.}
                  (* 2 (length X-axis-tic-symbol)))
              ? )
             X-axis-tic-symbol))
@end group
@group
    ;; @r{Insert remaining ticks.}
    (while (> number-of-X-tics 1)
      (insert X-axis-tic-element)
      (setq number-of-X-tics (1- number-of-X-tics))))
@end group
@end smallexample

The line of numbers is equally straightforward:

@need 1250
First, we create a numbered element with blank spaces before each number:

@findex X-axis-element
@smallexample
@group
(defun X-axis-element (number)
  "Construct a numbered X axis element."
  (let ((leading-spaces
         (-  (* symbol-width X-axis-label-spacing)
             (length (number-to-string number)))))
    (concat (make-string leading-spaces ? )
            (number-to-string number))))
@end group
@end smallexample

Next, we create the function to print the numbered line, starting with
the number ``1'' under the first column:

@findex print-X-axis-numbered-line
@smallexample
@group
(defun print-X-axis-numbered-line
  (number-of-X-tics X-axis-leading-spaces)
  "Print line of X-axis numbers"
  (let ((number X-axis-label-spacing))
    (insert X-axis-leading-spaces)
    (insert "1")
@end group
@group
    (insert (concat
             (make-string
              ;; @r{Insert white space up to next number.}
              (-  (* symbol-width X-axis-label-spacing) 2)
              ? )
             (number-to-string number)))
@end group
@group
    ;; @r{Insert remaining numbers.}
    (setq number (+ number X-axis-label-spacing))
    (while (> number-of-X-tics 1)
      (insert (X-axis-element number))
      (setq number (+ number X-axis-label-spacing))
      (setq number-of-X-tics (1- number-of-X-tics)))))
@end group
@end smallexample

Finally, we need to write the @code{print-X-axis} that uses
@code{print-X-axis-tic-line} and
@code{print-X-axis-numbered-line}.

The function must determine the local values of the variables used by both
@code{print-X-axis-tic-line} and @code{print-X-axis-numbered-line}, and
then it must call them.  Also, it must print the carriage return that
separates the two lines.

The function consists of a varlist that specifies five local variables,
and calls to each of the two line printing functions:

@findex print-X-axis
@smallexample
@group
(defun print-X-axis (numbers-list)
  "Print X axis labels to length of NUMBERS-LIST."
  (let* ((leading-spaces
          (make-string full-Y-label-width ? ))
@end group
@group
       ;; symbol-width @r{is provided by} graph-body-print
       (tic-width (* symbol-width X-axis-label-spacing))
       (X-length (length numbers-list))
@end group
@group
       (X-tic
        (concat
         (make-string
@end group
@group
          ;; @r{Make a string of blanks.}
          (-  (* symbol-width X-axis-label-spacing)
              (length X-axis-tic-symbol))
          ? )
@end group
@group
         ;; @r{Concatenate blanks with tic symbol.}
         X-axis-tic-symbol))
@end group
@group
       (tic-number
        (if (zerop (% X-length tic-width))
            (/ X-length tic-width)
          (1+ (/ X-length tic-width)))))
@end group
@group
    (print-X-axis-tic-line tic-number leading-spaces X-tic)
    (insert "\n")
    (print-X-axis-numbered-line tic-number leading-spaces)))
@end group
@end smallexample

@need 1250
You can test @code{print-X-axis}:

@enumerate
@item
Install @code{X-axis-tic-symbol}, @code{X-axis-label-spacing},
@code{print-X-axis-tic-line}, as well as @code{X-axis-element},
@code{print-X-axis-numbered-line}, and @code{print-X-axis}.

@item
Copy the following expression:

@smallexample
@group
(progn
 (let ((full-Y-label-width 5)
       (symbol-width 1))
   (print-X-axis
    '(1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16))))
@end group
@end smallexample

@item
Switch to the @file{*scratch*} buffer and place the cursor where you
want the axis labels to start.

@item
Type @kbd{M-:} (@code{eval-expression}).

@item
Yank the test expression into the minibuffer
with @kbd{C-y} (@code{yank)}.

@item
Press @key{RET} to evaluate the expression.
@end enumerate

@need 1250
Emacs will print the horizontal axis like this:
@sp 1

@smallexample
@group
     |   |    |    |    |
     1   5   10   15   20
@end group
@end smallexample

@node Print Whole Graph,  , print-X-axis, Full Graph
@appendixsec Printing the Whole Graph
@cindex Printing the whole graph
@cindex Whole graph printing
@cindex Graph, printing all

Now we are nearly ready to print the whole graph.

The function to print the graph with the proper labels follows the
outline we created earlier (@pxref{Full Graph, , A Graph with Labelled
Axes}), but with additions.

@need 1250
Here is the outline:

@smallexample
@group
(defun print-graph (numbers-list)
  "@var{documentation}@dots{}"
  (let ((height  @dots{}
        @dots{}))
@end group
@group
    (print-Y-axis height @dots{} )
    (graph-body-print numbers-list)
    (print-X-axis @dots{} )))
@end group
@end smallexample

@menu
* The final version::           A few changes.
* Test print-graph::            Run a short test.
* Graphing words in defuns::    Executing the final code.
* lambda::                      How to write an anonymous function.
* mapcar::                      Apply a function to elements of a list.
* Another Bug::                 Yet another bug @dots{} most insidious.
* Final printed graph::         The graph itself!
@end menu

@node The final version, Test print-graph, Print Whole Graph, Print Whole Graph
@ifnottex
@unnumberedsubsec Changes for the Final Version
@end ifnottex

The final version is different from what we planned in two ways:
first, it contains additional values calculated once in the varlist;
second, it carries an option to specify the labels' increment per row.
This latter feature turns out to be essential; otherwise, a graph may
have more rows than fit on a display or on a sheet of paper.

@need 1500
This new feature requires a change to the @code{Y-axis-column}
function, to add @code{vertical-step} to it.  The function looks like
this:

@findex Y-axis-column @r{Final version.}
@smallexample
@group
;;; @r{Final version.}
(defun Y-axis-column
  (height width-of-label &optional vertical-step)
  "Construct list of labels for Y axis.
HEIGHT is maximum height of graph.
WIDTH-OF-LABEL is maximum width of label.
VERTICAL-STEP, an option, is a positive integer
that specifies how much a Y axis label increments
for each line.  For example, a step of 5 means
that each line is five units of the graph."
@end group
@group
  (let (Y-axis
        (number-per-line (or vertical-step 1)))
    (while (> height 1)
      (if (zerop (% height Y-axis-label-spacing))
@end group
@group
          ;; @r{Insert label.}
          (setq Y-axis
                (cons
                 (Y-axis-element
                  (* height number-per-line)
                  width-of-label)
                 Y-axis))
@end group
@group
        ;; @r{Else, insert blanks.}
        (setq Y-axis
              (cons
               (make-string width-of-label ? )
               Y-axis)))
      (setq height (1- height)))
@end group
@group
    ;; @r{Insert base line.}
    (setq Y-axis (cons (Y-axis-element
                        (or vertical-step 1)
                        width-of-label)
                       Y-axis))
    (nreverse Y-axis)))
@end group
@end smallexample

The values for the maximum height of graph and the width of a symbol
are computed by @code{print-graph} in its @code{let} expression; so
@code{graph-body-print} must be changed to accept them.

@findex graph-body-print @r{Final version.}
@smallexample
@group
;;; @r{Final version.}
(defun graph-body-print (numbers-list height symbol-width)
  "Print a bar graph of the NUMBERS-LIST.
The numbers-list consists of the Y-axis values.
HEIGHT is maximum height of graph.
SYMBOL-WIDTH is number of each column."
@end group
@group
  (let (from-position)
    (while numbers-list
      (setq from-position (point))
      (insert-rectangle
       (column-of-graph height (car numbers-list)))
      (goto-char from-position)
      (forward-char symbol-width)
@end group
@group
      ;; @r{Draw graph column by column.}
      (sit-for 0)
      (setq numbers-list (cdr numbers-list)))
    ;; @r{Place point for X axis labels.}
    (forward-line height)
    (insert "\n")))
@end group
@end smallexample

@need 1250
Finally, the code for the @code{print-graph} function:

@findex print-graph @r{Final version.}
@smallexample
@group
;;; @r{Final version.}
(defun print-graph
  (numbers-list &optional vertical-step)
  "Print labelled bar graph of the NUMBERS-LIST.
The numbers-list consists of the Y-axis values.
@end group

@group
Optionally, VERTICAL-STEP, a positive integer,
specifies how much a Y axis label increments for
each line.  For example, a step of 5 means that
each row is five units."
@end group
@group
  (let* ((symbol-width (length graph-blank))
         ;; @code{height} @r{is both the largest number}
         ;; @r{and the number with the most digits.}
         (height (apply 'max numbers-list))
@end group
@group
         (height-of-top-line
          (if (zerop (% height Y-axis-label-spacing))
              height
            ;; @r{else}
            (* (1+ (/ height Y-axis-label-spacing))
               Y-axis-label-spacing)))
@end group
@group
         (vertical-step (or vertical-step 1))
         (full-Y-label-width
          (length
@end group
@group
           (concat
            (number-to-string
             (* height-of-top-line vertical-step))
            Y-axis-tic))))
@end group

@group
    (print-Y-axis
     height-of-top-line full-Y-label-width vertical-step)
@end group
@group
    (graph-body-print
     numbers-list height-of-top-line symbol-width)
    (print-X-axis numbers-list)))
@end group
@end smallexample

@node Test print-graph, Graphing words in defuns, The final version, Print Whole Graph
@appendixsubsec Testing @code{print-graph}

@need 1250
We can test the @code{print-graph} function with a short list of numbers:

@enumerate
@item
Install the final versions of @code{Y-axis-column},
@code{graph-body-print}, and @code{print-graph} (in addition to the
rest of the code.)

@item
Copy the following expression:

@smallexample
(print-graph '(3 2 5 6 7 5 3 4 6 4 3 2 1))
@end smallexample

@item
Switch to the @file{*scratch*} buffer and place the cursor where you
want the axis labels to start.

@item
Type @kbd{M-:} (@code{eval-expression}).

@item
Yank the test expression into the minibuffer
with @kbd{C-y} (@code{yank)}.

@item
Press @key{RET} to evaluate the expression.
@end enumerate

@need 1250
Emacs will print a graph that looks like this:

@smallexample
@group
10 -


         *
        **   *
 5 -   ****  *
       **** ***
     * *********
     ************
 1 - *************

     |   |    |    |
     1   5   10   15
@end group
@end smallexample

@need 1200
On the other hand, if you pass @code{print-graph} a
@code{vertical-step} value of 2, by evaluating this expression:

@smallexample
(print-graph '(3 2 5 6 7 5 3 4 6 4 3 2 1) 2)
@end smallexample

@need 1250
@noindent
The graph looks like this:

@smallexample
@group
20 -


         *
        **   *
10 -   ****  *
       **** ***
     * *********
     ************
 2 - *************

     |   |    |    |
     1   5   10   15
@end group
@end smallexample

@noindent
(A question: is the `2' on the bottom of the vertical axis a bug or a
feature?  If you think it is a bug, and should be a `1' instead, (or
even a `0'), you can modify the sources.)

@node Graphing words in defuns, lambda, Test print-graph, Print Whole Graph
@appendixsubsec Graphing Numbers of Words and Symbols

Now for the graph for which all this code was written: a graph that
shows how many function definitions contain fewer than 10 words and
symbols, how many contain between 10 and 19 words and symbols, how
many contain between 20 and 29 words and symbols, and so on.

This is a multi-step process.  First make sure you have loaded all the
requisite code.

@need 1500
It is a good idea to reset the value of @code{top-of-ranges} in case
you have set it to some different value.  You can evaluate the
following:

@smallexample
@group
(setq top-of-ranges
 '(10  20  30  40  50
   60  70  80  90 100
  110 120 130 140 150
  160 170 180 190 200
  210 220 230 240 250
  260 270 280 290 300)
@end group
@end smallexample

@noindent
Next create a list of the number of words and symbols in each range.

@need 1500
@noindent
Evaluate the following:

@smallexample
@group
(setq list-for-graph
       (defuns-per-range
         (sort
          (recursive-lengths-list-many-files
           (directory-files "/usr/local/emacs/lisp"
                            t ".+el$"))
          '<)
         top-of-ranges))
@end group
@end smallexample

@noindent
On my old machine, this took about an hour.  It looked though 303 Lisp
files in my copy of Emacs version 19.23.  After all that computing,
the @code{list-for-graph} had this value:

@smallexample
@group
(537 1027 955 785 594 483 349 292 224 199 166 120 116 99
90 80 67 48 52 45 41 33 28 26 25 20 12 28 11 13 220)
@end group
@end smallexample

@noindent
This means that my copy of Emacs had 537 function definitions with
fewer than 10 words or symbols in them, 1,027 function definitions
with 10 to 19 words or symbols in them, 955 function definitions with
20 to 29 words or symbols in them, and so on.

Clearly, just by looking at this list we can see that most function
definitions contain ten to thirty words and symbols.

Now for printing.  We do @emph{not} want to print a graph that is
1,030 lines high @dots{}  Instead, we should print a graph that is
fewer than twenty-five lines high.  A graph that height can be
displayed on almost any monitor, and easily printed on a sheet of paper.

This means that each value in @code{list-for-graph} must be reduced to
one-fiftieth its present value.

Here is a short function to do just that, using two functions we have
not yet seen, @code{mapcar} and @code{lambda}.

@smallexample
@group
(defun one-fiftieth (full-range)
  "Return list, each number one-fiftieth of previous."
 (mapcar '(lambda (arg) (/ arg 50)) full-range))
@end group
@end smallexample

@node lambda, mapcar, Graphing words in defuns, Print Whole Graph
@appendixsubsec A @code{lambda} Expression: Useful Anonymity
@cindex Anonymous function
@findex lambda

@code{lambda} is the symbol for an anonymous function, a function
without a name.  Every time you use an anonymous function, you need to
include its whole body.

@need 1250
@noindent
Thus,

@smallexample
(lambda (arg) (/ arg 50))
@end smallexample

@noindent
is a function definition that says `return the value resulting from
dividing whatever is passed to me as @code{arg} by 50'.

@need 1200
Earlier, for example, we had a function @code{multiply-by-seven}; it
multiplied its argument by 7.  This function is similar, except it
divides its argument by 50; and, it has no name.  The anonymous
equivalent of @code{multiply-by-seven} is:

@smallexample
(lambda (number) (* 7 number))
@end smallexample

@noindent
(@xref{defun, ,  특별한 형식 @code{defun}}.)

@need 1250
@noindent
If we want to multiply 3 by 7, we can write:

@c !!! Clear print-postscript-figures if the computer formatting this
@c     document is too small and cannot handle all the diagrams and figures.
@c clear print-postscript-figures
@c set print-postscript-figures
@c lambda example diagram #1
@ifnottex
@smallexample
@group
(multiply-by-seven 3)
 \_______________/ ^
         |         |
      function  argument
@end group
@end smallexample
@end ifnottex
@ifset print-postscript-figures
@sp 1
@tex
@center @image{lambda-1}
%%%% old method of including an image
% \input /usr/local/lib/tex/inputs/psfig.tex
% \centerline{\psfig{figure=/usr/local/lib/emacs/man/lambda-1.eps}}
% \catcode`\@=0 %
@end tex
@sp 1
@end ifset
@ifclear print-postscript-figures
@iftex
@smallexample
@group
(multiply-by-seven 3)
 \_______________/ ^
         |         |
      function  argument
@end group
@end smallexample
@end iftex
@end ifclear

@noindent
This expression returns 21.

@need 1250
@noindent
Similarly, we can write:

@c lambda example diagram #2
@ifnottex
@smallexample
@group
((lambda (number) (* 7 number)) 3)
 \____________________________/ ^
               |                |
      anonymous function     argument
@end group
@end smallexample
@end ifnottex
@ifset print-postscript-figures
@sp 1
@tex
@center @image{lambda-2}
%%%% old method of including an image
% \input /usr/local/lib/tex/inputs/psfig.tex
% \centerline{\psfig{figure=/usr/local/lib/emacs/man/lambda-2.eps}}
% \catcode`\@=0 %
@end tex
@sp 1
@end ifset
@ifclear print-postscript-figures
@iftex
@smallexample
@group
((lambda (number) (* 7 number)) 3)
 \____________________________/ ^
               |                |
      anonymous function     argument
@end group
@end smallexample
@end iftex
@end ifclear

@need 1250
@noindent
If we want to divide 100 by 50, we can write:

@c lambda example diagram #3
@ifnottex
@smallexample
@group
((lambda (arg) (/ arg 50)) 100)
 \______________________/  \_/
             |              |
    anonymous function   argument
@end group
@end smallexample
@end ifnottex
@ifset print-postscript-figures
@sp 1
@tex
@center @image{lambda-3}
%%%% old method of including an image
% \input /usr/local/lib/tex/inputs/psfig.tex
% \centerline{\psfig{figure=/usr/local/lib/emacs/man/lambda-3.eps}}
% \catcode`\@=0 %
@end tex
@sp 1
@end ifset
@ifclear print-postscript-figures
@iftex
@smallexample
@group
((lambda (arg) (/ arg 50)) 100)
 \______________________/  \_/
             |              |
    anonymous function   argument
@end group
@end smallexample
@end iftex
@end ifclear

@noindent
This expression returns 2.  The 100 is passed to the function, which
divides that number by 50.

@xref{Lambda Expressions, , Lambda Expressions, elisp, The GNU Emacs
Lisp Reference Manual}, for more about @code{lambda}.  Lisp and lambda
expressions derive from the Lambda Calculus.

@node mapcar, Another Bug, lambda, Print Whole Graph
@appendixsubsec The @code{mapcar} Function
@findex mapcar

@code{mapcar} is a function that calls its first argument with each
element of its second argument, in turn.  The second argument must be
a sequence.

The @samp{map} part of the name comes from the mathematical phrase,
`mapping over a domain', meaning to apply a function to each of the
elements in a domain.  The mathematical phrase is based on the
metaphor of a surveyor walking, one step at a time, over an area he is
mapping.  And @samp{car}, of course, comes from the Lisp notion of the
first of a list.

@need 1250
@noindent
For example,

@smallexample
@group
(mapcar '1+ '(2 4 6))
     @result{} (3 5 7)
@end group
@end smallexample

@noindent
The function @code{1+} which adds one to its argument, is executed on
@emph{each} element of the list, and a new list is returned.

Contrast this with @code{apply}, which applies its first argument to
all the remaining.
(@xref{Readying a Graph, , Readying a Graph}, for a explanation of
@code{apply}.)

@need 1250
In the definition of @code{one-fiftieth}, the first argument is the
anonymous function:

@smallexample
(lambda (arg) (/ arg 50))
@end smallexample

@noindent
and the second argument is @code{full-range}, which will be bound to
@code{list-for-graph}.

@need 1250
The whole expression looks like this:

@smallexample
(mapcar '(lambda (arg) (/ arg 50)) full-range))
@end smallexample

@xref{Mapping Functions, , Mapping Functions, elisp, The GNU Emacs
Lisp Reference Manual}, for more about @code{mapcar}.

Using the @code{one-fiftieth} function, we can generate a list in
which each element is one-fiftieth the size of the corresponding
element in @code{list-for-graph}.

@smallexample
@group
(setq fiftieth-list-for-graph
      (one-fiftieth list-for-graph))
@end group
@end smallexample

@need 1250
The resulting list looks like this:

@smallexample
@group
(10 20 19 15 11 9 6 5 4 3 3 2 2
1 1 1 1 0 1 0 0 0 0 0 0 0 0 0 0 0 4)
@end group
@end smallexample

@noindent
This, we are almost ready to print!  (We also notice the loss of
information: many of the higher ranges are 0, meaning that fewer than
50 defuns had that many words or symbols---but not necessarily meaning
that none had that many words or symbols.)

@node Another Bug, Final printed graph, mapcar, Print Whole Graph
@appendixsubsec Another Bug @dots{} Most Insidious
@cindex Bug, most insidious type
@cindex Insidious type of bug

I said `almost ready to print'!  Of course, there is a bug in the
@code{print-graph} function @dots{}  It has a @code{vertical-step}
option, but not a @code{horizontal-step} option.  The
@code{top-of-range} scale goes from 10 to 300 by tens.  But the
@code{print-graph} function will print only by ones.

This is a classic example of what some consider the most insidious
type of bug, the bug of omission.  This is not the kind of bug you can
find by studying the code, for it is not in the code; it is an omitted
feature.  Your best actions are to try your program early and often;
and try to arrange, as much as you can, to write code that is easy to
understand and easy to change.  Try to be aware, whenever you can,
that whatever you have written, @emph{will} be rewritten, if not soon,
eventually.  A hard maxim to follow.

It is the @code{print-X-axis-numbered-line} function that needs the
work; and then the @code{print-X-axis} and the @code{print-graph}
functions need to be adapted.  Not much needs to be done; there is one
nicety: the numbers ought to line up under the tic marks.  This takes
a little thought.

@need 1250
Here is the corrected @code{print-X-axis-numbered-line}:

@smallexample
@group
(defun print-X-axis-numbered-line
  (number-of-X-tics X-axis-leading-spaces
   &optional horizontal-step)
  "Print line of X-axis numbers"
  (let ((number X-axis-label-spacing)
        (horizontal-step (or horizontal-step 1)))
@end group
@group
    (insert X-axis-leading-spaces)
    ;; @r{Delete extra leading spaces.}
    (delete-char
     (- (1-
         (length (number-to-string horizontal-step)))))
    (insert (concat
             (make-string
@end group
@group
              ;; @r{Insert white space.}
              (-  (* symbol-width
                     X-axis-label-spacing)
                  (1-
                   (length
                    (number-to-string horizontal-step)))
                  2)
              ? )
             (number-to-string
              (* number horizontal-step))))
@end group
@group
    ;; @r{Insert remaining numbers.}
    (setq number (+ number X-axis-label-spacing))
    (while (> number-of-X-tics 1)
      (insert (X-axis-element
               (* number horizontal-step)))
      (setq number (+ number X-axis-label-spacing))
      (setq number-of-X-tics (1- number-of-X-tics)))))
@end group
@end smallexample

@need 1500
If you are reading this in Info, you can see the new versions of
@code{print-X-axis} @code{print-graph} and evaluate them.  If you are
reading this in a printed book, you can see the changed lines here
(the full text is too much to print).

@iftex
@smallexample
@group
(defun print-X-axis (numbers-list horizontal-step)
  @dots{}
    (print-X-axis-numbered-line
     tic-number leading-spaces horizontal-step))
@end group
@end smallexample

@smallexample
@group
(defun print-graph
  (numbers-list
   &optional vertical-step horizontal-step)
  @dots{}
    (print-X-axis numbers-list horizontal-step))
@end group
@end smallexample
@end iftex

@ifnottex
@smallexample
@group
(defun print-X-axis (numbers-list horizontal-step)
  "Print X axis labels to length of NUMBERS-LIST.
Optionally, HORIZONTAL-STEP, a positive integer,
specifies how much an X  axis label increments for
each column."
@end group
@group
;; Value of symbol-width and full-Y-label-width
;; are passed by `print-graph'.
  (let* ((leading-spaces
          (make-string full-Y-label-width ? ))
       ;; symbol-width @r{is provided by} graph-body-print
       (tic-width (* symbol-width X-axis-label-spacing))
       (X-length (length numbers-list))
@end group
@group
       (X-tic
        (concat
         (make-string
          ;; @r{Make a string of blanks.}
          (-  (* symbol-width X-axis-label-spacing)
              (length X-axis-tic-symbol))
          ? )
@end group
@group
         ;; @r{Concatenate blanks with tic symbol.}
         X-axis-tic-symbol))
       (tic-number
        (if (zerop (% X-length tic-width))
            (/ X-length tic-width)
          (1+ (/ X-length tic-width)))))
@end group

@group
    (print-X-axis-tic-line
     tic-number leading-spaces X-tic)
    (insert "\n")
    (print-X-axis-numbered-line
     tic-number leading-spaces horizontal-step)))
@end group
@end smallexample

@smallexample
@group
(defun print-graph
  (numbers-list &optional vertical-step horizontal-step)
  "Print labelled bar graph of the NUMBERS-LIST.
The numbers-list consists of the Y-axis values.
@end group

@group
Optionally, VERTICAL-STEP, a positive integer,
specifies how much a Y axis label increments for
each line.  For example, a step of 5 means that
each row is five units.
@end group

@group
Optionally, HORIZONTAL-STEP, a positive integer,
specifies how much an X  axis label increments for
each column."
  (let* ((symbol-width (length graph-blank))
         ;; @code{height} @r{is both the largest number}
         ;; @r{and the number with the most digits.}
         (height (apply 'max numbers-list))
@end group
@group
         (height-of-top-line
          (if (zerop (% height Y-axis-label-spacing))
              height
            ;; @r{else}
            (* (1+ (/ height Y-axis-label-spacing))
               Y-axis-label-spacing)))
@end group
@group
         (vertical-step (or vertical-step 1))
         (full-Y-label-width
          (length
           (concat
            (number-to-string
             (* height-of-top-line vertical-step))
            Y-axis-tic))))
@end group
@group
    (print-Y-axis
     height-of-top-line full-Y-label-width vertical-step)
    (graph-body-print
        numbers-list height-of-top-line symbol-width)
    (print-X-axis numbers-list horizontal-step)))
@end group
@end smallexample
@end ifnottex

@c qqq
@ignore
Graphing Definitions Re-listed

@need 1250
Here are all the graphing definitions in their final form:

@smallexample
@group
(defvar top-of-ranges
 '(10  20  30  40  50
   60  70  80  90 100
  110 120 130 140 150
  160 170 180 190 200
  210 220 230 240 250)
 "List specifying ranges for `defuns-per-range'.")
@end group

@group
(defvar graph-symbol "*"
  "String used as symbol in graph, usually an asterisk.")
@end group

@group
(defvar graph-blank " "
  "String used as blank in graph, usually a blank space.
graph-blank must be the same number of columns wide
as graph-symbol.")
@end group

@group
(defvar Y-axis-tic " - "
   "String that follows number in a Y axis label.")
@end group

@group
(defvar Y-axis-label-spacing 5
  "Number of lines from one Y axis label to next.")
@end group

@group
(defvar X-axis-tic-symbol "|"
  "String to insert to point to a column in X axis.")
@end group

@group
(defvar X-axis-label-spacing
  (if (boundp 'graph-blank)
      (* 5 (length graph-blank)) 5)
  "Number of units from one X axis label to next.")
@end group
@end smallexample

@smallexample
@group
(defun count-words-in-defun ()
  "Return the number of words and symbols in a defun."
  (beginning-of-defun)
  (let ((count 0)
        (end (save-excursion (end-of-defun) (point))))
@end group

@group
    (while
        (and (< (point) end)
             (re-search-forward
              "\\(\\w\\|\\s_\\)+[^ \t\n]*[ \t\n]*"
              end t))
      (setq count (1+ count)))
    count))
@end group
@end smallexample

@smallexample
@group
(defun lengths-list-file (filename)
  "Return list of definitions' lengths within FILE.
The returned list is a list of numbers.
Each number is the number of words or
symbols in one function definition."
@end group

@group
  (message "Working on `%s' ... " filename)
  (save-excursion
    (let ((buffer (find-file-noselect filename))
          (lengths-list))
      (set-buffer buffer)
      (setq buffer-read-only t)
      (widen)
      (goto-char (point-min))
@end group

@group
      (while (re-search-forward "^(defun" nil t)
        (setq lengths-list
              (cons (count-words-in-defun) lengths-list)))
      (kill-buffer buffer)
      lengths-list)))
@end group
@end smallexample

@smallexample
@group
(defun lengths-list-many-files (list-of-files)
  "Return list of lengths of defuns in LIST-OF-FILES."
  (let (lengths-list)
;;; @r{true-or-false-test}
    (while list-of-files
      (setq lengths-list
            (append
             lengths-list
@end group
@group
;;; @r{Generate a lengths' list.}
             (lengths-list-file
              (expand-file-name (car list-of-files)))))
;;; @r{Make files' list shorter.}
      (setq list-of-files (cdr list-of-files)))
;;; @r{Return final value of lengths' list.}
    lengths-list))
@end group
@end smallexample

@smallexample
@group
(defun defuns-per-range (sorted-lengths top-of-ranges)
  "SORTED-LENGTHS defuns in each TOP-OF-RANGES range."
  (let ((top-of-range (car top-of-ranges))
        (number-within-range 0)
        defuns-per-range-list)
@end group

@group
    ;; @r{Outer loop.}
    (while top-of-ranges

      ;; @r{Inner loop.}
      (while (and
              ;; @r{Need number for numeric test.}
              (car sorted-lengths)
              (< (car sorted-lengths) top-of-range))

        ;; @r{Count number of definitions within current range.}
        (setq number-within-range (1+ number-within-range))
        (setq sorted-lengths (cdr sorted-lengths)))
@end group

@group
      ;; @r{Exit inner loop but remain within outer loop.}

      (setq defuns-per-range-list
            (cons number-within-range defuns-per-range-list))
      (setq number-within-range 0)      ; @r{Reset count to zero.}

      ;; @r{Move to next range.}
      (setq top-of-ranges (cdr top-of-ranges))
      ;; @r{Specify next top of range value.}
      (setq top-of-range (car top-of-ranges)))
@end group

@group
    ;; @r{Exit outer loop and count the number of defuns larger than}
    ;; @r{  the largest top-of-range value.}
    (setq defuns-per-range-list
          (cons
           (length sorted-lengths)
           defuns-per-range-list))

    ;; @r{Return a list of the number of definitions within each range,}
    ;; @r{  smallest to largest.}
    (nreverse defuns-per-range-list)))
@end group
@end smallexample

@smallexample
@group
(defun column-of-graph (max-graph-height actual-height)
  "Return list of MAX-GRAPH-HEIGHT strings;
ACTUAL-HEIGHT are graph-symbols.
The graph-symbols are contiguous entries at the end
of the list.
The list will be inserted as one column of a graph.
The strings are either graph-blank or graph-symbol."
@end group

@group
  (let ((insert-list nil)
        (number-of-top-blanks
         (- max-graph-height actual-height)))

    ;; @r{Fill in @code{graph-symbols}.}
    (while (> actual-height 0)
      (setq insert-list (cons graph-symbol insert-list))
      (setq actual-height (1- actual-height)))
@end group

@group
    ;; @r{Fill in @code{graph-blanks}.}
    (while (> number-of-top-blanks 0)
      (setq insert-list (cons graph-blank insert-list))
      (setq number-of-top-blanks
            (1- number-of-top-blanks)))

    ;; @r{Return whole list.}
    insert-list))
@end group
@end smallexample

@smallexample
@group
(defun Y-axis-element (number full-Y-label-width)
  "Construct a NUMBERed label element.
A numbered element looks like this `  5 - ',
and is padded as needed so all line up with
the element for the largest number."
@end group
@group
  (let* ((leading-spaces
         (- full-Y-label-width
            (length
             (concat (number-to-string number)
                     Y-axis-tic)))))
@end group
@group
    (concat
     (make-string leading-spaces ? )
     (number-to-string number)
     Y-axis-tic)))
@end group
@end smallexample

@smallexample
@group
(defun print-Y-axis
  (height full-Y-label-width &optional vertical-step)
  "Insert Y axis by HEIGHT and FULL-Y-LABEL-WIDTH.
Height must be the  maximum height of the graph.
Full width is the width of the highest label element.
Optionally, print according to VERTICAL-STEP."
@end group
@group
;; Value of height and full-Y-label-width
;; are passed by `print-graph'.
  (let ((start (point)))
    (insert-rectangle
     (Y-axis-column height full-Y-label-width vertical-step))
@end group
@group
    ;; @r{Place point ready for inserting graph.}
    (goto-char start)
    ;; @r{Move point forward by value of} full-Y-label-width
    (forward-char full-Y-label-width)))
@end group
@end smallexample

@smallexample
@group
(defun print-X-axis-tic-line
  (number-of-X-tics X-axis-leading-spaces X-axis-tic-element)
  "Print ticks for X axis."
    (insert X-axis-leading-spaces)
    (insert X-axis-tic-symbol)  ; @r{Under first column.}
@end group
@group
    ;; @r{Insert second tic in the right spot.}
    (insert (concat
             (make-string
              (-  (* symbol-width X-axis-label-spacing)
                  ;; @r{Insert white space up to second tic symbol.}
                  (* 2 (length X-axis-tic-symbol)))
              ? )
             X-axis-tic-symbol))
@end group
@group
    ;; @r{Insert remaining ticks.}
    (while (> number-of-X-tics 1)
      (insert X-axis-tic-element)
      (setq number-of-X-tics (1- number-of-X-tics))))
@end group
@end smallexample

@smallexample
@group
(defun X-axis-element (number)
  "Construct a numbered X axis element."
  (let ((leading-spaces
         (-  (* symbol-width X-axis-label-spacing)
             (length (number-to-string number)))))
    (concat (make-string leading-spaces ? )
            (number-to-string number))))
@end group
@end smallexample

@smallexample
@group
(defun graph-body-print (numbers-list height symbol-width)
  "Print a bar graph of the NUMBERS-LIST.
The numbers-list consists of the Y-axis values.
HEIGHT is maximum height of graph.
SYMBOL-WIDTH is number of each column."
@end group
@group
  (let (from-position)
    (while numbers-list
      (setq from-position (point))
      (insert-rectangle
       (column-of-graph height (car numbers-list)))
      (goto-char from-position)
      (forward-char symbol-width)
@end group
@group
      ;; @r{Draw graph column by column.}
      (sit-for 0)
      (setq numbers-list (cdr numbers-list)))
    ;; @r{Place point for X axis labels.}
    (forward-line height)
    (insert "\n")))
@end group
@end smallexample

@smallexample
@group
(defun Y-axis-column
  (height width-of-label &optional vertical-step)
  "Construct list of labels for Y axis.
HEIGHT is maximum height of graph.
WIDTH-OF-LABEL is maximum width of label.
@end group
@group
VERTICAL-STEP, an option, is a positive integer
that specifies how much a Y axis label increments
for each line.  For example, a step of 5 means
that each line is five units of the graph."
  (let (Y-axis
        (number-per-line (or vertical-step 1)))
@end group
@group
    (while (> height 1)
      (if (zerop (% height Y-axis-label-spacing))
          ;; @r{Insert label.}
          (setq Y-axis
                (cons
                 (Y-axis-element
                  (* height number-per-line)
                  width-of-label)
                 Y-axis))
@end group
@group
        ;; @r{Else, insert blanks.}
        (setq Y-axis
              (cons
               (make-string width-of-label ? )
               Y-axis)))
      (setq height (1- height)))
@end group
@group
    ;; @r{Insert base line.}
    (setq Y-axis (cons (Y-axis-element
                        (or vertical-step 1)
                        width-of-label)
                       Y-axis))
    (nreverse Y-axis)))
@end group
@end smallexample

@smallexample
@group
(defun print-X-axis-numbered-line
  (number-of-X-tics X-axis-leading-spaces
   &optional horizontal-step)
  "Print line of X-axis numbers"
  (let ((number X-axis-label-spacing)
        (horizontal-step (or horizontal-step 1)))
@end group
@group
    (insert X-axis-leading-spaces)
    ;; line up number
    (delete-char (- (1- (length (number-to-string horizontal-step)))))
    (insert (concat
             (make-string
              ;; @r{Insert white space up to next number.}
              (-  (* symbol-width X-axis-label-spacing)
                  (1- (length (number-to-string horizontal-step)))
                  2)
              ? )
             (number-to-string (* number horizontal-step))))
@end group
@group
    ;; @r{Insert remaining numbers.}
    (setq number (+ number X-axis-label-spacing))
    (while (> number-of-X-tics 1)
      (insert (X-axis-element (* number horizontal-step)))
      (setq number (+ number X-axis-label-spacing))
      (setq number-of-X-tics (1- number-of-X-tics)))))
@end group
@end smallexample

@smallexample
@group
(defun print-X-axis (numbers-list horizontal-step)
  "Print X axis labels to length of NUMBERS-LIST.
Optionally, HORIZONTAL-STEP, a positive integer,
specifies how much an X  axis label increments for
each column."
@end group
@group
;; Value of symbol-width and full-Y-label-width
;; are passed by `print-graph'.
  (let* ((leading-spaces
          (make-string full-Y-label-width ? ))
       ;; symbol-width @r{is provided by} graph-body-print
       (tic-width (* symbol-width X-axis-label-spacing))
       (X-length (length numbers-list))
@end group
@group
       (X-tic
        (concat
         (make-string
          ;; @r{Make a string of blanks.}
          (-  (* symbol-width X-axis-label-spacing)
              (length X-axis-tic-symbol))
          ? )
@end group
@group
         ;; @r{Concatenate blanks with tic symbol.}
         X-axis-tic-symbol))
       (tic-number
        (if (zerop (% X-length tic-width))
            (/ X-length tic-width)
          (1+ (/ X-length tic-width)))))
@end group

@group
    (print-X-axis-tic-line
     tic-number leading-spaces X-tic)
    (insert "\n")
    (print-X-axis-numbered-line
     tic-number leading-spaces horizontal-step)))
@end group
@end smallexample

@smallexample
@group
(defun one-fiftieth (full-range)
  "Return list, each number of which is 1/50th previous."
 (mapcar '(lambda (arg) (/ arg 50)) full-range))
@end group
@end smallexample

@smallexample
@group
(defun print-graph
  (numbers-list &optional vertical-step horizontal-step)
  "Print labelled bar graph of the NUMBERS-LIST.
The numbers-list consists of the Y-axis values.
@end group

@group
Optionally, VERTICAL-STEP, a positive integer,
specifies how much a Y axis label increments for
each line.  For example, a step of 5 means that
each row is five units.
@end group

@group
Optionally, HORIZONTAL-STEP, a positive integer,
specifies how much an X  axis label increments for
each column."
  (let* ((symbol-width (length graph-blank))
         ;; @code{height} @r{is both the largest number}
         ;; @r{and the number with the most digits.}
         (height (apply 'max numbers-list))
@end group
@group
         (height-of-top-line
          (if (zerop (% height Y-axis-label-spacing))
              height
            ;; @r{else}
            (* (1+ (/ height Y-axis-label-spacing))
               Y-axis-label-spacing)))
@end group
@group
         (vertical-step (or vertical-step 1))
         (full-Y-label-width
          (length
           (concat
            (number-to-string
             (* height-of-top-line vertical-step))
            Y-axis-tic))))
@end group
@group

    (print-Y-axis
     height-of-top-line full-Y-label-width vertical-step)
    (graph-body-print
        numbers-list height-of-top-line symbol-width)
    (print-X-axis numbers-list horizontal-step)))
@end group
@end smallexample
@c qqq
@end ignore

@page
@node Final printed graph,  , Another Bug, Print Whole Graph
@appendixsubsec The Printed Graph

When made and installed, you can call the @code{print-graph} command
like this:
@sp 1

@smallexample
@group
(print-graph fiftieth-list-for-graph 50 10)
@end group
@end smallexample
@sp 1

@noindent
Here is the graph:
@sp 2

@smallexample
@group
1000 -  *
        **
        **
        **
        **
 750 -  ***
        ***
        ***
        ***
        ****
 500 - *****
       ******
       ******
       ******
       *******
 250 - ********
       *********                     *
       ***********                   *
       *************                 *
  50 - ***************** *           *
       |   |    |    |    |    |    |    |
      10  50  100  150  200  250  300  350
@end group
@end smallexample

@sp 2

@noindent
The largest group of functions contain 10 -- 19 words and symbols each.


@node Free Software and Free Manuals, GNU Free Documentation License, Full Graph, Top
@appendix Free Software and Free Manuals

@strong{by Richard M. Stallman}
@sp 1

The biggest deficiency in free operating systems is not in the
software---it is the lack of good free manuals that we can include in
these systems.  Many of our most important programs do not come with
full manuals.  Documentation is an essential part of any software
package; when an important free software package does not come with a
free manual, that is a major gap.  We have many such gaps today.

Once upon a time, many years ago, I thought I would learn Perl.  I got
a copy of a free manual, but I found it hard to read.  When I asked
Perl users about alternatives, they told me that there were better
introductory manuals---but those were not free.

Why was this?  The authors of the good manuals had written them for
O'Reilly Associates, which published them with restrictive terms---no
copying, no modification, source files not available---which exclude
them from the free software community.

That wasn't the first time this sort of thing has happened, and (to
our community's great loss) it was far from the last.  Proprietary
manual publishers have enticed a great many authors to restrict their
manuals since then.  Many times I have heard a GNU user eagerly tell me
about a manual that he is writing, with which he expects to help the
GNU project---and then had my hopes dashed, as he proceeded to explain
that he had signed a contract with a publisher that would restrict it
so that we cannot use it.

Given that writing good English is a rare skill among programmers, we
can ill afford to lose manuals this way.

Free documentation, like free software, is a matter of freedom, not
price.  The problem with these manuals was not that O'Reilly Associates
charged a price for printed copies---that in itself is fine.  The Free
Software Foundation @uref{http://shop.fsf.org, sells printed copies} of
free @uref{http://www.gnu.org/doc/doc.html, GNU manuals}, too.
But GNU manuals are available in source code form, while these manuals
are available only on paper.  GNU manuals come with permission to copy
and modify; the Perl manuals do not.  These restrictions are the
problems.

The criterion for a free manual is pretty much the same as for free
software: it is a matter of giving all users certain
freedoms.  Redistribution (including commercial redistribution) must be
permitted, so that the manual can accompany every copy of the program,
on-line or on paper.  Permission for modification is crucial too.

As a general rule, I don't believe that it is essential for people to
have permission to modify all sorts of articles and books.  The issues
for writings are not necessarily the same as those for software.  For
example, I don't think you or I are obliged to give permission to
modify articles like this one, which describe our actions and our
views.

But there is a particular reason why the freedom to modify is crucial
for documentation for free software.  When people exercise their right
to modify the software, and add or change its features, if they are
conscientious they will change the manual too---so they can provide
accurate and usable documentation with the modified program.  A manual
which forbids programmers to be conscientious and finish the job, or
more precisely requires them to write a new manual from scratch if
they change the program, does not fill our community's needs.

While a blanket prohibition on modification is unacceptable, some
kinds of limits on the method of modification pose no problem.  For
example, requirements to preserve the original author's copyright
notice, the distribution terms, or the list of authors, are ok.  It is
also no problem to require modified versions to include notice that
they were modified, even to have entire sections that may not be
deleted or changed, as long as these sections deal with nontechnical
topics.  (Some GNU manuals have them.)

These kinds of restrictions are not a problem because, as a practical
matter, they don't stop the conscientious programmer from adapting the
manual to fit the modified program.  In other words, they don't block
the free software community from making full use of the manual.

However, it must be possible to modify all the technical content of
the manual, and then distribute the result in all the usual media,
through all the usual channels; otherwise, the restrictions do block
the community, the manual is not free, and so we need another manual.

Unfortunately, it is often hard to find someone to write another
manual when a proprietary manual exists.  The obstacle is that many
users think that a proprietary manual is good enough---so they don't
see the need to write a free manual.  They do not see that the free
operating system has a gap that needs filling.

Why do users think that proprietary manuals are good enough? Some have
not considered the issue.  I hope this article will do something to
change that.

Other users consider proprietary manuals acceptable for the same
reason so many people consider proprietary software acceptable: they
judge in purely practical terms, not using freedom as a
criterion.  These people are entitled to their opinions, but since
those opinions spring from values which do not include freedom, they
are no guide for those of us who do value freedom.

Please spread the word about this issue.  We continue to lose manuals
to proprietary publishing.  If we spread the word that proprietary
manuals are not sufficient, perhaps the next person who wants to help
GNU by writing documentation will realize, before it is too late, that
he must above all make it free.

We can also encourage commercial publishers to sell free, copylefted
manuals instead of proprietary ones.  One way you can help this is to
check the distribution terms of a manual before you buy it, and prefer
copylefted manuals to non-copylefted ones.

@sp 2
@noindent
Note: The Free Software Foundation maintains a page on its Web site
that lists free books available from other publishers:@*
@uref{http://www.gnu.org/doc/other-free-books.html}


@node GNU Free Documentation License, Index, Free Software and Free Manuals, Top
@appendix GNU Free Documentation License

@cindex FDL, GNU Free Documentation License
@include doclicense.texi

@node Index, About the Author, GNU Free Documentation License, Top
@comment  node-name,  next,  previous,  up
@unnumbered Index

@ignore
MENU ENTRY: NODE NAME.
@end ignore

@printindex cp

@iftex
@c Place biographical information on right-hand (verso) page

@tex
\par\vfill\supereject
\ifodd\pageno
    \global\evenheadline={\hfil} \global\evenfootline={\hfil}
    \global\oddheadline={\hfil} \global\oddfootline={\hfil}
    %\page\hbox{}\page
\else
%    \par\vfill\supereject
    \global\evenheadline={\hfil} \global\evenfootline={\hfil}
    \global\oddheadline={\hfil} \global\oddfootline={\hfil}
    %\page\hbox{}%\page
    %\page\hbox{}%\page
\fi
@end tex

@c page
@w{ }

@c ================ Biographical information ================

@w{ }
@sp 8
@center About the Author
@sp 1
@end iftex

@ifnottex
@node About the Author,  , Index, Top
@unnumbered About the Author
@end ifnottex

@quotation
Robert J. Chassell has worked with GNU Emacs since 1985.  He writes
and edits, teaches Emacs and Emacs Lisp, and speaks throughout the
world on software freedom.  Chassell was a founding Director and
Treasurer of the Free Software Foundation, Inc.  He is co-author of
the @cite{Texinfo} manual, and has edited more than a dozen other
books.  He graduated from Cambridge University, in England.  He has an
abiding interest in social and economic history and flies his own
airplane.
@end quotation

@c @page
@c @w{ }
@c
@c @c Prevent page number on blank verso, so eject it first.
@c @tex
@c \par\vfill\supereject
@c @end tex

@c @iftex
@c @headings off
@c @evenheading @thispage @| @| @thistitle
@c @oddheading            @| @| @thispage
@c @end iftex

@bye

@ignore
   arch-tag: da1a2154-531f-43a8-8e33-fc7faad10acf
@end ignore
